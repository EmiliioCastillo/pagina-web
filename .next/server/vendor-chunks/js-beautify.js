/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/js-beautify";
exports.ids = ["vendor-chunks/js-beautify"];
exports.modules = {

/***/ "(action-browser)/./node_modules/js-beautify/js/index.js":
/*!**********************************************!*\
  !*** ./node_modules/js-beautify/js/index.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jshint node:true */ /* globals define */ /*\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n*/ \n/**\nThe following batches are equivalent:\n\nvar beautify_js = require('js-beautify');\nvar beautify_js = require('js-beautify').js;\nvar beautify_js = require('js-beautify').js_beautify;\n\nvar beautify_css = require('js-beautify').css;\nvar beautify_css = require('js-beautify').css_beautify;\n\nvar beautify_html = require('js-beautify').html;\nvar beautify_html = require('js-beautify').html_beautify;\n\nAll methods returned accept two arguments, the source string and an options object.\n**/ function get_beautify(js_beautify, css_beautify, html_beautify) {\n    // the default is js\n    var beautify = function(src, config) {\n        return js_beautify.js_beautify(src, config);\n    };\n    // short aliases\n    beautify.js = js_beautify.js_beautify;\n    beautify.css = css_beautify.css_beautify;\n    beautify.html = html_beautify.html_beautify;\n    // legacy aliases\n    beautify.js_beautify = js_beautify.js_beautify;\n    beautify.css_beautify = css_beautify.css_beautify;\n    beautify.html_beautify = html_beautify.html_beautify;\n    return beautify;\n}\nif (true) {\n    // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n        __webpack_require__(/*! ./lib/beautify */ \"(action-browser)/./node_modules/js-beautify/js/lib/beautify.js\"),\n        __webpack_require__(/*! ./lib/beautify-css */ \"(action-browser)/./node_modules/js-beautify/js/lib/beautify-css.js\"),\n        __webpack_require__(/*! ./lib/beautify-html */ \"(action-browser)/./node_modules/js-beautify/js/lib/beautify-html.js\")\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(js_beautify, css_beautify, html_beautify) {\n        return get_beautify(js_beautify, css_beautify, html_beautify);\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qcy1iZWF1dGlmeS9qcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtRkFBbUIsR0FDbkIsa0JBQWtCLEdBQ2xCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBLEdBRUE7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUVELFNBQVNBLGFBQWFDLFdBQVcsRUFBRUMsWUFBWSxFQUFFQyxhQUFhO0lBQzVELG9CQUFvQjtJQUNwQixJQUFJQyxXQUFXLFNBQVNDLEdBQUcsRUFBRUMsTUFBTTtRQUNqQyxPQUFPTCxZQUFZQSxXQUFXLENBQUNJLEtBQUtDO0lBQ3RDO0lBRUEsZ0JBQWdCO0lBQ2hCRixTQUFTRyxFQUFFLEdBQUdOLFlBQVlBLFdBQVc7SUFDckNHLFNBQVNJLEdBQUcsR0FBR04sYUFBYUEsWUFBWTtJQUN4Q0UsU0FBU0ssSUFBSSxHQUFHTixjQUFjQSxhQUFhO0lBRTNDLGlCQUFpQjtJQUNqQkMsU0FBU0gsV0FBVyxHQUFHQSxZQUFZQSxXQUFXO0lBQzlDRyxTQUFTRixZQUFZLEdBQUdBLGFBQWFBLFlBQVk7SUFDakRFLFNBQVNELGFBQWEsR0FBR0EsY0FBY0EsYUFBYTtJQUVwRCxPQUFPQztBQUNUO0FBRUEsSUFBSSxJQUEwQyxFQUFFO0lBQzlDLDBGQUEwRjtJQUMxRk0saUNBQU87UUFDTCwyR0FBZ0I7UUFDaEIsbUhBQW9CO1FBQ3BCLHFIQUFxQjtLQUN0QixtQ0FBRSxTQUFTVCxXQUFXLEVBQUVDLFlBQVksRUFBRUMsYUFBYTtRQUNsRCxPQUFPSCxhQUFhQyxhQUFhQyxjQUFjQztJQUNqRCxDQUFDO0FBQUEsa0dBQUM7QUFDSixPQUFPLEVBVU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcGVuLXByby1uZXh0Ly4vbm9kZV9tb2R1bGVzL2pzLWJlYXV0aWZ5L2pzL2luZGV4LmpzPzFjYTgiXSwic291cmNlc0NvbnRlbnQiOlsiLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKiBnbG9iYWxzIGRlZmluZSAqL1xuLypcbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuVGhlIGZvbGxvd2luZyBiYXRjaGVzIGFyZSBlcXVpdmFsZW50OlxuXG52YXIgYmVhdXRpZnlfanMgPSByZXF1aXJlKCdqcy1iZWF1dGlmeScpO1xudmFyIGJlYXV0aWZ5X2pzID0gcmVxdWlyZSgnanMtYmVhdXRpZnknKS5qcztcbnZhciBiZWF1dGlmeV9qcyA9IHJlcXVpcmUoJ2pzLWJlYXV0aWZ5JykuanNfYmVhdXRpZnk7XG5cbnZhciBiZWF1dGlmeV9jc3MgPSByZXF1aXJlKCdqcy1iZWF1dGlmeScpLmNzcztcbnZhciBiZWF1dGlmeV9jc3MgPSByZXF1aXJlKCdqcy1iZWF1dGlmeScpLmNzc19iZWF1dGlmeTtcblxudmFyIGJlYXV0aWZ5X2h0bWwgPSByZXF1aXJlKCdqcy1iZWF1dGlmeScpLmh0bWw7XG52YXIgYmVhdXRpZnlfaHRtbCA9IHJlcXVpcmUoJ2pzLWJlYXV0aWZ5JykuaHRtbF9iZWF1dGlmeTtcblxuQWxsIG1ldGhvZHMgcmV0dXJuZWQgYWNjZXB0IHR3byBhcmd1bWVudHMsIHRoZSBzb3VyY2Ugc3RyaW5nIGFuZCBhbiBvcHRpb25zIG9iamVjdC5cbioqL1xuXG5mdW5jdGlvbiBnZXRfYmVhdXRpZnkoanNfYmVhdXRpZnksIGNzc19iZWF1dGlmeSwgaHRtbF9iZWF1dGlmeSkge1xuICAvLyB0aGUgZGVmYXVsdCBpcyBqc1xuICB2YXIgYmVhdXRpZnkgPSBmdW5jdGlvbihzcmMsIGNvbmZpZykge1xuICAgIHJldHVybiBqc19iZWF1dGlmeS5qc19iZWF1dGlmeShzcmMsIGNvbmZpZyk7XG4gIH07XG5cbiAgLy8gc2hvcnQgYWxpYXNlc1xuICBiZWF1dGlmeS5qcyA9IGpzX2JlYXV0aWZ5LmpzX2JlYXV0aWZ5O1xuICBiZWF1dGlmeS5jc3MgPSBjc3NfYmVhdXRpZnkuY3NzX2JlYXV0aWZ5O1xuICBiZWF1dGlmeS5odG1sID0gaHRtbF9iZWF1dGlmeS5odG1sX2JlYXV0aWZ5O1xuXG4gIC8vIGxlZ2FjeSBhbGlhc2VzXG4gIGJlYXV0aWZ5LmpzX2JlYXV0aWZ5ID0ganNfYmVhdXRpZnkuanNfYmVhdXRpZnk7XG4gIGJlYXV0aWZ5LmNzc19iZWF1dGlmeSA9IGNzc19iZWF1dGlmeS5jc3NfYmVhdXRpZnk7XG4gIGJlYXV0aWZ5Lmh0bWxfYmVhdXRpZnkgPSBodG1sX2JlYXV0aWZ5Lmh0bWxfYmVhdXRpZnk7XG5cbiAgcmV0dXJuIGJlYXV0aWZ5O1xufVxuXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgLy8gQWRkIHN1cHBvcnQgZm9yIEFNRCAoIGh0dHBzOi8vZ2l0aHViLmNvbS9hbWRqcy9hbWRqcy1hcGkvd2lraS9BTUQjZGVmaW5lYW1kLXByb3BlcnR5LSApXG4gIGRlZmluZShbXG4gICAgXCIuL2xpYi9iZWF1dGlmeVwiLFxuICAgIFwiLi9saWIvYmVhdXRpZnktY3NzXCIsXG4gICAgXCIuL2xpYi9iZWF1dGlmeS1odG1sXCJcbiAgXSwgZnVuY3Rpb24oanNfYmVhdXRpZnksIGNzc19iZWF1dGlmeSwgaHRtbF9iZWF1dGlmeSkge1xuICAgIHJldHVybiBnZXRfYmVhdXRpZnkoanNfYmVhdXRpZnksIGNzc19iZWF1dGlmeSwgaHRtbF9iZWF1dGlmeSk7XG4gIH0pO1xufSBlbHNlIHtcbiAgKGZ1bmN0aW9uKG1vZCkge1xuICAgIHZhciBiZWF1dGlmaWVyID0gcmVxdWlyZSgnLi9zcmMvaW5kZXgnKTtcbiAgICBiZWF1dGlmaWVyLmpzX2JlYXV0aWZ5ID0gYmVhdXRpZmllci5qcztcbiAgICBiZWF1dGlmaWVyLmNzc19iZWF1dGlmeSA9IGJlYXV0aWZpZXIuY3NzO1xuICAgIGJlYXV0aWZpZXIuaHRtbF9iZWF1dGlmeSA9IGJlYXV0aWZpZXIuaHRtbDtcblxuICAgIG1vZC5leHBvcnRzID0gZ2V0X2JlYXV0aWZ5KGJlYXV0aWZpZXIsIGJlYXV0aWZpZXIsIGJlYXV0aWZpZXIpO1xuXG4gIH0pKG1vZHVsZSk7XG59Il0sIm5hbWVzIjpbImdldF9iZWF1dGlmeSIsImpzX2JlYXV0aWZ5IiwiY3NzX2JlYXV0aWZ5IiwiaHRtbF9iZWF1dGlmeSIsImJlYXV0aWZ5Iiwic3JjIiwiY29uZmlnIiwianMiLCJjc3MiLCJodG1sIiwiZGVmaW5lIiwiYW1kIiwibW9kIiwiYmVhdXRpZmllciIsInJlcXVpcmUiLCJleHBvcnRzIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/js-beautify/js/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/js-beautify/js/lib/beautify-css.js":
/*!*********************************************************!*\
  !*** ./node_modules/js-beautify/js/lib/beautify-css.js ***!
  \*********************************************************/
/***/ ((module, exports) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* AUTO-GENERATED. DO NOT MODIFY. */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n\n CSS Beautifier\n---------------\n\n    Written by Harutyun Amirjanyan, (amirjanyan@gmail.com)\n\n    Based on code initially developed by: Einar Lielmanis, <einar@beautifier.io>\n        https://beautifier.io/\n\n    Usage:\n        css_beautify(source_text);\n        css_beautify(source_text, options);\n\n    The options are (default in brackets):\n        indent_size (4)                         — indentation size,\n        indent_char (space)                     — character to indent with,\n        selector_separator_newline (true)       - separate selectors with newline or\n                                                  not (e.g. \"a,\\nbr\" or \"a, br\")\n        end_with_newline (false)                - end with a newline\n        newline_between_rules (true)            - add a new line after every css rule\n        space_around_selector_separator (false) - ensure space around selector separators:\n                                                  '>', '+', '~' (e.g. \"a>b\" -> \"a > b\")\n    e.g\n\n    css_beautify(css_source_text, {\n      'indent_size': 1,\n      'indent_char': '\\t',\n      'selector_separator': ' ',\n      'end_with_newline': false,\n      'newline_between_rules': true,\n      'space_around_selector_separator': true\n    });\n*/ // http://www.w3.org/TR/CSS21/syndata.html#tokenization\n// http://www.w3.org/TR/css3-syntax/\n(function() {\n    /* GENERATED_BUILD_OUTPUT */ var legacy_beautify_css;\n    /******/ (function() {\n        /******/ \"use strict\";\n        /******/ var __webpack_modules__ = [\n            ,\n            ,\n            /* 2 */ /***/ function(module) {\n                /*jshint node:true */ /*\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function OutputLine(parent) {\n                    this.__parent = parent;\n                    this.__character_count = 0;\n                    // use indent_count as a marker for this.__lines that have preserved indentation\n                    this.__indent_count = -1;\n                    this.__alignment_count = 0;\n                    this.__wrap_point_index = 0;\n                    this.__wrap_point_character_count = 0;\n                    this.__wrap_point_indent_count = -1;\n                    this.__wrap_point_alignment_count = 0;\n                    this.__items = [];\n                }\n                OutputLine.prototype.clone_empty = function() {\n                    var line = new OutputLine(this.__parent);\n                    line.set_indent(this.__indent_count, this.__alignment_count);\n                    return line;\n                };\n                OutputLine.prototype.item = function(index) {\n                    if (index < 0) {\n                        return this.__items[this.__items.length + index];\n                    } else {\n                        return this.__items[index];\n                    }\n                };\n                OutputLine.prototype.has_match = function(pattern) {\n                    for(var lastCheckedOutput = this.__items.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--){\n                        if (this.__items[lastCheckedOutput].match(pattern)) {\n                            return true;\n                        }\n                    }\n                    return false;\n                };\n                OutputLine.prototype.set_indent = function(indent, alignment) {\n                    if (this.is_empty()) {\n                        this.__indent_count = indent || 0;\n                        this.__alignment_count = alignment || 0;\n                        this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);\n                    }\n                };\n                OutputLine.prototype._set_wrap_point = function() {\n                    if (this.__parent.wrap_line_length) {\n                        this.__wrap_point_index = this.__items.length;\n                        this.__wrap_point_character_count = this.__character_count;\n                        this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;\n                        this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;\n                    }\n                };\n                OutputLine.prototype._should_wrap = function() {\n                    return this.__wrap_point_index && this.__character_count > this.__parent.wrap_line_length && this.__wrap_point_character_count > this.__parent.next_line.__character_count;\n                };\n                OutputLine.prototype._allow_wrap = function() {\n                    if (this._should_wrap()) {\n                        this.__parent.add_new_line();\n                        var next = this.__parent.current_line;\n                        next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);\n                        next.__items = this.__items.slice(this.__wrap_point_index);\n                        this.__items = this.__items.slice(0, this.__wrap_point_index);\n                        next.__character_count += this.__character_count - this.__wrap_point_character_count;\n                        this.__character_count = this.__wrap_point_character_count;\n                        if (next.__items[0] === \" \") {\n                            next.__items.splice(0, 1);\n                            next.__character_count -= 1;\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n                OutputLine.prototype.is_empty = function() {\n                    return this.__items.length === 0;\n                };\n                OutputLine.prototype.last = function() {\n                    if (!this.is_empty()) {\n                        return this.__items[this.__items.length - 1];\n                    } else {\n                        return null;\n                    }\n                };\n                OutputLine.prototype.push = function(item) {\n                    this.__items.push(item);\n                    var last_newline_index = item.lastIndexOf(\"\\n\");\n                    if (last_newline_index !== -1) {\n                        this.__character_count = item.length - last_newline_index;\n                    } else {\n                        this.__character_count += item.length;\n                    }\n                };\n                OutputLine.prototype.pop = function() {\n                    var item = null;\n                    if (!this.is_empty()) {\n                        item = this.__items.pop();\n                        this.__character_count -= item.length;\n                    }\n                    return item;\n                };\n                OutputLine.prototype._remove_indent = function() {\n                    if (this.__indent_count > 0) {\n                        this.__indent_count -= 1;\n                        this.__character_count -= this.__parent.indent_size;\n                    }\n                };\n                OutputLine.prototype._remove_wrap_indent = function() {\n                    if (this.__wrap_point_indent_count > 0) {\n                        this.__wrap_point_indent_count -= 1;\n                    }\n                };\n                OutputLine.prototype.trim = function() {\n                    while(this.last() === \" \"){\n                        this.__items.pop();\n                        this.__character_count -= 1;\n                    }\n                };\n                OutputLine.prototype.toString = function() {\n                    var result = \"\";\n                    if (this.is_empty()) {\n                        if (this.__parent.indent_empty_lines) {\n                            result = this.__parent.get_indent_string(this.__indent_count);\n                        }\n                    } else {\n                        result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);\n                        result += this.__items.join(\"\");\n                    }\n                    return result;\n                };\n                function IndentStringCache(options, baseIndentString) {\n                    this.__cache = [\n                        \"\"\n                    ];\n                    this.__indent_size = options.indent_size;\n                    this.__indent_string = options.indent_char;\n                    if (!options.indent_with_tabs) {\n                        this.__indent_string = new Array(options.indent_size + 1).join(options.indent_char);\n                    }\n                    // Set to null to continue support for auto detection of base indent\n                    baseIndentString = baseIndentString || \"\";\n                    if (options.indent_level > 0) {\n                        baseIndentString = new Array(options.indent_level + 1).join(this.__indent_string);\n                    }\n                    this.__base_string = baseIndentString;\n                    this.__base_string_length = baseIndentString.length;\n                }\n                IndentStringCache.prototype.get_indent_size = function(indent, column) {\n                    var result = this.__base_string_length;\n                    column = column || 0;\n                    if (indent < 0) {\n                        result = 0;\n                    }\n                    result += indent * this.__indent_size;\n                    result += column;\n                    return result;\n                };\n                IndentStringCache.prototype.get_indent_string = function(indent_level, column) {\n                    var result = this.__base_string;\n                    column = column || 0;\n                    if (indent_level < 0) {\n                        indent_level = 0;\n                        result = \"\";\n                    }\n                    column += indent_level * this.__indent_size;\n                    this.__ensure_cache(column);\n                    result += this.__cache[column];\n                    return result;\n                };\n                IndentStringCache.prototype.__ensure_cache = function(column) {\n                    while(column >= this.__cache.length){\n                        this.__add_column();\n                    }\n                };\n                IndentStringCache.prototype.__add_column = function() {\n                    var column = this.__cache.length;\n                    var indent = 0;\n                    var result = \"\";\n                    if (this.__indent_size && column >= this.__indent_size) {\n                        indent = Math.floor(column / this.__indent_size);\n                        column -= indent * this.__indent_size;\n                        result = new Array(indent + 1).join(this.__indent_string);\n                    }\n                    if (column) {\n                        result += new Array(column + 1).join(\" \");\n                    }\n                    this.__cache.push(result);\n                };\n                function Output(options, baseIndentString) {\n                    this.__indent_cache = new IndentStringCache(options, baseIndentString);\n                    this.raw = false;\n                    this._end_with_newline = options.end_with_newline;\n                    this.indent_size = options.indent_size;\n                    this.wrap_line_length = options.wrap_line_length;\n                    this.indent_empty_lines = options.indent_empty_lines;\n                    this.__lines = [];\n                    this.previous_line = null;\n                    this.current_line = null;\n                    this.next_line = new OutputLine(this);\n                    this.space_before_token = false;\n                    this.non_breaking_space = false;\n                    this.previous_token_wrapped = false;\n                    // initialize\n                    this.__add_outputline();\n                }\n                Output.prototype.__add_outputline = function() {\n                    this.previous_line = this.current_line;\n                    this.current_line = this.next_line.clone_empty();\n                    this.__lines.push(this.current_line);\n                };\n                Output.prototype.get_line_number = function() {\n                    return this.__lines.length;\n                };\n                Output.prototype.get_indent_string = function(indent, column) {\n                    return this.__indent_cache.get_indent_string(indent, column);\n                };\n                Output.prototype.get_indent_size = function(indent, column) {\n                    return this.__indent_cache.get_indent_size(indent, column);\n                };\n                Output.prototype.is_empty = function() {\n                    return !this.previous_line && this.current_line.is_empty();\n                };\n                Output.prototype.add_new_line = function(force_newline) {\n                    // never newline at the start of file\n                    // otherwise, newline only if we didn't just add one or we're forced\n                    if (this.is_empty() || !force_newline && this.just_added_newline()) {\n                        return false;\n                    }\n                    // if raw output is enabled, don't print additional newlines,\n                    // but still return True as though you had\n                    if (!this.raw) {\n                        this.__add_outputline();\n                    }\n                    return true;\n                };\n                Output.prototype.get_code = function(eol) {\n                    this.trim(true);\n                    // handle some edge cases where the last tokens\n                    // has text that ends with newline(s)\n                    var last_item = this.current_line.pop();\n                    if (last_item) {\n                        if (last_item[last_item.length - 1] === \"\\n\") {\n                            last_item = last_item.replace(/\\n+$/g, \"\");\n                        }\n                        this.current_line.push(last_item);\n                    }\n                    if (this._end_with_newline) {\n                        this.__add_outputline();\n                    }\n                    var sweet_code = this.__lines.join(\"\\n\");\n                    if (eol !== \"\\n\") {\n                        sweet_code = sweet_code.replace(/[\\n]/g, eol);\n                    }\n                    return sweet_code;\n                };\n                Output.prototype.set_wrap_point = function() {\n                    this.current_line._set_wrap_point();\n                };\n                Output.prototype.set_indent = function(indent, alignment) {\n                    indent = indent || 0;\n                    alignment = alignment || 0;\n                    // Next line stores alignment values\n                    this.next_line.set_indent(indent, alignment);\n                    // Never indent your first output indent at the start of the file\n                    if (this.__lines.length > 1) {\n                        this.current_line.set_indent(indent, alignment);\n                        return true;\n                    }\n                    this.current_line.set_indent();\n                    return false;\n                };\n                Output.prototype.add_raw_token = function(token) {\n                    for(var x = 0; x < token.newlines; x++){\n                        this.__add_outputline();\n                    }\n                    this.current_line.set_indent(-1);\n                    this.current_line.push(token.whitespace_before);\n                    this.current_line.push(token.text);\n                    this.space_before_token = false;\n                    this.non_breaking_space = false;\n                    this.previous_token_wrapped = false;\n                };\n                Output.prototype.add_token = function(printable_token) {\n                    this.__add_space_before_token();\n                    this.current_line.push(printable_token);\n                    this.space_before_token = false;\n                    this.non_breaking_space = false;\n                    this.previous_token_wrapped = this.current_line._allow_wrap();\n                };\n                Output.prototype.__add_space_before_token = function() {\n                    if (this.space_before_token && !this.just_added_newline()) {\n                        if (!this.non_breaking_space) {\n                            this.set_wrap_point();\n                        }\n                        this.current_line.push(\" \");\n                    }\n                };\n                Output.prototype.remove_indent = function(index) {\n                    var output_length = this.__lines.length;\n                    while(index < output_length){\n                        this.__lines[index]._remove_indent();\n                        index++;\n                    }\n                    this.current_line._remove_wrap_indent();\n                };\n                Output.prototype.trim = function(eat_newlines) {\n                    eat_newlines = eat_newlines === undefined ? false : eat_newlines;\n                    this.current_line.trim();\n                    while(eat_newlines && this.__lines.length > 1 && this.current_line.is_empty()){\n                        this.__lines.pop();\n                        this.current_line = this.__lines[this.__lines.length - 1];\n                        this.current_line.trim();\n                    }\n                    this.previous_line = this.__lines.length > 1 ? this.__lines[this.__lines.length - 2] : null;\n                };\n                Output.prototype.just_added_newline = function() {\n                    return this.current_line.is_empty();\n                };\n                Output.prototype.just_added_blankline = function() {\n                    return this.is_empty() || this.current_line.is_empty() && this.previous_line.is_empty();\n                };\n                Output.prototype.ensure_empty_line_above = function(starts_with, ends_with) {\n                    var index = this.__lines.length - 2;\n                    while(index >= 0){\n                        var potentialEmptyLine = this.__lines[index];\n                        if (potentialEmptyLine.is_empty()) {\n                            break;\n                        } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 && potentialEmptyLine.item(-1) !== ends_with) {\n                            this.__lines.splice(index + 1, 0, new OutputLine(this));\n                            this.previous_line = this.__lines[this.__lines.length - 2];\n                            break;\n                        }\n                        index--;\n                    }\n                };\n                module.exports.Output = Output;\n            /***/ },\n            ,\n            ,\n            ,\n            /* 6 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function Options(options, merge_child_field) {\n                    this.raw_options = _mergeOpts(options, merge_child_field);\n                    // Support passing the source text back with no change\n                    this.disabled = this._get_boolean(\"disabled\");\n                    this.eol = this._get_characters(\"eol\", \"auto\");\n                    this.end_with_newline = this._get_boolean(\"end_with_newline\");\n                    this.indent_size = this._get_number(\"indent_size\", 4);\n                    this.indent_char = this._get_characters(\"indent_char\", \" \");\n                    this.indent_level = this._get_number(\"indent_level\");\n                    this.preserve_newlines = this._get_boolean(\"preserve_newlines\", true);\n                    this.max_preserve_newlines = this._get_number(\"max_preserve_newlines\", 32786);\n                    if (!this.preserve_newlines) {\n                        this.max_preserve_newlines = 0;\n                    }\n                    this.indent_with_tabs = this._get_boolean(\"indent_with_tabs\", this.indent_char === \"\t\");\n                    if (this.indent_with_tabs) {\n                        this.indent_char = \"\t\";\n                        // indent_size behavior changed after 1.8.6\n                        // It used to be that indent_size would be\n                        // set to 1 for indent_with_tabs. That is no longer needed and\n                        // actually doesn't make sense - why not use spaces? Further,\n                        // that might produce unexpected behavior - tabs being used\n                        // for single-column alignment. So, when indent_with_tabs is true\n                        // and indent_size is 1, reset indent_size to 4.\n                        if (this.indent_size === 1) {\n                            this.indent_size = 4;\n                        }\n                    }\n                    // Backwards compat with 1.3.x\n                    this.wrap_line_length = this._get_number(\"wrap_line_length\", this._get_number(\"max_char\"));\n                    this.indent_empty_lines = this._get_boolean(\"indent_empty_lines\");\n                    // valid templating languages ['django', 'erb', 'handlebars', 'php', 'smarty']\n                    // For now, 'auto' = all off for javascript, all on for html (and inline javascript).\n                    // other values ignored\n                    this.templating = this._get_selection_list(\"templating\", [\n                        \"auto\",\n                        \"none\",\n                        \"django\",\n                        \"erb\",\n                        \"handlebars\",\n                        \"php\",\n                        \"smarty\"\n                    ], [\n                        \"auto\"\n                    ]);\n                }\n                Options.prototype._get_array = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    var result = default_value || [];\n                    if (typeof option_value === \"object\") {\n                        if (option_value !== null && typeof option_value.concat === \"function\") {\n                            result = option_value.concat();\n                        }\n                    } else if (typeof option_value === \"string\") {\n                        result = option_value.split(/[^a-zA-Z0-9_\\/\\-]+/);\n                    }\n                    return result;\n                };\n                Options.prototype._get_boolean = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    var result = option_value === undefined ? !!default_value : !!option_value;\n                    return result;\n                };\n                Options.prototype._get_characters = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    var result = default_value || \"\";\n                    if (typeof option_value === \"string\") {\n                        result = option_value.replace(/\\\\r/, \"\\r\").replace(/\\\\n/, \"\\n\").replace(/\\\\t/, \"\t\");\n                    }\n                    return result;\n                };\n                Options.prototype._get_number = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    default_value = parseInt(default_value, 10);\n                    if (isNaN(default_value)) {\n                        default_value = 0;\n                    }\n                    var result = parseInt(option_value, 10);\n                    if (isNaN(result)) {\n                        result = default_value;\n                    }\n                    return result;\n                };\n                Options.prototype._get_selection = function(name, selection_list, default_value) {\n                    var result = this._get_selection_list(name, selection_list, default_value);\n                    if (result.length !== 1) {\n                        throw new Error(\"Invalid Option Value: The option '\" + name + \"' can only be one of the following values:\\n\" + selection_list + \"\\nYou passed in: '\" + this.raw_options[name] + \"'\");\n                    }\n                    return result[0];\n                };\n                Options.prototype._get_selection_list = function(name, selection_list, default_value) {\n                    if (!selection_list || selection_list.length === 0) {\n                        throw new Error(\"Selection list cannot be empty.\");\n                    }\n                    default_value = default_value || [\n                        selection_list[0]\n                    ];\n                    if (!this._is_valid_selection(default_value, selection_list)) {\n                        throw new Error(\"Invalid Default Value!\");\n                    }\n                    var result = this._get_array(name, default_value);\n                    if (!this._is_valid_selection(result, selection_list)) {\n                        throw new Error(\"Invalid Option Value: The option '\" + name + \"' can contain only the following values:\\n\" + selection_list + \"\\nYou passed in: '\" + this.raw_options[name] + \"'\");\n                    }\n                    return result;\n                };\n                Options.prototype._is_valid_selection = function(result, selection_list) {\n                    return result.length && selection_list.length && !result.some(function(item) {\n                        return selection_list.indexOf(item) === -1;\n                    });\n                };\n                // merges child options up with the parent options object\n                // Example: obj = {a: 1, b: {a: 2}}\n                //          mergeOpts(obj, 'b')\n                //\n                //          Returns: {a: 2}\n                function _mergeOpts(allOptions, childFieldName) {\n                    var finalOpts = {};\n                    allOptions = _normalizeOpts(allOptions);\n                    var name;\n                    for(name in allOptions){\n                        if (name !== childFieldName) {\n                            finalOpts[name] = allOptions[name];\n                        }\n                    }\n                    //merge in the per type settings for the childFieldName\n                    if (childFieldName && allOptions[childFieldName]) {\n                        for(name in allOptions[childFieldName]){\n                            finalOpts[name] = allOptions[childFieldName][name];\n                        }\n                    }\n                    return finalOpts;\n                }\n                function _normalizeOpts(options) {\n                    var convertedOpts = {};\n                    var key;\n                    for(key in options){\n                        var newKey = key.replace(/-/g, \"_\");\n                        convertedOpts[newKey] = options[key];\n                    }\n                    return convertedOpts;\n                }\n                module.exports.Options = Options;\n                module.exports.normalizeOpts = _normalizeOpts;\n                module.exports.mergeOpts = _mergeOpts;\n            /***/ },\n            ,\n            /* 8 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var regexp_has_sticky = RegExp.prototype.hasOwnProperty(\"sticky\");\n                function InputScanner(input_string) {\n                    this.__input = input_string || \"\";\n                    this.__input_length = this.__input.length;\n                    this.__position = 0;\n                }\n                InputScanner.prototype.restart = function() {\n                    this.__position = 0;\n                };\n                InputScanner.prototype.back = function() {\n                    if (this.__position > 0) {\n                        this.__position -= 1;\n                    }\n                };\n                InputScanner.prototype.hasNext = function() {\n                    return this.__position < this.__input_length;\n                };\n                InputScanner.prototype.next = function() {\n                    var val = null;\n                    if (this.hasNext()) {\n                        val = this.__input.charAt(this.__position);\n                        this.__position += 1;\n                    }\n                    return val;\n                };\n                InputScanner.prototype.peek = function(index) {\n                    var val = null;\n                    index = index || 0;\n                    index += this.__position;\n                    if (index >= 0 && index < this.__input_length) {\n                        val = this.__input.charAt(index);\n                    }\n                    return val;\n                };\n                // This is a JavaScript only helper function (not in python)\n                // Javascript doesn't have a match method\n                // and not all implementation support \"sticky\" flag.\n                // If they do not support sticky then both this.match() and this.test() method\n                // must get the match and check the index of the match.\n                // If sticky is supported and set, this method will use it.\n                // Otherwise it will check that global is set, and fall back to the slower method.\n                InputScanner.prototype.__match = function(pattern, index) {\n                    pattern.lastIndex = index;\n                    var pattern_match = pattern.exec(this.__input);\n                    if (pattern_match && !(regexp_has_sticky && pattern.sticky)) {\n                        if (pattern_match.index !== index) {\n                            pattern_match = null;\n                        }\n                    }\n                    return pattern_match;\n                };\n                InputScanner.prototype.test = function(pattern, index) {\n                    index = index || 0;\n                    index += this.__position;\n                    if (index >= 0 && index < this.__input_length) {\n                        return !!this.__match(pattern, index);\n                    } else {\n                        return false;\n                    }\n                };\n                InputScanner.prototype.testChar = function(pattern, index) {\n                    // test one character regex match\n                    var val = this.peek(index);\n                    pattern.lastIndex = 0;\n                    return val !== null && pattern.test(val);\n                };\n                InputScanner.prototype.match = function(pattern) {\n                    var pattern_match = this.__match(pattern, this.__position);\n                    if (pattern_match) {\n                        this.__position += pattern_match[0].length;\n                    } else {\n                        pattern_match = null;\n                    }\n                    return pattern_match;\n                };\n                InputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {\n                    var val = \"\";\n                    var match;\n                    if (starting_pattern) {\n                        match = this.match(starting_pattern);\n                        if (match) {\n                            val += match[0];\n                        }\n                    }\n                    if (until_pattern && (match || !starting_pattern)) {\n                        val += this.readUntil(until_pattern, until_after);\n                    }\n                    return val;\n                };\n                InputScanner.prototype.readUntil = function(pattern, until_after) {\n                    var val = \"\";\n                    var match_index = this.__position;\n                    pattern.lastIndex = this.__position;\n                    var pattern_match = pattern.exec(this.__input);\n                    if (pattern_match) {\n                        match_index = pattern_match.index;\n                        if (until_after) {\n                            match_index += pattern_match[0].length;\n                        }\n                    } else {\n                        match_index = this.__input_length;\n                    }\n                    val = this.__input.substring(this.__position, match_index);\n                    this.__position = match_index;\n                    return val;\n                };\n                InputScanner.prototype.readUntilAfter = function(pattern) {\n                    return this.readUntil(pattern, true);\n                };\n                InputScanner.prototype.get_regexp = function(pattern, match_from) {\n                    var result = null;\n                    var flags = \"g\";\n                    if (match_from && regexp_has_sticky) {\n                        flags = \"y\";\n                    }\n                    // strings are converted to regexp\n                    if (typeof pattern === \"string\" && pattern !== \"\") {\n                        // result = new RegExp(pattern.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'), flags);\n                        result = new RegExp(pattern, flags);\n                    } else if (pattern) {\n                        result = new RegExp(pattern.source, flags);\n                    }\n                    return result;\n                };\n                InputScanner.prototype.get_literal_regexp = function(literal_string) {\n                    return RegExp(literal_string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\"));\n                };\n                /* css beautifier legacy helpers */ InputScanner.prototype.peekUntilAfter = function(pattern) {\n                    var start = this.__position;\n                    var val = this.readUntilAfter(pattern);\n                    this.__position = start;\n                    return val;\n                };\n                InputScanner.prototype.lookBack = function(testVal) {\n                    var start = this.__position - 1;\n                    return start >= testVal.length && this.__input.substring(start - testVal.length, start).toLowerCase() === testVal;\n                };\n                module.exports.InputScanner = InputScanner;\n            /***/ },\n            ,\n            ,\n            ,\n            ,\n            /* 13 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function Directives(start_block_pattern, end_block_pattern) {\n                    start_block_pattern = typeof start_block_pattern === \"string\" ? start_block_pattern : start_block_pattern.source;\n                    end_block_pattern = typeof end_block_pattern === \"string\" ? end_block_pattern : end_block_pattern.source;\n                    this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \\w+[:]\\w+)+ /.source + end_block_pattern, \"g\");\n                    this.__directive_pattern = / (\\w+)[:](\\w+)/g;\n                    this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\\sbeautify\\signore:end\\s/.source + end_block_pattern, \"g\");\n                }\n                Directives.prototype.get_directives = function(text) {\n                    if (!text.match(this.__directives_block_pattern)) {\n                        return null;\n                    }\n                    var directives = {};\n                    this.__directive_pattern.lastIndex = 0;\n                    var directive_match = this.__directive_pattern.exec(text);\n                    while(directive_match){\n                        directives[directive_match[1]] = directive_match[2];\n                        directive_match = this.__directive_pattern.exec(text);\n                    }\n                    return directives;\n                };\n                Directives.prototype.readIgnored = function(input) {\n                    return input.readUntilAfter(this.__directives_end_ignore_pattern);\n                };\n                module.exports.Directives = Directives;\n            /***/ },\n            ,\n            /* 15 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_41569__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var Beautifier = __nested_webpack_require_41569__(16).Beautifier, Options = __nested_webpack_require_41569__(17).Options;\n                function css_beautify(source_text, options) {\n                    var beautifier = new Beautifier(source_text, options);\n                    return beautifier.beautify();\n                }\n                module.exports = css_beautify;\n                module.exports.defaultOptions = function() {\n                    return new Options();\n                };\n            /***/ },\n            /* 16 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_43355__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var Options = __nested_webpack_require_43355__(17).Options;\n                var Output = __nested_webpack_require_43355__(2).Output;\n                var InputScanner = __nested_webpack_require_43355__(8).InputScanner;\n                var Directives = __nested_webpack_require_43355__(13).Directives;\n                var directives_core = new Directives(/\\/\\*/, /\\*\\//);\n                var lineBreak = /\\r\\n|[\\r\\n]/;\n                var allLineBreaks = /\\r\\n|[\\r\\n]/g;\n                // tokenizer\n                var whitespaceChar = /\\s/;\n                var whitespacePattern = /(?:\\s|\\n)+/g;\n                var block_comment_pattern = /\\/\\*(?:[\\s\\S]*?)((?:\\*\\/)|$)/g;\n                var comment_pattern = /\\/\\/(?:[^\\n\\r\\u2028\\u2029]*)/g;\n                function Beautifier(source_text, options) {\n                    this._source_text = source_text || \"\";\n                    // Allow the setting of language/file-type specific options\n                    // with inheritance of overall settings\n                    this._options = new Options(options);\n                    this._ch = null;\n                    this._input = null;\n                    // https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule\n                    this.NESTED_AT_RULE = {\n                        \"page\": true,\n                        \"font-face\": true,\n                        \"keyframes\": true,\n                        // also in CONDITIONAL_GROUP_RULE below\n                        \"media\": true,\n                        \"supports\": true,\n                        \"document\": true\n                    };\n                    this.CONDITIONAL_GROUP_RULE = {\n                        \"media\": true,\n                        \"supports\": true,\n                        \"document\": true\n                    };\n                    this.NON_SEMICOLON_NEWLINE_PROPERTY = [\n                        \"grid-template-areas\",\n                        \"grid-template\"\n                    ];\n                }\n                Beautifier.prototype.eatString = function(endChars) {\n                    var result = \"\";\n                    this._ch = this._input.next();\n                    while(this._ch){\n                        result += this._ch;\n                        if (this._ch === \"\\\\\") {\n                            result += this._input.next();\n                        } else if (endChars.indexOf(this._ch) !== -1 || this._ch === \"\\n\") {\n                            break;\n                        }\n                        this._ch = this._input.next();\n                    }\n                    return result;\n                };\n                // Skips any white space in the source text from the current position.\n                // When allowAtLeastOneNewLine is true, will output new lines for each\n                // newline character found; if the user has preserve_newlines off, only\n                // the first newline will be output\n                Beautifier.prototype.eatWhitespace = function(allowAtLeastOneNewLine) {\n                    var result = whitespaceChar.test(this._input.peek());\n                    var newline_count = 0;\n                    while(whitespaceChar.test(this._input.peek())){\n                        this._ch = this._input.next();\n                        if (allowAtLeastOneNewLine && this._ch === \"\\n\") {\n                            if (newline_count === 0 || newline_count < this._options.max_preserve_newlines) {\n                                newline_count++;\n                                this._output.add_new_line(true);\n                            }\n                        }\n                    }\n                    return result;\n                };\n                // Nested pseudo-class if we are insideRule\n                // and the next special character found opens\n                // a new block\n                Beautifier.prototype.foundNestedPseudoClass = function() {\n                    var openParen = 0;\n                    var i = 1;\n                    var ch = this._input.peek(i);\n                    while(ch){\n                        if (ch === \"{\") {\n                            return true;\n                        } else if (ch === \"(\") {\n                            // pseudoclasses can contain ()\n                            openParen += 1;\n                        } else if (ch === \")\") {\n                            if (openParen === 0) {\n                                return false;\n                            }\n                            openParen -= 1;\n                        } else if (ch === \";\" || ch === \"}\") {\n                            return false;\n                        }\n                        i++;\n                        ch = this._input.peek(i);\n                    }\n                    return false;\n                };\n                Beautifier.prototype.print_string = function(output_string) {\n                    this._output.set_indent(this._indentLevel);\n                    this._output.non_breaking_space = true;\n                    this._output.add_token(output_string);\n                };\n                Beautifier.prototype.preserveSingleSpace = function(isAfterSpace) {\n                    if (isAfterSpace) {\n                        this._output.space_before_token = true;\n                    }\n                };\n                Beautifier.prototype.indent = function() {\n                    this._indentLevel++;\n                };\n                Beautifier.prototype.outdent = function() {\n                    if (this._indentLevel > 0) {\n                        this._indentLevel--;\n                    }\n                };\n                /*_____________________--------------------_____________________*/ Beautifier.prototype.beautify = function() {\n                    if (this._options.disabled) {\n                        return this._source_text;\n                    }\n                    var source_text = this._source_text;\n                    var eol = this._options.eol;\n                    if (eol === \"auto\") {\n                        eol = \"\\n\";\n                        if (source_text && lineBreak.test(source_text || \"\")) {\n                            eol = source_text.match(lineBreak)[0];\n                        }\n                    }\n                    // HACK: newline parsing inconsistent. This brute force normalizes the this._input.\n                    source_text = source_text.replace(allLineBreaks, \"\\n\");\n                    // reset\n                    var baseIndentString = source_text.match(/^[\\t ]*/)[0];\n                    this._output = new Output(this._options, baseIndentString);\n                    this._input = new InputScanner(source_text);\n                    this._indentLevel = 0;\n                    this._nestedLevel = 0;\n                    this._ch = null;\n                    var parenLevel = 0;\n                    var insideRule = false;\n                    // This is the value side of a property value pair (blue in the following ex)\n                    // label { content: blue }\n                    var insidePropertyValue = false;\n                    var enteringConditionalGroup = false;\n                    var insideNonNestedAtRule = false;\n                    var insideScssMap = false;\n                    var topCharacter = this._ch;\n                    var insideNonSemiColonValues = false;\n                    var whitespace;\n                    var isAfterSpace;\n                    var previous_ch;\n                    while(true){\n                        whitespace = this._input.read(whitespacePattern);\n                        isAfterSpace = whitespace !== \"\";\n                        previous_ch = topCharacter;\n                        this._ch = this._input.next();\n                        if (this._ch === \"\\\\\" && this._input.hasNext()) {\n                            this._ch += this._input.next();\n                        }\n                        topCharacter = this._ch;\n                        if (!this._ch) {\n                            break;\n                        } else if (this._ch === \"/\" && this._input.peek() === \"*\") {\n                            // /* css comment */\n                            // Always start block comments on a new line.\n                            // This handles scenarios where a block comment immediately\n                            // follows a property definition on the same line or where\n                            // minified code is being beautified.\n                            this._output.add_new_line();\n                            this._input.back();\n                            var comment = this._input.read(block_comment_pattern);\n                            // Handle ignore directive\n                            var directives = directives_core.get_directives(comment);\n                            if (directives && directives.ignore === \"start\") {\n                                comment += directives_core.readIgnored(this._input);\n                            }\n                            this.print_string(comment);\n                            // Ensures any new lines following the comment are preserved\n                            this.eatWhitespace(true);\n                            // Block comments are followed by a new line so they don't\n                            // share a line with other properties\n                            this._output.add_new_line();\n                        } else if (this._ch === \"/\" && this._input.peek() === \"/\") {\n                            // // single line comment\n                            // Preserves the space before a comment\n                            // on the same line as a rule\n                            this._output.space_before_token = true;\n                            this._input.back();\n                            this.print_string(this._input.read(comment_pattern));\n                            // Ensures any new lines following the comment are preserved\n                            this.eatWhitespace(true);\n                        } else if (this._ch === \"$\") {\n                            this.preserveSingleSpace(isAfterSpace);\n                            this.print_string(this._ch);\n                            // strip trailing space, if present, for hash property checks\n                            var variable = this._input.peekUntilAfter(/[: ,;{}()[\\]\\/='\"]/g);\n                            if (variable.match(/[ :]$/)) {\n                                // we have a variable or pseudo-class, add it and insert one space before continuing\n                                variable = this.eatString(\": \").replace(/\\s+$/, \"\");\n                                this.print_string(variable);\n                                this._output.space_before_token = true;\n                            }\n                            // might be sass variable\n                            if (parenLevel === 0 && variable.indexOf(\":\") !== -1) {\n                                insidePropertyValue = true;\n                                this.indent();\n                            }\n                        } else if (this._ch === \"@\") {\n                            this.preserveSingleSpace(isAfterSpace);\n                            // deal with less property mixins @{...}\n                            if (this._input.peek() === \"{\") {\n                                this.print_string(this._ch + this.eatString(\"}\"));\n                            } else {\n                                this.print_string(this._ch);\n                                // strip trailing space, if present, for hash property checks\n                                var variableOrRule = this._input.peekUntilAfter(/[: ,;{}()[\\]\\/='\"]/g);\n                                if (variableOrRule.match(/[ :]$/)) {\n                                    // we have a variable or pseudo-class, add it and insert one space before continuing\n                                    variableOrRule = this.eatString(\": \").replace(/\\s+$/, \"\");\n                                    this.print_string(variableOrRule);\n                                    this._output.space_before_token = true;\n                                }\n                                // might be less variable\n                                if (parenLevel === 0 && variableOrRule.indexOf(\":\") !== -1) {\n                                    insidePropertyValue = true;\n                                    this.indent();\n                                // might be a nesting at-rule\n                                } else if (variableOrRule in this.NESTED_AT_RULE) {\n                                    this._nestedLevel += 1;\n                                    if (variableOrRule in this.CONDITIONAL_GROUP_RULE) {\n                                        enteringConditionalGroup = true;\n                                    }\n                                // might be a non-nested at-rule\n                                } else if (parenLevel === 0 && !insidePropertyValue) {\n                                    insideNonNestedAtRule = true;\n                                }\n                            }\n                        } else if (this._ch === \"#\" && this._input.peek() === \"{\") {\n                            this.preserveSingleSpace(isAfterSpace);\n                            this.print_string(this._ch + this.eatString(\"}\"));\n                        } else if (this._ch === \"{\") {\n                            if (insidePropertyValue) {\n                                insidePropertyValue = false;\n                                this.outdent();\n                            }\n                            // non nested at rule becomes nested\n                            insideNonNestedAtRule = false;\n                            // when entering conditional groups, only rulesets are allowed\n                            if (enteringConditionalGroup) {\n                                enteringConditionalGroup = false;\n                                insideRule = this._indentLevel >= this._nestedLevel;\n                            } else {\n                                // otherwise, declarations are also allowed\n                                insideRule = this._indentLevel >= this._nestedLevel - 1;\n                            }\n                            if (this._options.newline_between_rules && insideRule) {\n                                if (this._output.previous_line && this._output.previous_line.item(-1) !== \"{\") {\n                                    this._output.ensure_empty_line_above(\"/\", \",\");\n                                }\n                            }\n                            this._output.space_before_token = true;\n                            // The difference in print_string and indent order is necessary to indent the '{' correctly\n                            if (this._options.brace_style === \"expand\") {\n                                this._output.add_new_line();\n                                this.print_string(this._ch);\n                                this.indent();\n                                this._output.set_indent(this._indentLevel);\n                            } else {\n                                // inside mixin and first param is object\n                                if (previous_ch === \"(\") {\n                                    this._output.space_before_token = false;\n                                } else if (previous_ch !== \",\") {\n                                    this.indent();\n                                }\n                                this.print_string(this._ch);\n                            }\n                            this.eatWhitespace(true);\n                            this._output.add_new_line();\n                        } else if (this._ch === \"}\") {\n                            this.outdent();\n                            this._output.add_new_line();\n                            if (previous_ch === \"{\") {\n                                this._output.trim(true);\n                            }\n                            if (insidePropertyValue) {\n                                this.outdent();\n                                insidePropertyValue = false;\n                            }\n                            this.print_string(this._ch);\n                            insideRule = false;\n                            if (this._nestedLevel) {\n                                this._nestedLevel--;\n                            }\n                            this.eatWhitespace(true);\n                            this._output.add_new_line();\n                            if (this._options.newline_between_rules && !this._output.just_added_blankline()) {\n                                if (this._input.peek() !== \"}\") {\n                                    this._output.add_new_line(true);\n                                }\n                            }\n                            if (this._input.peek() === \")\") {\n                                this._output.trim(true);\n                                if (this._options.brace_style === \"expand\") {\n                                    this._output.add_new_line(true);\n                                }\n                            }\n                        } else if (this._ch === \":\") {\n                            for(var i = 0; i < this.NON_SEMICOLON_NEWLINE_PROPERTY.length; i++){\n                                if (this._input.lookBack(this.NON_SEMICOLON_NEWLINE_PROPERTY[i])) {\n                                    insideNonSemiColonValues = true;\n                                    break;\n                                }\n                            }\n                            if ((insideRule || enteringConditionalGroup) && !(this._input.lookBack(\"&\") || this.foundNestedPseudoClass()) && !this._input.lookBack(\"(\") && !insideNonNestedAtRule && parenLevel === 0) {\n                                // 'property: value' delimiter\n                                // which could be in a conditional group query\n                                this.print_string(\":\");\n                                if (!insidePropertyValue) {\n                                    insidePropertyValue = true;\n                                    this._output.space_before_token = true;\n                                    this.eatWhitespace(true);\n                                    this.indent();\n                                }\n                            } else {\n                                // sass/less parent reference don't use a space\n                                // sass nested pseudo-class don't use a space\n                                // preserve space before pseudoclasses/pseudoelements, as it means \"in any child\"\n                                if (this._input.lookBack(\" \")) {\n                                    this._output.space_before_token = true;\n                                }\n                                if (this._input.peek() === \":\") {\n                                    // pseudo-element\n                                    this._ch = this._input.next();\n                                    this.print_string(\"::\");\n                                } else {\n                                    // pseudo-class\n                                    this.print_string(\":\");\n                                }\n                            }\n                        } else if (this._ch === '\"' || this._ch === \"'\") {\n                            var preserveQuoteSpace = previous_ch === '\"' || previous_ch === \"'\";\n                            this.preserveSingleSpace(preserveQuoteSpace || isAfterSpace);\n                            this.print_string(this._ch + this.eatString(this._ch));\n                            this.eatWhitespace(true);\n                        } else if (this._ch === \";\") {\n                            insideNonSemiColonValues = false;\n                            if (parenLevel === 0) {\n                                if (insidePropertyValue) {\n                                    this.outdent();\n                                    insidePropertyValue = false;\n                                }\n                                insideNonNestedAtRule = false;\n                                this.print_string(this._ch);\n                                this.eatWhitespace(true);\n                                // This maintains single line comments on the same\n                                // line. Block comments are also affected, but\n                                // a new line is always output before one inside\n                                // that section\n                                if (this._input.peek() !== \"/\") {\n                                    this._output.add_new_line();\n                                }\n                            } else {\n                                this.print_string(this._ch);\n                                this.eatWhitespace(true);\n                                this._output.space_before_token = true;\n                            }\n                        } else if (this._ch === \"(\") {\n                            if (this._input.lookBack(\"url\")) {\n                                this.print_string(this._ch);\n                                this.eatWhitespace();\n                                parenLevel++;\n                                this.indent();\n                                this._ch = this._input.next();\n                                if (this._ch === \")\" || this._ch === '\"' || this._ch === \"'\") {\n                                    this._input.back();\n                                } else if (this._ch) {\n                                    this.print_string(this._ch + this.eatString(\")\"));\n                                    if (parenLevel) {\n                                        parenLevel--;\n                                        this.outdent();\n                                    }\n                                }\n                            } else {\n                                var space_needed = false;\n                                if (this._input.lookBack(\"with\")) {\n                                    // look back is not an accurate solution, we need tokens to confirm without whitespaces\n                                    space_needed = true;\n                                }\n                                this.preserveSingleSpace(isAfterSpace || space_needed);\n                                this.print_string(this._ch);\n                                // handle scss/sass map\n                                if (insidePropertyValue && previous_ch === \"$\" && this._options.selector_separator_newline) {\n                                    this._output.add_new_line();\n                                    insideScssMap = true;\n                                } else {\n                                    this.eatWhitespace();\n                                    parenLevel++;\n                                    this.indent();\n                                }\n                            }\n                        } else if (this._ch === \")\") {\n                            if (parenLevel) {\n                                parenLevel--;\n                                this.outdent();\n                            }\n                            if (insideScssMap && this._input.peek() === \";\" && this._options.selector_separator_newline) {\n                                insideScssMap = false;\n                                this.outdent();\n                                this._output.add_new_line();\n                            }\n                            this.print_string(this._ch);\n                        } else if (this._ch === \",\") {\n                            this.print_string(this._ch);\n                            this.eatWhitespace(true);\n                            if (this._options.selector_separator_newline && (!insidePropertyValue || insideScssMap) && parenLevel === 0 && !insideNonNestedAtRule) {\n                                this._output.add_new_line();\n                            } else {\n                                this._output.space_before_token = true;\n                            }\n                        } else if ((this._ch === \">\" || this._ch === \"+\" || this._ch === \"~\") && !insidePropertyValue && parenLevel === 0) {\n                            //handle combinator spacing\n                            if (this._options.space_around_combinator) {\n                                this._output.space_before_token = true;\n                                this.print_string(this._ch);\n                                this._output.space_before_token = true;\n                            } else {\n                                this.print_string(this._ch);\n                                this.eatWhitespace();\n                                // squash extra whitespace\n                                if (this._ch && whitespaceChar.test(this._ch)) {\n                                    this._ch = \"\";\n                                }\n                            }\n                        } else if (this._ch === \"]\") {\n                            this.print_string(this._ch);\n                        } else if (this._ch === \"[\") {\n                            this.preserveSingleSpace(isAfterSpace);\n                            this.print_string(this._ch);\n                        } else if (this._ch === \"=\") {\n                            this.eatWhitespace();\n                            this.print_string(\"=\");\n                            if (whitespaceChar.test(this._ch)) {\n                                this._ch = \"\";\n                            }\n                        } else if (this._ch === \"!\" && !this._input.lookBack(\"\\\\\")) {\n                            this._output.space_before_token = true;\n                            this.print_string(this._ch);\n                        } else {\n                            var preserveAfterSpace = previous_ch === '\"' || previous_ch === \"'\";\n                            this.preserveSingleSpace(preserveAfterSpace || isAfterSpace);\n                            this.print_string(this._ch);\n                            if (!this._output.just_added_newline() && this._input.peek() === \"\\n\" && insideNonSemiColonValues) {\n                                this._output.add_new_line();\n                            }\n                        }\n                    }\n                    var sweetCode = this._output.get_code(eol);\n                    return sweetCode;\n                };\n                module.exports.Beautifier = Beautifier;\n            /***/ },\n            /* 17 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_71190__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var BaseOptions = __nested_webpack_require_71190__(6).Options;\n                function Options(options) {\n                    BaseOptions.call(this, options, \"css\");\n                    this.selector_separator_newline = this._get_boolean(\"selector_separator_newline\", true);\n                    this.newline_between_rules = this._get_boolean(\"newline_between_rules\", true);\n                    var space_around_selector_separator = this._get_boolean(\"space_around_selector_separator\");\n                    this.space_around_combinator = this._get_boolean(\"space_around_combinator\") || space_around_selector_separator;\n                    var brace_style_split = this._get_selection_list(\"brace_style\", [\n                        \"collapse\",\n                        \"expand\",\n                        \"end-expand\",\n                        \"none\",\n                        \"preserve-inline\"\n                    ]);\n                    this.brace_style = \"collapse\";\n                    for(var bs = 0; bs < brace_style_split.length; bs++){\n                        if (brace_style_split[bs] !== \"expand\") {\n                            // default to collapse, as only collapse|expand is implemented for now\n                            this.brace_style = \"collapse\";\n                        } else {\n                            this.brace_style = brace_style_split[bs];\n                        }\n                    }\n                }\n                Options.prototype = new BaseOptions();\n                module.exports.Options = Options;\n            /***/ }\n        ];\n        /************************************************************************/ /******/ // The module cache\n        /******/ var __webpack_module_cache__ = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_74198__(moduleId) {\n            /******/ // Check if module is in cache\n            /******/ var cachedModule = __webpack_module_cache__[moduleId];\n            /******/ if (cachedModule !== undefined) {\n                /******/ return cachedModule.exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module = __webpack_module_cache__[moduleId] = {\n                /******/ // no module.id needed\n                /******/ // no module.loaded needed\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ __webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_74198__);\n            /******/ /******/ // Return the exports of the module\n            /******/ return module.exports;\n        /******/ }\n        /******/ /************************************************************************/ /******/ /******/ // startup\n        /******/ // Load entry module and return exports\n        /******/ // This entry module is referenced by other modules so it can't be inlined\n        /******/ var __nested_webpack_exports__ = __nested_webpack_require_74198__(15);\n        /******/ legacy_beautify_css = __nested_webpack_exports__;\n    /******/ /******/ })();\n    var css_beautify = legacy_beautify_css;\n    /* Footer */ if (true) {\n        // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return {\n                css_beautify: css_beautify\n            };\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qcy1iZWF1dGlmeS9qcy9saWIvYmVhdXRpZnktY3NzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGtHQUFrQyxHQUNsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBEQSxHQUVBLHVEQUF1RDtBQUN2RCxvQ0FBb0M7QUFFbkM7SUFFRCwwQkFBMEIsR0FDMUIsSUFBSUE7SUFDSixNQUFNLEdBQUk7UUFDVixNQUFNLEdBQUk7UUFDVixNQUFNLEdBQUksSUFBSUMsc0JBQXVCOzs7WUFHckMsS0FBSyxHQUNMLEdBQUcsR0FBSSxTQUFTQyxNQUFNO2dCQUV0QixtQkFBbUIsR0FDbkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQSxHQUlBLFNBQVNDLFdBQVdDLE1BQU07b0JBQ3hCLElBQUksQ0FBQ0MsUUFBUSxHQUFHRDtvQkFDaEIsSUFBSSxDQUFDRSxpQkFBaUIsR0FBRztvQkFDekIsZ0ZBQWdGO29CQUNoRixJQUFJLENBQUNDLGNBQWMsR0FBRyxDQUFDO29CQUN2QixJQUFJLENBQUNDLGlCQUFpQixHQUFHO29CQUN6QixJQUFJLENBQUNDLGtCQUFrQixHQUFHO29CQUMxQixJQUFJLENBQUNDLDRCQUE0QixHQUFHO29CQUNwQyxJQUFJLENBQUNDLHlCQUF5QixHQUFHLENBQUM7b0JBQ2xDLElBQUksQ0FBQ0MsNEJBQTRCLEdBQUc7b0JBRXBDLElBQUksQ0FBQ0MsT0FBTyxHQUFHLEVBQUU7Z0JBQ25CO2dCQUVBVixXQUFXVyxTQUFTLENBQUNDLFdBQVcsR0FBRztvQkFDakMsSUFBSUMsT0FBTyxJQUFJYixXQUFXLElBQUksQ0FBQ0UsUUFBUTtvQkFDdkNXLEtBQUtDLFVBQVUsQ0FBQyxJQUFJLENBQUNWLGNBQWMsRUFBRSxJQUFJLENBQUNDLGlCQUFpQjtvQkFDM0QsT0FBT1E7Z0JBQ1Q7Z0JBRUFiLFdBQVdXLFNBQVMsQ0FBQ0ksSUFBSSxHQUFH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QUNoQyxNQUFNLEdBQUk7UUFDVixNQUFNLEdBQ04sd0VBQXdFLEdBQ3hFLE1BQU0sR0FDTixNQUFNLEdBQUksVUFBVTtRQUNwQixNQUFNLEdBQUksdUNBQXVDO1FBQ2pELE1BQU0sR0FBSSwwRUFBMEU7UUFDcEYsTUFBTSxHQUFJLElBQUkySiwwQkFBbUJBLEdBQUdwRSxnQ0FBbUJBLENBQUM7UUFDeEQsTUFBTSxHQUFJcE0sc0JBQXNCd1EsMEJBQW1CQTtJQUNuRCxNQUFNLEdBQ04sTUFBTSxHQUFHO0lBRVQsSUFBSWxFLGVBQWV0TTtJQUNuQixVQUFVLEdBQ1YsSUFBSSxJQUEwQyxFQUFFO1FBQzVDLDBGQUEwRjtRQUMxRnlRLGlDQUFPLEVBQUUsbUNBQUU7WUFDUCxPQUFPO2dCQUNIbkUsY0FBY0E7WUFDbEI7UUFDSixDQUFDO0FBQUEsa0dBQUM7SUFDTixPQUFPLEVBVU47QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL29wZW4tcHJvLW5leHQvLi9ub2RlX21vZHVsZXMvanMtYmVhdXRpZnkvanMvbGliL2JlYXV0aWZ5LWNzcy5qcz9jNDNmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIEFVVE8tR0VORVJBVEVELiBETyBOT1QgTU9ESUZZLiAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG5cblxuIENTUyBCZWF1dGlmaWVyXG4tLS0tLS0tLS0tLS0tLS1cblxuICAgIFdyaXR0ZW4gYnkgSGFydXR5dW4gQW1pcmphbnlhbiwgKGFtaXJqYW55YW5AZ21haWwuY29tKVxuXG4gICAgQmFzZWQgb24gY29kZSBpbml0aWFsbHkgZGV2ZWxvcGVkIGJ5OiBFaW5hciBMaWVsbWFuaXMsIDxlaW5hckBiZWF1dGlmaWVyLmlvPlxuICAgICAgICBodHRwczovL2JlYXV0aWZpZXIuaW8vXG5cbiAgICBVc2FnZTpcbiAgICAgICAgY3NzX2JlYXV0aWZ5KHNvdXJjZV90ZXh0KTtcbiAgICAgICAgY3NzX2JlYXV0aWZ5KHNvdXJjZV90ZXh0LCBvcHRpb25zKTtcblxuICAgIFRoZSBvcHRpb25zIGFyZSAoZGVmYXVsdCBpbiBicmFja2V0cyk6XG4gICAgICAgIGluZGVudF9zaXplICg0KSAgICAgICAgICAgICAgICAgICAgICAgICDigJQgaW5kZW50YXRpb24gc2l6ZSxcbiAgICAgICAgaW5kZW50X2NoYXIgKHNwYWNlKSAgICAgICAgICAgICAgICAgICAgIOKAlCBjaGFyYWN0ZXIgdG8gaW5kZW50IHdpdGgsXG4gICAgICAgIHNlbGVjdG9yX3NlcGFyYXRvcl9uZXdsaW5lICh0cnVlKSAgICAgICAtIHNlcGFyYXRlIHNlbGVjdG9ycyB3aXRoIG5ld2xpbmUgb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90IChlLmcuIFwiYSxcXG5iclwiIG9yIFwiYSwgYnJcIilcbiAgICAgICAgZW5kX3dpdGhfbmV3bGluZSAoZmFsc2UpICAgICAgICAgICAgICAgIC0gZW5kIHdpdGggYSBuZXdsaW5lXG4gICAgICAgIG5ld2xpbmVfYmV0d2Vlbl9ydWxlcyAodHJ1ZSkgICAgICAgICAgICAtIGFkZCBhIG5ldyBsaW5lIGFmdGVyIGV2ZXJ5IGNzcyBydWxlXG4gICAgICAgIHNwYWNlX2Fyb3VuZF9zZWxlY3Rvcl9zZXBhcmF0b3IgKGZhbHNlKSAtIGVuc3VyZSBzcGFjZSBhcm91bmQgc2VsZWN0b3Igc2VwYXJhdG9yczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJz4nLCAnKycsICd+JyAoZS5nLiBcImE+YlwiIC0+IFwiYSA+IGJcIilcbiAgICBlLmdcblxuICAgIGNzc19iZWF1dGlmeShjc3Nfc291cmNlX3RleHQsIHtcbiAgICAgICdpbmRlbnRfc2l6ZSc6IDEsXG4gICAgICAnaW5kZW50X2NoYXInOiAnXFx0JyxcbiAgICAgICdzZWxlY3Rvcl9zZXBhcmF0b3InOiAnICcsXG4gICAgICAnZW5kX3dpdGhfbmV3bGluZSc6IGZhbHNlLFxuICAgICAgJ25ld2xpbmVfYmV0d2Vlbl9ydWxlcyc6IHRydWUsXG4gICAgICAnc3BhY2VfYXJvdW5kX3NlbGVjdG9yX3NlcGFyYXRvcic6IHRydWVcbiAgICB9KTtcbiovXG5cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN0b2tlbml6YXRpb25cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc3ludGF4L1xuXG4oZnVuY3Rpb24oKSB7XG5cbi8qIEdFTkVSQVRFRF9CVUlMRF9PVVRQVVQgKi9cbnZhciBsZWdhY3lfYmVhdXRpZnlfY3NzO1xuLyoqKioqKi8gKGZ1bmN0aW9uKCkgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdFwidXNlIHN0cmljdFwiO1xuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9IChbXG4vKiAwICovLFxuLyogMSAqLyxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxuZnVuY3Rpb24gT3V0cHV0TGluZShwYXJlbnQpIHtcbiAgdGhpcy5fX3BhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCA9IDA7XG4gIC8vIHVzZSBpbmRlbnRfY291bnQgYXMgYSBtYXJrZXIgZm9yIHRoaXMuX19saW5lcyB0aGF0IGhhdmUgcHJlc2VydmVkIGluZGVudGF0aW9uXG4gIHRoaXMuX19pbmRlbnRfY291bnQgPSAtMTtcbiAgdGhpcy5fX2FsaWdubWVudF9jb3VudCA9IDA7XG4gIHRoaXMuX193cmFwX3BvaW50X2luZGV4ID0gMDtcbiAgdGhpcy5fX3dyYXBfcG9pbnRfY2hhcmFjdGVyX2NvdW50ID0gMDtcbiAgdGhpcy5fX3dyYXBfcG9pbnRfaW5kZW50X2NvdW50ID0gLTE7XG4gIHRoaXMuX193cmFwX3BvaW50X2FsaWdubWVudF9jb3VudCA9IDA7XG5cbiAgdGhpcy5fX2l0ZW1zID0gW107XG59XG5cbk91dHB1dExpbmUucHJvdG90eXBlLmNsb25lX2VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsaW5lID0gbmV3IE91dHB1dExpbmUodGhpcy5fX3BhcmVudCk7XG4gIGxpbmUuc2V0X2luZGVudCh0aGlzLl9faW5kZW50X2NvdW50LCB0aGlzLl9fYWxpZ25tZW50X2NvdW50KTtcbiAgcmV0dXJuIGxpbmU7XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5pdGVtID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiB0aGlzLl9faXRlbXNbdGhpcy5fX2l0ZW1zLmxlbmd0aCArIGluZGV4XTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5fX2l0ZW1zW2luZGV4XTtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuaGFzX21hdGNoID0gZnVuY3Rpb24ocGF0dGVybikge1xuICBmb3IgKHZhciBsYXN0Q2hlY2tlZE91dHB1dCA9IHRoaXMuX19pdGVtcy5sZW5ndGggLSAxOyBsYXN0Q2hlY2tlZE91dHB1dCA+PSAwOyBsYXN0Q2hlY2tlZE91dHB1dC0tKSB7XG4gICAgaWYgKHRoaXMuX19pdGVtc1tsYXN0Q2hlY2tlZE91dHB1dF0ubWF0Y2gocGF0dGVybikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5zZXRfaW5kZW50ID0gZnVuY3Rpb24oaW5kZW50LCBhbGlnbm1lbnQpIHtcbiAgaWYgKHRoaXMuaXNfZW1wdHkoKSkge1xuICAgIHRoaXMuX19pbmRlbnRfY291bnQgPSBpbmRlbnQgfHwgMDtcbiAgICB0aGlzLl9fYWxpZ25tZW50X2NvdW50ID0gYWxpZ25tZW50IHx8IDA7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCA9IHRoaXMuX19wYXJlbnQuZ2V0X2luZGVudF9zaXplKHRoaXMuX19pbmRlbnRfY291bnQsIHRoaXMuX19hbGlnbm1lbnRfY291bnQpO1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5fc2V0X3dyYXBfcG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX19wYXJlbnQud3JhcF9saW5lX2xlbmd0aCkge1xuICAgIHRoaXMuX193cmFwX3BvaW50X2luZGV4ID0gdGhpcy5fX2l0ZW1zLmxlbmd0aDtcbiAgICB0aGlzLl9fd3JhcF9wb2ludF9jaGFyYWN0ZXJfY291bnQgPSB0aGlzLl9fY2hhcmFjdGVyX2NvdW50O1xuICAgIHRoaXMuX193cmFwX3BvaW50X2luZGVudF9jb3VudCA9IHRoaXMuX19wYXJlbnQubmV4dF9saW5lLl9faW5kZW50X2NvdW50O1xuICAgIHRoaXMuX193cmFwX3BvaW50X2FsaWdubWVudF9jb3VudCA9IHRoaXMuX19wYXJlbnQubmV4dF9saW5lLl9fYWxpZ25tZW50X2NvdW50O1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5fc2hvdWxkX3dyYXAgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX193cmFwX3BvaW50X2luZGV4ICYmXG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCA+IHRoaXMuX19wYXJlbnQud3JhcF9saW5lX2xlbmd0aCAmJlxuICAgIHRoaXMuX193cmFwX3BvaW50X2NoYXJhY3Rlcl9jb3VudCA+IHRoaXMuX19wYXJlbnQubmV4dF9saW5lLl9fY2hhcmFjdGVyX2NvdW50O1xufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuX2FsbG93X3dyYXAgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX3Nob3VsZF93cmFwKCkpIHtcbiAgICB0aGlzLl9fcGFyZW50LmFkZF9uZXdfbGluZSgpO1xuICAgIHZhciBuZXh0ID0gdGhpcy5fX3BhcmVudC5jdXJyZW50X2xpbmU7XG4gICAgbmV4dC5zZXRfaW5kZW50KHRoaXMuX193cmFwX3BvaW50X2luZGVudF9jb3VudCwgdGhpcy5fX3dyYXBfcG9pbnRfYWxpZ25tZW50X2NvdW50KTtcbiAgICBuZXh0Ll9faXRlbXMgPSB0aGlzLl9faXRlbXMuc2xpY2UodGhpcy5fX3dyYXBfcG9pbnRfaW5kZXgpO1xuICAgIHRoaXMuX19pdGVtcyA9IHRoaXMuX19pdGVtcy5zbGljZSgwLCB0aGlzLl9fd3JhcF9wb2ludF9pbmRleCk7XG5cbiAgICBuZXh0Ll9fY2hhcmFjdGVyX2NvdW50ICs9IHRoaXMuX19jaGFyYWN0ZXJfY291bnQgLSB0aGlzLl9fd3JhcF9wb2ludF9jaGFyYWN0ZXJfY291bnQ7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCA9IHRoaXMuX193cmFwX3BvaW50X2NoYXJhY3Rlcl9jb3VudDtcblxuICAgIGlmIChuZXh0Ll9faXRlbXNbMF0gPT09IFwiIFwiKSB7XG4gICAgICBuZXh0Ll9faXRlbXMuc3BsaWNlKDAsIDEpO1xuICAgICAgbmV4dC5fX2NoYXJhY3Rlcl9jb3VudCAtPSAxO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5pc19lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX2l0ZW1zLmxlbmd0aCA9PT0gMDtcbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmlzX2VtcHR5KCkpIHtcbiAgICByZXR1cm4gdGhpcy5fX2l0ZW1zW3RoaXMuX19pdGVtcy5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgdGhpcy5fX2l0ZW1zLnB1c2goaXRlbSk7XG4gIHZhciBsYXN0X25ld2xpbmVfaW5kZXggPSBpdGVtLmxhc3RJbmRleE9mKCdcXG4nKTtcbiAgaWYgKGxhc3RfbmV3bGluZV9pbmRleCAhPT0gLTEpIHtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50ID0gaXRlbS5sZW5ndGggLSBsYXN0X25ld2xpbmVfaW5kZXg7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCArPSBpdGVtLmxlbmd0aDtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtID0gbnVsbDtcbiAgaWYgKCF0aGlzLmlzX2VtcHR5KCkpIHtcbiAgICBpdGVtID0gdGhpcy5fX2l0ZW1zLnBvcCgpO1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgLT0gaXRlbS5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59O1xuXG5cbk91dHB1dExpbmUucHJvdG90eXBlLl9yZW1vdmVfaW5kZW50ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9faW5kZW50X2NvdW50ID4gMCkge1xuICAgIHRoaXMuX19pbmRlbnRfY291bnQgLT0gMTtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50IC09IHRoaXMuX19wYXJlbnQuaW5kZW50X3NpemU7XG4gIH1cbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLl9yZW1vdmVfd3JhcF9pbmRlbnQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX193cmFwX3BvaW50X2luZGVudF9jb3VudCA+IDApIHtcbiAgICB0aGlzLl9fd3JhcF9wb2ludF9pbmRlbnRfY291bnQgLT0gMTtcbiAgfVxufTtcbk91dHB1dExpbmUucHJvdG90eXBlLnRyaW0gPSBmdW5jdGlvbigpIHtcbiAgd2hpbGUgKHRoaXMubGFzdCgpID09PSAnICcpIHtcbiAgICB0aGlzLl9faXRlbXMucG9wKCk7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCAtPSAxO1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGlzLmlzX2VtcHR5KCkpIHtcbiAgICBpZiAodGhpcy5fX3BhcmVudC5pbmRlbnRfZW1wdHlfbGluZXMpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuX19wYXJlbnQuZ2V0X2luZGVudF9zdHJpbmcodGhpcy5fX2luZGVudF9jb3VudCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IHRoaXMuX19wYXJlbnQuZ2V0X2luZGVudF9zdHJpbmcodGhpcy5fX2luZGVudF9jb3VudCwgdGhpcy5fX2FsaWdubWVudF9jb3VudCk7XG4gICAgcmVzdWx0ICs9IHRoaXMuX19pdGVtcy5qb2luKCcnKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gSW5kZW50U3RyaW5nQ2FjaGUob3B0aW9ucywgYmFzZUluZGVudFN0cmluZykge1xuICB0aGlzLl9fY2FjaGUgPSBbJyddO1xuICB0aGlzLl9faW5kZW50X3NpemUgPSBvcHRpb25zLmluZGVudF9zaXplO1xuICB0aGlzLl9faW5kZW50X3N0cmluZyA9IG9wdGlvbnMuaW5kZW50X2NoYXI7XG4gIGlmICghb3B0aW9ucy5pbmRlbnRfd2l0aF90YWJzKSB7XG4gICAgdGhpcy5fX2luZGVudF9zdHJpbmcgPSBuZXcgQXJyYXkob3B0aW9ucy5pbmRlbnRfc2l6ZSArIDEpLmpvaW4ob3B0aW9ucy5pbmRlbnRfY2hhcik7XG4gIH1cblxuICAvLyBTZXQgdG8gbnVsbCB0byBjb250aW51ZSBzdXBwb3J0IGZvciBhdXRvIGRldGVjdGlvbiBvZiBiYXNlIGluZGVudFxuICBiYXNlSW5kZW50U3RyaW5nID0gYmFzZUluZGVudFN0cmluZyB8fCAnJztcbiAgaWYgKG9wdGlvbnMuaW5kZW50X2xldmVsID4gMCkge1xuICAgIGJhc2VJbmRlbnRTdHJpbmcgPSBuZXcgQXJyYXkob3B0aW9ucy5pbmRlbnRfbGV2ZWwgKyAxKS5qb2luKHRoaXMuX19pbmRlbnRfc3RyaW5nKTtcbiAgfVxuXG4gIHRoaXMuX19iYXNlX3N0cmluZyA9IGJhc2VJbmRlbnRTdHJpbmc7XG4gIHRoaXMuX19iYXNlX3N0cmluZ19sZW5ndGggPSBiYXNlSW5kZW50U3RyaW5nLmxlbmd0aDtcbn1cblxuSW5kZW50U3RyaW5nQ2FjaGUucHJvdG90eXBlLmdldF9pbmRlbnRfc2l6ZSA9IGZ1bmN0aW9uKGluZGVudCwgY29sdW1uKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9fYmFzZV9zdHJpbmdfbGVuZ3RoO1xuICBjb2x1bW4gPSBjb2x1bW4gfHwgMDtcbiAgaWYgKGluZGVudCA8IDApIHtcbiAgICByZXN1bHQgPSAwO1xuICB9XG4gIHJlc3VsdCArPSBpbmRlbnQgKiB0aGlzLl9faW5kZW50X3NpemU7XG4gIHJlc3VsdCArPSBjb2x1bW47XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5JbmRlbnRTdHJpbmdDYWNoZS5wcm90b3R5cGUuZ2V0X2luZGVudF9zdHJpbmcgPSBmdW5jdGlvbihpbmRlbnRfbGV2ZWwsIGNvbHVtbikge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fX2Jhc2Vfc3RyaW5nO1xuICBjb2x1bW4gPSBjb2x1bW4gfHwgMDtcbiAgaWYgKGluZGVudF9sZXZlbCA8IDApIHtcbiAgICBpbmRlbnRfbGV2ZWwgPSAwO1xuICAgIHJlc3VsdCA9ICcnO1xuICB9XG4gIGNvbHVtbiArPSBpbmRlbnRfbGV2ZWwgKiB0aGlzLl9faW5kZW50X3NpemU7XG4gIHRoaXMuX19lbnN1cmVfY2FjaGUoY29sdW1uKTtcbiAgcmVzdWx0ICs9IHRoaXMuX19jYWNoZVtjb2x1bW5dO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuSW5kZW50U3RyaW5nQ2FjaGUucHJvdG90eXBlLl9fZW5zdXJlX2NhY2hlID0gZnVuY3Rpb24oY29sdW1uKSB7XG4gIHdoaWxlIChjb2x1bW4gPj0gdGhpcy5fX2NhY2hlLmxlbmd0aCkge1xuICAgIHRoaXMuX19hZGRfY29sdW1uKCk7XG4gIH1cbn07XG5cbkluZGVudFN0cmluZ0NhY2hlLnByb3RvdHlwZS5fX2FkZF9jb2x1bW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvbHVtbiA9IHRoaXMuX19jYWNoZS5sZW5ndGg7XG4gIHZhciBpbmRlbnQgPSAwO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGlzLl9faW5kZW50X3NpemUgJiYgY29sdW1uID49IHRoaXMuX19pbmRlbnRfc2l6ZSkge1xuICAgIGluZGVudCA9IE1hdGguZmxvb3IoY29sdW1uIC8gdGhpcy5fX2luZGVudF9zaXplKTtcbiAgICBjb2x1bW4gLT0gaW5kZW50ICogdGhpcy5fX2luZGVudF9zaXplO1xuICAgIHJlc3VsdCA9IG5ldyBBcnJheShpbmRlbnQgKyAxKS5qb2luKHRoaXMuX19pbmRlbnRfc3RyaW5nKTtcbiAgfVxuICBpZiAoY29sdW1uKSB7XG4gICAgcmVzdWx0ICs9IG5ldyBBcnJheShjb2x1bW4gKyAxKS5qb2luKCcgJyk7XG4gIH1cblxuICB0aGlzLl9fY2FjaGUucHVzaChyZXN1bHQpO1xufTtcblxuZnVuY3Rpb24gT3V0cHV0KG9wdGlvbnMsIGJhc2VJbmRlbnRTdHJpbmcpIHtcbiAgdGhpcy5fX2luZGVudF9jYWNoZSA9IG5ldyBJbmRlbnRTdHJpbmdDYWNoZShvcHRpb25zLCBiYXNlSW5kZW50U3RyaW5nKTtcbiAgdGhpcy5yYXcgPSBmYWxzZTtcbiAgdGhpcy5fZW5kX3dpdGhfbmV3bGluZSA9IG9wdGlvbnMuZW5kX3dpdGhfbmV3bGluZTtcbiAgdGhpcy5pbmRlbnRfc2l6ZSA9IG9wdGlvbnMuaW5kZW50X3NpemU7XG4gIHRoaXMud3JhcF9saW5lX2xlbmd0aCA9IG9wdGlvbnMud3JhcF9saW5lX2xlbmd0aDtcbiAgdGhpcy5pbmRlbnRfZW1wdHlfbGluZXMgPSBvcHRpb25zLmluZGVudF9lbXB0eV9saW5lcztcbiAgdGhpcy5fX2xpbmVzID0gW107XG4gIHRoaXMucHJldmlvdXNfbGluZSA9IG51bGw7XG4gIHRoaXMuY3VycmVudF9saW5lID0gbnVsbDtcbiAgdGhpcy5uZXh0X2xpbmUgPSBuZXcgT3V0cHV0TGluZSh0aGlzKTtcbiAgdGhpcy5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgdGhpcy5ub25fYnJlYWtpbmdfc3BhY2UgPSBmYWxzZTtcbiAgdGhpcy5wcmV2aW91c190b2tlbl93cmFwcGVkID0gZmFsc2U7XG4gIC8vIGluaXRpYWxpemVcbiAgdGhpcy5fX2FkZF9vdXRwdXRsaW5lKCk7XG59XG5cbk91dHB1dC5wcm90b3R5cGUuX19hZGRfb3V0cHV0bGluZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnByZXZpb3VzX2xpbmUgPSB0aGlzLmN1cnJlbnRfbGluZTtcbiAgdGhpcy5jdXJyZW50X2xpbmUgPSB0aGlzLm5leHRfbGluZS5jbG9uZV9lbXB0eSgpO1xuICB0aGlzLl9fbGluZXMucHVzaCh0aGlzLmN1cnJlbnRfbGluZSk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmdldF9saW5lX251bWJlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX2xpbmVzLmxlbmd0aDtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuZ2V0X2luZGVudF9zdHJpbmcgPSBmdW5jdGlvbihpbmRlbnQsIGNvbHVtbikge1xuICByZXR1cm4gdGhpcy5fX2luZGVudF9jYWNoZS5nZXRfaW5kZW50X3N0cmluZyhpbmRlbnQsIGNvbHVtbik7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmdldF9pbmRlbnRfc2l6ZSA9IGZ1bmN0aW9uKGluZGVudCwgY29sdW1uKSB7XG4gIHJldHVybiB0aGlzLl9faW5kZW50X2NhY2hlLmdldF9pbmRlbnRfc2l6ZShpbmRlbnQsIGNvbHVtbik7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmlzX2VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhdGhpcy5wcmV2aW91c19saW5lICYmIHRoaXMuY3VycmVudF9saW5lLmlzX2VtcHR5KCk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmFkZF9uZXdfbGluZSA9IGZ1bmN0aW9uKGZvcmNlX25ld2xpbmUpIHtcbiAgLy8gbmV2ZXIgbmV3bGluZSBhdCB0aGUgc3RhcnQgb2YgZmlsZVxuICAvLyBvdGhlcndpc2UsIG5ld2xpbmUgb25seSBpZiB3ZSBkaWRuJ3QganVzdCBhZGQgb25lIG9yIHdlJ3JlIGZvcmNlZFxuICBpZiAodGhpcy5pc19lbXB0eSgpIHx8XG4gICAgKCFmb3JjZV9uZXdsaW5lICYmIHRoaXMuanVzdF9hZGRlZF9uZXdsaW5lKCkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gaWYgcmF3IG91dHB1dCBpcyBlbmFibGVkLCBkb24ndCBwcmludCBhZGRpdGlvbmFsIG5ld2xpbmVzLFxuICAvLyBidXQgc3RpbGwgcmV0dXJuIFRydWUgYXMgdGhvdWdoIHlvdSBoYWRcbiAgaWYgKCF0aGlzLnJhdykge1xuICAgIHRoaXMuX19hZGRfb3V0cHV0bGluZSgpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5nZXRfY29kZSA9IGZ1bmN0aW9uKGVvbCkge1xuICB0aGlzLnRyaW0odHJ1ZSk7XG5cbiAgLy8gaGFuZGxlIHNvbWUgZWRnZSBjYXNlcyB3aGVyZSB0aGUgbGFzdCB0b2tlbnNcbiAgLy8gaGFzIHRleHQgdGhhdCBlbmRzIHdpdGggbmV3bGluZShzKVxuICB2YXIgbGFzdF9pdGVtID0gdGhpcy5jdXJyZW50X2xpbmUucG9wKCk7XG4gIGlmIChsYXN0X2l0ZW0pIHtcbiAgICBpZiAobGFzdF9pdGVtW2xhc3RfaXRlbS5sZW5ndGggLSAxXSA9PT0gJ1xcbicpIHtcbiAgICAgIGxhc3RfaXRlbSA9IGxhc3RfaXRlbS5yZXBsYWNlKC9cXG4rJC9nLCAnJyk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudF9saW5lLnB1c2gobGFzdF9pdGVtKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9lbmRfd2l0aF9uZXdsaW5lKSB7XG4gICAgdGhpcy5fX2FkZF9vdXRwdXRsaW5lKCk7XG4gIH1cblxuICB2YXIgc3dlZXRfY29kZSA9IHRoaXMuX19saW5lcy5qb2luKCdcXG4nKTtcblxuICBpZiAoZW9sICE9PSAnXFxuJykge1xuICAgIHN3ZWV0X2NvZGUgPSBzd2VldF9jb2RlLnJlcGxhY2UoL1tcXG5dL2csIGVvbCk7XG4gIH1cbiAgcmV0dXJuIHN3ZWV0X2NvZGU7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLnNldF93cmFwX3BvaW50ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY3VycmVudF9saW5lLl9zZXRfd3JhcF9wb2ludCgpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5zZXRfaW5kZW50ID0gZnVuY3Rpb24oaW5kZW50LCBhbGlnbm1lbnQpIHtcbiAgaW5kZW50ID0gaW5kZW50IHx8IDA7XG4gIGFsaWdubWVudCA9IGFsaWdubWVudCB8fCAwO1xuXG4gIC8vIE5leHQgbGluZSBzdG9yZXMgYWxpZ25tZW50IHZhbHVlc1xuICB0aGlzLm5leHRfbGluZS5zZXRfaW5kZW50KGluZGVudCwgYWxpZ25tZW50KTtcblxuICAvLyBOZXZlciBpbmRlbnQgeW91ciBmaXJzdCBvdXRwdXQgaW5kZW50IGF0IHRoZSBzdGFydCBvZiB0aGUgZmlsZVxuICBpZiAodGhpcy5fX2xpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICB0aGlzLmN1cnJlbnRfbGluZS5zZXRfaW5kZW50KGluZGVudCwgYWxpZ25tZW50KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuY3VycmVudF9saW5lLnNldF9pbmRlbnQoKTtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5hZGRfcmF3X3Rva2VuID0gZnVuY3Rpb24odG9rZW4pIHtcbiAgZm9yICh2YXIgeCA9IDA7IHggPCB0b2tlbi5uZXdsaW5lczsgeCsrKSB7XG4gICAgdGhpcy5fX2FkZF9vdXRwdXRsaW5lKCk7XG4gIH1cbiAgdGhpcy5jdXJyZW50X2xpbmUuc2V0X2luZGVudCgtMSk7XG4gIHRoaXMuY3VycmVudF9saW5lLnB1c2godG9rZW4ud2hpdGVzcGFjZV9iZWZvcmUpO1xuICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKHRva2VuLnRleHQpO1xuICB0aGlzLnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICB0aGlzLm5vbl9icmVha2luZ19zcGFjZSA9IGZhbHNlO1xuICB0aGlzLnByZXZpb3VzX3Rva2VuX3dyYXBwZWQgPSBmYWxzZTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuYWRkX3Rva2VuID0gZnVuY3Rpb24ocHJpbnRhYmxlX3Rva2VuKSB7XG4gIHRoaXMuX19hZGRfc3BhY2VfYmVmb3JlX3Rva2VuKCk7XG4gIHRoaXMuY3VycmVudF9saW5lLnB1c2gocHJpbnRhYmxlX3Rva2VuKTtcbiAgdGhpcy5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgdGhpcy5ub25fYnJlYWtpbmdfc3BhY2UgPSBmYWxzZTtcbiAgdGhpcy5wcmV2aW91c190b2tlbl93cmFwcGVkID0gdGhpcy5jdXJyZW50X2xpbmUuX2FsbG93X3dyYXAoKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuX19hZGRfc3BhY2VfYmVmb3JlX3Rva2VuID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnNwYWNlX2JlZm9yZV90b2tlbiAmJiAhdGhpcy5qdXN0X2FkZGVkX25ld2xpbmUoKSkge1xuICAgIGlmICghdGhpcy5ub25fYnJlYWtpbmdfc3BhY2UpIHtcbiAgICAgIHRoaXMuc2V0X3dyYXBfcG9pbnQoKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50X2xpbmUucHVzaCgnICcpO1xuICB9XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLnJlbW92ZV9pbmRlbnQgPSBmdW5jdGlvbihpbmRleCkge1xuICB2YXIgb3V0cHV0X2xlbmd0aCA9IHRoaXMuX19saW5lcy5sZW5ndGg7XG4gIHdoaWxlIChpbmRleCA8IG91dHB1dF9sZW5ndGgpIHtcbiAgICB0aGlzLl9fbGluZXNbaW5kZXhdLl9yZW1vdmVfaW5kZW50KCk7XG4gICAgaW5kZXgrKztcbiAgfVxuICB0aGlzLmN1cnJlbnRfbGluZS5fcmVtb3ZlX3dyYXBfaW5kZW50KCk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLnRyaW0gPSBmdW5jdGlvbihlYXRfbmV3bGluZXMpIHtcbiAgZWF0X25ld2xpbmVzID0gKGVhdF9uZXdsaW5lcyA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogZWF0X25ld2xpbmVzO1xuXG4gIHRoaXMuY3VycmVudF9saW5lLnRyaW0oKTtcblxuICB3aGlsZSAoZWF0X25ld2xpbmVzICYmIHRoaXMuX19saW5lcy5sZW5ndGggPiAxICYmXG4gICAgdGhpcy5jdXJyZW50X2xpbmUuaXNfZW1wdHkoKSkge1xuICAgIHRoaXMuX19saW5lcy5wb3AoKTtcbiAgICB0aGlzLmN1cnJlbnRfbGluZSA9IHRoaXMuX19saW5lc1t0aGlzLl9fbGluZXMubGVuZ3RoIC0gMV07XG4gICAgdGhpcy5jdXJyZW50X2xpbmUudHJpbSgpO1xuICB9XG5cbiAgdGhpcy5wcmV2aW91c19saW5lID0gdGhpcy5fX2xpbmVzLmxlbmd0aCA+IDEgP1xuICAgIHRoaXMuX19saW5lc1t0aGlzLl9fbGluZXMubGVuZ3RoIC0gMl0gOiBudWxsO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5qdXN0X2FkZGVkX25ld2xpbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY3VycmVudF9saW5lLmlzX2VtcHR5KCk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmp1c3RfYWRkZWRfYmxhbmtsaW5lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmlzX2VtcHR5KCkgfHxcbiAgICAodGhpcy5jdXJyZW50X2xpbmUuaXNfZW1wdHkoKSAmJiB0aGlzLnByZXZpb3VzX2xpbmUuaXNfZW1wdHkoKSk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmVuc3VyZV9lbXB0eV9saW5lX2Fib3ZlID0gZnVuY3Rpb24oc3RhcnRzX3dpdGgsIGVuZHNfd2l0aCkge1xuICB2YXIgaW5kZXggPSB0aGlzLl9fbGluZXMubGVuZ3RoIC0gMjtcbiAgd2hpbGUgKGluZGV4ID49IDApIHtcbiAgICB2YXIgcG90ZW50aWFsRW1wdHlMaW5lID0gdGhpcy5fX2xpbmVzW2luZGV4XTtcbiAgICBpZiAocG90ZW50aWFsRW1wdHlMaW5lLmlzX2VtcHR5KCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAocG90ZW50aWFsRW1wdHlMaW5lLml0ZW0oMCkuaW5kZXhPZihzdGFydHNfd2l0aCkgIT09IDAgJiZcbiAgICAgIHBvdGVudGlhbEVtcHR5TGluZS5pdGVtKC0xKSAhPT0gZW5kc193aXRoKSB7XG4gICAgICB0aGlzLl9fbGluZXMuc3BsaWNlKGluZGV4ICsgMSwgMCwgbmV3IE91dHB1dExpbmUodGhpcykpO1xuICAgICAgdGhpcy5wcmV2aW91c19saW5lID0gdGhpcy5fX2xpbmVzW3RoaXMuX19saW5lcy5sZW5ndGggLSAyXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpbmRleC0tO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5PdXRwdXQgPSBPdXRwdXQ7XG5cblxuLyoqKi8gfSksXG4vKiAzICovLFxuLyogNCAqLyxcbi8qIDUgKi8sXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxuZnVuY3Rpb24gT3B0aW9ucyhvcHRpb25zLCBtZXJnZV9jaGlsZF9maWVsZCkge1xuICB0aGlzLnJhd19vcHRpb25zID0gX21lcmdlT3B0cyhvcHRpb25zLCBtZXJnZV9jaGlsZF9maWVsZCk7XG5cbiAgLy8gU3VwcG9ydCBwYXNzaW5nIHRoZSBzb3VyY2UgdGV4dCBiYWNrIHdpdGggbm8gY2hhbmdlXG4gIHRoaXMuZGlzYWJsZWQgPSB0aGlzLl9nZXRfYm9vbGVhbignZGlzYWJsZWQnKTtcblxuICB0aGlzLmVvbCA9IHRoaXMuX2dldF9jaGFyYWN0ZXJzKCdlb2wnLCAnYXV0bycpO1xuICB0aGlzLmVuZF93aXRoX25ld2xpbmUgPSB0aGlzLl9nZXRfYm9vbGVhbignZW5kX3dpdGhfbmV3bGluZScpO1xuICB0aGlzLmluZGVudF9zaXplID0gdGhpcy5fZ2V0X251bWJlcignaW5kZW50X3NpemUnLCA0KTtcbiAgdGhpcy5pbmRlbnRfY2hhciA9IHRoaXMuX2dldF9jaGFyYWN0ZXJzKCdpbmRlbnRfY2hhcicsICcgJyk7XG4gIHRoaXMuaW5kZW50X2xldmVsID0gdGhpcy5fZ2V0X251bWJlcignaW5kZW50X2xldmVsJyk7XG5cbiAgdGhpcy5wcmVzZXJ2ZV9uZXdsaW5lcyA9IHRoaXMuX2dldF9ib29sZWFuKCdwcmVzZXJ2ZV9uZXdsaW5lcycsIHRydWUpO1xuICB0aGlzLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcyA9IHRoaXMuX2dldF9udW1iZXIoJ21heF9wcmVzZXJ2ZV9uZXdsaW5lcycsIDMyNzg2KTtcbiAgaWYgKCF0aGlzLnByZXNlcnZlX25ld2xpbmVzKSB7XG4gICAgdGhpcy5tYXhfcHJlc2VydmVfbmV3bGluZXMgPSAwO1xuICB9XG5cbiAgdGhpcy5pbmRlbnRfd2l0aF90YWJzID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ2luZGVudF93aXRoX3RhYnMnLCB0aGlzLmluZGVudF9jaGFyID09PSAnXFx0Jyk7XG4gIGlmICh0aGlzLmluZGVudF93aXRoX3RhYnMpIHtcbiAgICB0aGlzLmluZGVudF9jaGFyID0gJ1xcdCc7XG5cbiAgICAvLyBpbmRlbnRfc2l6ZSBiZWhhdmlvciBjaGFuZ2VkIGFmdGVyIDEuOC42XG4gICAgLy8gSXQgdXNlZCB0byBiZSB0aGF0IGluZGVudF9zaXplIHdvdWxkIGJlXG4gICAgLy8gc2V0IHRvIDEgZm9yIGluZGVudF93aXRoX3RhYnMuIFRoYXQgaXMgbm8gbG9uZ2VyIG5lZWRlZCBhbmRcbiAgICAvLyBhY3R1YWxseSBkb2Vzbid0IG1ha2Ugc2Vuc2UgLSB3aHkgbm90IHVzZSBzcGFjZXM/IEZ1cnRoZXIsXG4gICAgLy8gdGhhdCBtaWdodCBwcm9kdWNlIHVuZXhwZWN0ZWQgYmVoYXZpb3IgLSB0YWJzIGJlaW5nIHVzZWRcbiAgICAvLyBmb3Igc2luZ2xlLWNvbHVtbiBhbGlnbm1lbnQuIFNvLCB3aGVuIGluZGVudF93aXRoX3RhYnMgaXMgdHJ1ZVxuICAgIC8vIGFuZCBpbmRlbnRfc2l6ZSBpcyAxLCByZXNldCBpbmRlbnRfc2l6ZSB0byA0LlxuICAgIGlmICh0aGlzLmluZGVudF9zaXplID09PSAxKSB7XG4gICAgICB0aGlzLmluZGVudF9zaXplID0gNDtcbiAgICB9XG4gIH1cblxuICAvLyBCYWNrd2FyZHMgY29tcGF0IHdpdGggMS4zLnhcbiAgdGhpcy53cmFwX2xpbmVfbGVuZ3RoID0gdGhpcy5fZ2V0X251bWJlcignd3JhcF9saW5lX2xlbmd0aCcsIHRoaXMuX2dldF9udW1iZXIoJ21heF9jaGFyJykpO1xuXG4gIHRoaXMuaW5kZW50X2VtcHR5X2xpbmVzID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ2luZGVudF9lbXB0eV9saW5lcycpO1xuXG4gIC8vIHZhbGlkIHRlbXBsYXRpbmcgbGFuZ3VhZ2VzIFsnZGphbmdvJywgJ2VyYicsICdoYW5kbGViYXJzJywgJ3BocCcsICdzbWFydHknXVxuICAvLyBGb3Igbm93LCAnYXV0bycgPSBhbGwgb2ZmIGZvciBqYXZhc2NyaXB0LCBhbGwgb24gZm9yIGh0bWwgKGFuZCBpbmxpbmUgamF2YXNjcmlwdCkuXG4gIC8vIG90aGVyIHZhbHVlcyBpZ25vcmVkXG4gIHRoaXMudGVtcGxhdGluZyA9IHRoaXMuX2dldF9zZWxlY3Rpb25fbGlzdCgndGVtcGxhdGluZycsIFsnYXV0bycsICdub25lJywgJ2RqYW5nbycsICdlcmInLCAnaGFuZGxlYmFycycsICdwaHAnLCAnc21hcnR5J10sIFsnYXV0byddKTtcbn1cblxuT3B0aW9ucy5wcm90b3R5cGUuX2dldF9hcnJheSA9IGZ1bmN0aW9uKG5hbWUsIGRlZmF1bHRfdmFsdWUpIHtcbiAgdmFyIG9wdGlvbl92YWx1ZSA9IHRoaXMucmF3X29wdGlvbnNbbmFtZV07XG4gIHZhciByZXN1bHQgPSBkZWZhdWx0X3ZhbHVlIHx8IFtdO1xuICBpZiAodHlwZW9mIG9wdGlvbl92YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAob3B0aW9uX3ZhbHVlICE9PSBudWxsICYmIHR5cGVvZiBvcHRpb25fdmFsdWUuY29uY2F0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXN1bHQgPSBvcHRpb25fdmFsdWUuY29uY2F0KCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25fdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmVzdWx0ID0gb3B0aW9uX3ZhbHVlLnNwbGl0KC9bXmEtekEtWjAtOV9cXC9cXC1dKy8pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5PcHRpb25zLnByb3RvdHlwZS5fZ2V0X2Jvb2xlYW4gPSBmdW5jdGlvbihuYW1lLCBkZWZhdWx0X3ZhbHVlKSB7XG4gIHZhciBvcHRpb25fdmFsdWUgPSB0aGlzLnJhd19vcHRpb25zW25hbWVdO1xuICB2YXIgcmVzdWx0ID0gb3B0aW9uX3ZhbHVlID09PSB1bmRlZmluZWQgPyAhIWRlZmF1bHRfdmFsdWUgOiAhIW9wdGlvbl92YWx1ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk9wdGlvbnMucHJvdG90eXBlLl9nZXRfY2hhcmFjdGVycyA9IGZ1bmN0aW9uKG5hbWUsIGRlZmF1bHRfdmFsdWUpIHtcbiAgdmFyIG9wdGlvbl92YWx1ZSA9IHRoaXMucmF3X29wdGlvbnNbbmFtZV07XG4gIHZhciByZXN1bHQgPSBkZWZhdWx0X3ZhbHVlIHx8ICcnO1xuICBpZiAodHlwZW9mIG9wdGlvbl92YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXN1bHQgPSBvcHRpb25fdmFsdWUucmVwbGFjZSgvXFxcXHIvLCAnXFxyJykucmVwbGFjZSgvXFxcXG4vLCAnXFxuJykucmVwbGFjZSgvXFxcXHQvLCAnXFx0Jyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk9wdGlvbnMucHJvdG90eXBlLl9nZXRfbnVtYmVyID0gZnVuY3Rpb24obmFtZSwgZGVmYXVsdF92YWx1ZSkge1xuICB2YXIgb3B0aW9uX3ZhbHVlID0gdGhpcy5yYXdfb3B0aW9uc1tuYW1lXTtcbiAgZGVmYXVsdF92YWx1ZSA9IHBhcnNlSW50KGRlZmF1bHRfdmFsdWUsIDEwKTtcbiAgaWYgKGlzTmFOKGRlZmF1bHRfdmFsdWUpKSB7XG4gICAgZGVmYXVsdF92YWx1ZSA9IDA7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KG9wdGlvbl92YWx1ZSwgMTApO1xuICBpZiAoaXNOYU4ocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IGRlZmF1bHRfdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk9wdGlvbnMucHJvdG90eXBlLl9nZXRfc2VsZWN0aW9uID0gZnVuY3Rpb24obmFtZSwgc2VsZWN0aW9uX2xpc3QsIGRlZmF1bHRfdmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2dldF9zZWxlY3Rpb25fbGlzdChuYW1lLCBzZWxlY3Rpb25fbGlzdCwgZGVmYXVsdF92YWx1ZSk7XG4gIGlmIChyZXN1bHQubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJJbnZhbGlkIE9wdGlvbiBWYWx1ZTogVGhlIG9wdGlvbiAnXCIgKyBuYW1lICsgXCInIGNhbiBvbmx5IGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHZhbHVlczpcXG5cIiArXG4gICAgICBzZWxlY3Rpb25fbGlzdCArIFwiXFxuWW91IHBhc3NlZCBpbjogJ1wiICsgdGhpcy5yYXdfb3B0aW9uc1tuYW1lXSArIFwiJ1wiKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHRbMF07XG59O1xuXG5cbk9wdGlvbnMucHJvdG90eXBlLl9nZXRfc2VsZWN0aW9uX2xpc3QgPSBmdW5jdGlvbihuYW1lLCBzZWxlY3Rpb25fbGlzdCwgZGVmYXVsdF92YWx1ZSkge1xuICBpZiAoIXNlbGVjdGlvbl9saXN0IHx8IHNlbGVjdGlvbl9saXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNlbGVjdGlvbiBsaXN0IGNhbm5vdCBiZSBlbXB0eS5cIik7XG4gIH1cblxuICBkZWZhdWx0X3ZhbHVlID0gZGVmYXVsdF92YWx1ZSB8fCBbc2VsZWN0aW9uX2xpc3RbMF1dO1xuICBpZiAoIXRoaXMuX2lzX3ZhbGlkX3NlbGVjdGlvbihkZWZhdWx0X3ZhbHVlLCBzZWxlY3Rpb25fbGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIERlZmF1bHQgVmFsdWUhXCIpO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2dldF9hcnJheShuYW1lLCBkZWZhdWx0X3ZhbHVlKTtcbiAgaWYgKCF0aGlzLl9pc192YWxpZF9zZWxlY3Rpb24ocmVzdWx0LCBzZWxlY3Rpb25fbGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkludmFsaWQgT3B0aW9uIFZhbHVlOiBUaGUgb3B0aW9uICdcIiArIG5hbWUgKyBcIicgY2FuIGNvbnRhaW4gb25seSB0aGUgZm9sbG93aW5nIHZhbHVlczpcXG5cIiArXG4gICAgICBzZWxlY3Rpb25fbGlzdCArIFwiXFxuWW91IHBhc3NlZCBpbjogJ1wiICsgdGhpcy5yYXdfb3B0aW9uc1tuYW1lXSArIFwiJ1wiKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5PcHRpb25zLnByb3RvdHlwZS5faXNfdmFsaWRfc2VsZWN0aW9uID0gZnVuY3Rpb24ocmVzdWx0LCBzZWxlY3Rpb25fbGlzdCkge1xuICByZXR1cm4gcmVzdWx0Lmxlbmd0aCAmJiBzZWxlY3Rpb25fbGlzdC5sZW5ndGggJiZcbiAgICAhcmVzdWx0LnNvbWUoZnVuY3Rpb24oaXRlbSkgeyByZXR1cm4gc2VsZWN0aW9uX2xpc3QuaW5kZXhPZihpdGVtKSA9PT0gLTE7IH0pO1xufTtcblxuXG4vLyBtZXJnZXMgY2hpbGQgb3B0aW9ucyB1cCB3aXRoIHRoZSBwYXJlbnQgb3B0aW9ucyBvYmplY3Rcbi8vIEV4YW1wbGU6IG9iaiA9IHthOiAxLCBiOiB7YTogMn19XG4vLyAgICAgICAgICBtZXJnZU9wdHMob2JqLCAnYicpXG4vL1xuLy8gICAgICAgICAgUmV0dXJuczoge2E6IDJ9XG5mdW5jdGlvbiBfbWVyZ2VPcHRzKGFsbE9wdGlvbnMsIGNoaWxkRmllbGROYW1lKSB7XG4gIHZhciBmaW5hbE9wdHMgPSB7fTtcbiAgYWxsT3B0aW9ucyA9IF9ub3JtYWxpemVPcHRzKGFsbE9wdGlvbnMpO1xuICB2YXIgbmFtZTtcblxuICBmb3IgKG5hbWUgaW4gYWxsT3B0aW9ucykge1xuICAgIGlmIChuYW1lICE9PSBjaGlsZEZpZWxkTmFtZSkge1xuICAgICAgZmluYWxPcHRzW25hbWVdID0gYWxsT3B0aW9uc1tuYW1lXTtcbiAgICB9XG4gIH1cblxuICAvL21lcmdlIGluIHRoZSBwZXIgdHlwZSBzZXR0aW5ncyBmb3IgdGhlIGNoaWxkRmllbGROYW1lXG4gIGlmIChjaGlsZEZpZWxkTmFtZSAmJiBhbGxPcHRpb25zW2NoaWxkRmllbGROYW1lXSkge1xuICAgIGZvciAobmFtZSBpbiBhbGxPcHRpb25zW2NoaWxkRmllbGROYW1lXSkge1xuICAgICAgZmluYWxPcHRzW25hbWVdID0gYWxsT3B0aW9uc1tjaGlsZEZpZWxkTmFtZV1bbmFtZV07XG4gICAgfVxuICB9XG4gIHJldHVybiBmaW5hbE9wdHM7XG59XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVPcHRzKG9wdGlvbnMpIHtcbiAgdmFyIGNvbnZlcnRlZE9wdHMgPSB7fTtcbiAgdmFyIGtleTtcblxuICBmb3IgKGtleSBpbiBvcHRpb25zKSB7XG4gICAgdmFyIG5ld0tleSA9IGtleS5yZXBsYWNlKC8tL2csIFwiX1wiKTtcbiAgICBjb252ZXJ0ZWRPcHRzW25ld0tleV0gPSBvcHRpb25zW2tleV07XG4gIH1cbiAgcmV0dXJuIGNvbnZlcnRlZE9wdHM7XG59XG5cbm1vZHVsZS5leHBvcnRzLk9wdGlvbnMgPSBPcHRpb25zO1xubW9kdWxlLmV4cG9ydHMubm9ybWFsaXplT3B0cyA9IF9ub3JtYWxpemVPcHRzO1xubW9kdWxlLmV4cG9ydHMubWVyZ2VPcHRzID0gX21lcmdlT3B0cztcblxuXG4vKioqLyB9KSxcbi8qIDcgKi8sXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxudmFyIHJlZ2V4cF9oYXNfc3RpY2t5ID0gUmVnRXhwLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnc3RpY2t5Jyk7XG5cbmZ1bmN0aW9uIElucHV0U2Nhbm5lcihpbnB1dF9zdHJpbmcpIHtcbiAgdGhpcy5fX2lucHV0ID0gaW5wdXRfc3RyaW5nIHx8ICcnO1xuICB0aGlzLl9faW5wdXRfbGVuZ3RoID0gdGhpcy5fX2lucHV0Lmxlbmd0aDtcbiAgdGhpcy5fX3Bvc2l0aW9uID0gMDtcbn1cblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5yZXN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX19wb3NpdGlvbiA9IDA7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLmJhY2sgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX19wb3NpdGlvbiA+IDApIHtcbiAgICB0aGlzLl9fcG9zaXRpb24gLT0gMTtcbiAgfVxufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5oYXNOZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9fcG9zaXRpb24gPCB0aGlzLl9faW5wdXRfbGVuZ3RoO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciB2YWwgPSBudWxsO1xuICBpZiAodGhpcy5oYXNOZXh0KCkpIHtcbiAgICB2YWwgPSB0aGlzLl9faW5wdXQuY2hhckF0KHRoaXMuX19wb3NpdGlvbik7XG4gICAgdGhpcy5fX3Bvc2l0aW9uICs9IDE7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gIHZhciB2YWwgPSBudWxsO1xuICBpbmRleCA9IGluZGV4IHx8IDA7XG4gIGluZGV4ICs9IHRoaXMuX19wb3NpdGlvbjtcbiAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9faW5wdXRfbGVuZ3RoKSB7XG4gICAgdmFsID0gdGhpcy5fX2lucHV0LmNoYXJBdChpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5cbi8vIFRoaXMgaXMgYSBKYXZhU2NyaXB0IG9ubHkgaGVscGVyIGZ1bmN0aW9uIChub3QgaW4gcHl0aG9uKVxuLy8gSmF2YXNjcmlwdCBkb2Vzbid0IGhhdmUgYSBtYXRjaCBtZXRob2Rcbi8vIGFuZCBub3QgYWxsIGltcGxlbWVudGF0aW9uIHN1cHBvcnQgXCJzdGlja3lcIiBmbGFnLlxuLy8gSWYgdGhleSBkbyBub3Qgc3VwcG9ydCBzdGlja3kgdGhlbiBib3RoIHRoaXMubWF0Y2goKSBhbmQgdGhpcy50ZXN0KCkgbWV0aG9kXG4vLyBtdXN0IGdldCB0aGUgbWF0Y2ggYW5kIGNoZWNrIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2guXG4vLyBJZiBzdGlja3kgaXMgc3VwcG9ydGVkIGFuZCBzZXQsIHRoaXMgbWV0aG9kIHdpbGwgdXNlIGl0LlxuLy8gT3RoZXJ3aXNlIGl0IHdpbGwgY2hlY2sgdGhhdCBnbG9iYWwgaXMgc2V0LCBhbmQgZmFsbCBiYWNrIHRvIHRoZSBzbG93ZXIgbWV0aG9kLlxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5fX21hdGNoID0gZnVuY3Rpb24ocGF0dGVybiwgaW5kZXgpIHtcbiAgcGF0dGVybi5sYXN0SW5kZXggPSBpbmRleDtcbiAgdmFyIHBhdHRlcm5fbWF0Y2ggPSBwYXR0ZXJuLmV4ZWModGhpcy5fX2lucHV0KTtcblxuICBpZiAocGF0dGVybl9tYXRjaCAmJiAhKHJlZ2V4cF9oYXNfc3RpY2t5ICYmIHBhdHRlcm4uc3RpY2t5KSkge1xuICAgIGlmIChwYXR0ZXJuX21hdGNoLmluZGV4ICE9PSBpbmRleCkge1xuICAgICAgcGF0dGVybl9tYXRjaCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhdHRlcm5fbWF0Y2g7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbihwYXR0ZXJuLCBpbmRleCkge1xuICBpbmRleCA9IGluZGV4IHx8IDA7XG4gIGluZGV4ICs9IHRoaXMuX19wb3NpdGlvbjtcblxuICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuX19pbnB1dF9sZW5ndGgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9fbWF0Y2gocGF0dGVybiwgaW5kZXgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS50ZXN0Q2hhciA9IGZ1bmN0aW9uKHBhdHRlcm4sIGluZGV4KSB7XG4gIC8vIHRlc3Qgb25lIGNoYXJhY3RlciByZWdleCBtYXRjaFxuICB2YXIgdmFsID0gdGhpcy5wZWVrKGluZGV4KTtcbiAgcGF0dGVybi5sYXN0SW5kZXggPSAwO1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmIHBhdHRlcm4udGVzdCh2YWwpO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgdmFyIHBhdHRlcm5fbWF0Y2ggPSB0aGlzLl9fbWF0Y2gocGF0dGVybiwgdGhpcy5fX3Bvc2l0aW9uKTtcbiAgaWYgKHBhdHRlcm5fbWF0Y2gpIHtcbiAgICB0aGlzLl9fcG9zaXRpb24gKz0gcGF0dGVybl9tYXRjaFswXS5sZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgcGF0dGVybl9tYXRjaCA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIHBhdHRlcm5fbWF0Y2g7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihzdGFydGluZ19wYXR0ZXJuLCB1bnRpbF9wYXR0ZXJuLCB1bnRpbF9hZnRlcikge1xuICB2YXIgdmFsID0gJyc7XG4gIHZhciBtYXRjaDtcbiAgaWYgKHN0YXJ0aW5nX3BhdHRlcm4pIHtcbiAgICBtYXRjaCA9IHRoaXMubWF0Y2goc3RhcnRpbmdfcGF0dGVybik7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB2YWwgKz0gbWF0Y2hbMF07XG4gICAgfVxuICB9XG4gIGlmICh1bnRpbF9wYXR0ZXJuICYmIChtYXRjaCB8fCAhc3RhcnRpbmdfcGF0dGVybikpIHtcbiAgICB2YWwgKz0gdGhpcy5yZWFkVW50aWwodW50aWxfcGF0dGVybiwgdW50aWxfYWZ0ZXIpO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnJlYWRVbnRpbCA9IGZ1bmN0aW9uKHBhdHRlcm4sIHVudGlsX2FmdGVyKSB7XG4gIHZhciB2YWwgPSAnJztcbiAgdmFyIG1hdGNoX2luZGV4ID0gdGhpcy5fX3Bvc2l0aW9uO1xuICBwYXR0ZXJuLmxhc3RJbmRleCA9IHRoaXMuX19wb3NpdGlvbjtcbiAgdmFyIHBhdHRlcm5fbWF0Y2ggPSBwYXR0ZXJuLmV4ZWModGhpcy5fX2lucHV0KTtcbiAgaWYgKHBhdHRlcm5fbWF0Y2gpIHtcbiAgICBtYXRjaF9pbmRleCA9IHBhdHRlcm5fbWF0Y2guaW5kZXg7XG4gICAgaWYgKHVudGlsX2FmdGVyKSB7XG4gICAgICBtYXRjaF9pbmRleCArPSBwYXR0ZXJuX21hdGNoWzBdLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWF0Y2hfaW5kZXggPSB0aGlzLl9faW5wdXRfbGVuZ3RoO1xuICB9XG5cbiAgdmFsID0gdGhpcy5fX2lucHV0LnN1YnN0cmluZyh0aGlzLl9fcG9zaXRpb24sIG1hdGNoX2luZGV4KTtcbiAgdGhpcy5fX3Bvc2l0aW9uID0gbWF0Y2hfaW5kZXg7XG4gIHJldHVybiB2YWw7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnJlYWRVbnRpbEFmdGVyID0gZnVuY3Rpb24ocGF0dGVybikge1xuICByZXR1cm4gdGhpcy5yZWFkVW50aWwocGF0dGVybiwgdHJ1ZSk7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLmdldF9yZWdleHAgPSBmdW5jdGlvbihwYXR0ZXJuLCBtYXRjaF9mcm9tKSB7XG4gIHZhciByZXN1bHQgPSBudWxsO1xuICB2YXIgZmxhZ3MgPSAnZyc7XG4gIGlmIChtYXRjaF9mcm9tICYmIHJlZ2V4cF9oYXNfc3RpY2t5KSB7XG4gICAgZmxhZ3MgPSAneSc7XG4gIH1cbiAgLy8gc3RyaW5ncyBhcmUgY29udmVydGVkIHRvIHJlZ2V4cFxuICBpZiAodHlwZW9mIHBhdHRlcm4gPT09IFwic3RyaW5nXCIgJiYgcGF0dGVybiAhPT0gJycpIHtcbiAgICAvLyByZXN1bHQgPSBuZXcgUmVnRXhwKHBhdHRlcm4ucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyksIGZsYWdzKTtcbiAgICByZXN1bHQgPSBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgfSBlbHNlIGlmIChwYXR0ZXJuKSB7XG4gICAgcmVzdWx0ID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnNvdXJjZSwgZmxhZ3MpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLmdldF9saXRlcmFsX3JlZ2V4cCA9IGZ1bmN0aW9uKGxpdGVyYWxfc3RyaW5nKSB7XG4gIHJldHVybiBSZWdFeHAobGl0ZXJhbF9zdHJpbmcucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJykpO1xufTtcblxuLyogY3NzIGJlYXV0aWZpZXIgbGVnYWN5IGhlbHBlcnMgKi9cbklucHV0U2Nhbm5lci5wcm90b3R5cGUucGVla1VudGlsQWZ0ZXIgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHZhciBzdGFydCA9IHRoaXMuX19wb3NpdGlvbjtcbiAgdmFyIHZhbCA9IHRoaXMucmVhZFVudGlsQWZ0ZXIocGF0dGVybik7XG4gIHRoaXMuX19wb3NpdGlvbiA9IHN0YXJ0O1xuICByZXR1cm4gdmFsO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5sb29rQmFjayA9IGZ1bmN0aW9uKHRlc3RWYWwpIHtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5fX3Bvc2l0aW9uIC0gMTtcbiAgcmV0dXJuIHN0YXJ0ID49IHRlc3RWYWwubGVuZ3RoICYmIHRoaXMuX19pbnB1dC5zdWJzdHJpbmcoc3RhcnQgLSB0ZXN0VmFsLmxlbmd0aCwgc3RhcnQpXG4gICAgLnRvTG93ZXJDYXNlKCkgPT09IHRlc3RWYWw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5JbnB1dFNjYW5uZXIgPSBJbnB1dFNjYW5uZXI7XG5cblxuLyoqKi8gfSksXG4vKiA5ICovLFxuLyogMTAgKi8sXG4vKiAxMSAqLyxcbi8qIDEyICovLFxuLyogMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG5mdW5jdGlvbiBEaXJlY3RpdmVzKHN0YXJ0X2Jsb2NrX3BhdHRlcm4sIGVuZF9ibG9ja19wYXR0ZXJuKSB7XG4gIHN0YXJ0X2Jsb2NrX3BhdHRlcm4gPSB0eXBlb2Ygc3RhcnRfYmxvY2tfcGF0dGVybiA9PT0gJ3N0cmluZycgPyBzdGFydF9ibG9ja19wYXR0ZXJuIDogc3RhcnRfYmxvY2tfcGF0dGVybi5zb3VyY2U7XG4gIGVuZF9ibG9ja19wYXR0ZXJuID0gdHlwZW9mIGVuZF9ibG9ja19wYXR0ZXJuID09PSAnc3RyaW5nJyA/IGVuZF9ibG9ja19wYXR0ZXJuIDogZW5kX2Jsb2NrX3BhdHRlcm4uc291cmNlO1xuICB0aGlzLl9fZGlyZWN0aXZlc19ibG9ja19wYXR0ZXJuID0gbmV3IFJlZ0V4cChzdGFydF9ibG9ja19wYXR0ZXJuICsgLyBiZWF1dGlmeSggXFx3K1s6XVxcdyspKyAvLnNvdXJjZSArIGVuZF9ibG9ja19wYXR0ZXJuLCAnZycpO1xuICB0aGlzLl9fZGlyZWN0aXZlX3BhdHRlcm4gPSAvIChcXHcrKVs6XShcXHcrKS9nO1xuXG4gIHRoaXMuX19kaXJlY3RpdmVzX2VuZF9pZ25vcmVfcGF0dGVybiA9IG5ldyBSZWdFeHAoc3RhcnRfYmxvY2tfcGF0dGVybiArIC9cXHNiZWF1dGlmeVxcc2lnbm9yZTplbmRcXHMvLnNvdXJjZSArIGVuZF9ibG9ja19wYXR0ZXJuLCAnZycpO1xufVxuXG5EaXJlY3RpdmVzLnByb3RvdHlwZS5nZXRfZGlyZWN0aXZlcyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgaWYgKCF0ZXh0Lm1hdGNoKHRoaXMuX19kaXJlY3RpdmVzX2Jsb2NrX3BhdHRlcm4pKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZGlyZWN0aXZlcyA9IHt9O1xuICB0aGlzLl9fZGlyZWN0aXZlX3BhdHRlcm4ubGFzdEluZGV4ID0gMDtcbiAgdmFyIGRpcmVjdGl2ZV9tYXRjaCA9IHRoaXMuX19kaXJlY3RpdmVfcGF0dGVybi5leGVjKHRleHQpO1xuXG4gIHdoaWxlIChkaXJlY3RpdmVfbWF0Y2gpIHtcbiAgICBkaXJlY3RpdmVzW2RpcmVjdGl2ZV9tYXRjaFsxXV0gPSBkaXJlY3RpdmVfbWF0Y2hbMl07XG4gICAgZGlyZWN0aXZlX21hdGNoID0gdGhpcy5fX2RpcmVjdGl2ZV9wYXR0ZXJuLmV4ZWModGV4dCk7XG4gIH1cblxuICByZXR1cm4gZGlyZWN0aXZlcztcbn07XG5cbkRpcmVjdGl2ZXMucHJvdG90eXBlLnJlYWRJZ25vcmVkID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgcmV0dXJuIGlucHV0LnJlYWRVbnRpbEFmdGVyKHRoaXMuX19kaXJlY3RpdmVzX2VuZF9pZ25vcmVfcGF0dGVybik7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzLkRpcmVjdGl2ZXMgPSBEaXJlY3RpdmVzO1xuXG5cbi8qKiovIH0pLFxuLyogMTQgKi8sXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxudmFyIEJlYXV0aWZpZXIgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxNikuQmVhdXRpZmllciksXG4gIE9wdGlvbnMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxNykuT3B0aW9ucyk7XG5cbmZ1bmN0aW9uIGNzc19iZWF1dGlmeShzb3VyY2VfdGV4dCwgb3B0aW9ucykge1xuICB2YXIgYmVhdXRpZmllciA9IG5ldyBCZWF1dGlmaWVyKHNvdXJjZV90ZXh0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGJlYXV0aWZpZXIuYmVhdXRpZnkoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjc3NfYmVhdXRpZnk7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IE9wdGlvbnMoKTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxudmFyIE9wdGlvbnMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxNykuT3B0aW9ucyk7XG52YXIgT3V0cHV0ID0gKF9fd2VicGFja19yZXF1aXJlX18oMikuT3V0cHV0KTtcbnZhciBJbnB1dFNjYW5uZXIgPSAoX193ZWJwYWNrX3JlcXVpcmVfXyg4KS5JbnB1dFNjYW5uZXIpO1xudmFyIERpcmVjdGl2ZXMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxMykuRGlyZWN0aXZlcyk7XG5cbnZhciBkaXJlY3RpdmVzX2NvcmUgPSBuZXcgRGlyZWN0aXZlcygvXFwvXFwqLywgL1xcKlxcLy8pO1xuXG52YXIgbGluZUJyZWFrID0gL1xcclxcbnxbXFxyXFxuXS87XG52YXIgYWxsTGluZUJyZWFrcyA9IC9cXHJcXG58W1xcclxcbl0vZztcblxuLy8gdG9rZW5pemVyXG52YXIgd2hpdGVzcGFjZUNoYXIgPSAvXFxzLztcbnZhciB3aGl0ZXNwYWNlUGF0dGVybiA9IC8oPzpcXHN8XFxuKSsvZztcbnZhciBibG9ja19jb21tZW50X3BhdHRlcm4gPSAvXFwvXFwqKD86W1xcc1xcU10qPykoKD86XFwqXFwvKXwkKS9nO1xudmFyIGNvbW1lbnRfcGF0dGVybiA9IC9cXC9cXC8oPzpbXlxcblxcclxcdTIwMjhcXHUyMDI5XSopL2c7XG5cbmZ1bmN0aW9uIEJlYXV0aWZpZXIoc291cmNlX3RleHQsIG9wdGlvbnMpIHtcbiAgdGhpcy5fc291cmNlX3RleHQgPSBzb3VyY2VfdGV4dCB8fCAnJztcbiAgLy8gQWxsb3cgdGhlIHNldHRpbmcgb2YgbGFuZ3VhZ2UvZmlsZS10eXBlIHNwZWNpZmljIG9wdGlvbnNcbiAgLy8gd2l0aCBpbmhlcml0YW5jZSBvZiBvdmVyYWxsIHNldHRpbmdzXG4gIHRoaXMuX29wdGlvbnMgPSBuZXcgT3B0aW9ucyhvcHRpb25zKTtcbiAgdGhpcy5fY2ggPSBudWxsO1xuICB0aGlzLl9pbnB1dCA9IG51bGw7XG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0F0LXJ1bGVcbiAgdGhpcy5ORVNURURfQVRfUlVMRSA9IHtcbiAgICBcInBhZ2VcIjogdHJ1ZSxcbiAgICBcImZvbnQtZmFjZVwiOiB0cnVlLFxuICAgIFwia2V5ZnJhbWVzXCI6IHRydWUsXG4gICAgLy8gYWxzbyBpbiBDT05ESVRJT05BTF9HUk9VUF9SVUxFIGJlbG93XG4gICAgXCJtZWRpYVwiOiB0cnVlLFxuICAgIFwic3VwcG9ydHNcIjogdHJ1ZSxcbiAgICBcImRvY3VtZW50XCI6IHRydWVcbiAgfTtcbiAgdGhpcy5DT05ESVRJT05BTF9HUk9VUF9SVUxFID0ge1xuICAgIFwibWVkaWFcIjogdHJ1ZSxcbiAgICBcInN1cHBvcnRzXCI6IHRydWUsXG4gICAgXCJkb2N1bWVudFwiOiB0cnVlXG4gIH07XG4gIHRoaXMuTk9OX1NFTUlDT0xPTl9ORVdMSU5FX1BST1BFUlRZID0gW1xuICAgIFwiZ3JpZC10ZW1wbGF0ZS1hcmVhc1wiLFxuICAgIFwiZ3JpZC10ZW1wbGF0ZVwiXG4gIF07XG5cbn1cblxuQmVhdXRpZmllci5wcm90b3R5cGUuZWF0U3RyaW5nID0gZnVuY3Rpb24oZW5kQ2hhcnMpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICB0aGlzLl9jaCA9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgd2hpbGUgKHRoaXMuX2NoKSB7XG4gICAgcmVzdWx0ICs9IHRoaXMuX2NoO1xuICAgIGlmICh0aGlzLl9jaCA9PT0gXCJcXFxcXCIpIHtcbiAgICAgIHJlc3VsdCArPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgfSBlbHNlIGlmIChlbmRDaGFycy5pbmRleE9mKHRoaXMuX2NoKSAhPT0gLTEgfHwgdGhpcy5fY2ggPT09IFwiXFxuXCIpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl9jaCA9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gU2tpcHMgYW55IHdoaXRlIHNwYWNlIGluIHRoZSBzb3VyY2UgdGV4dCBmcm9tIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuLy8gV2hlbiBhbGxvd0F0TGVhc3RPbmVOZXdMaW5lIGlzIHRydWUsIHdpbGwgb3V0cHV0IG5ldyBsaW5lcyBmb3IgZWFjaFxuLy8gbmV3bGluZSBjaGFyYWN0ZXIgZm91bmQ7IGlmIHRoZSB1c2VyIGhhcyBwcmVzZXJ2ZV9uZXdsaW5lcyBvZmYsIG9ubHlcbi8vIHRoZSBmaXJzdCBuZXdsaW5lIHdpbGwgYmUgb3V0cHV0XG5CZWF1dGlmaWVyLnByb3RvdHlwZS5lYXRXaGl0ZXNwYWNlID0gZnVuY3Rpb24oYWxsb3dBdExlYXN0T25lTmV3TGluZSkge1xuICB2YXIgcmVzdWx0ID0gd2hpdGVzcGFjZUNoYXIudGVzdCh0aGlzLl9pbnB1dC5wZWVrKCkpO1xuICB2YXIgbmV3bGluZV9jb3VudCA9IDA7XG4gIHdoaWxlICh3aGl0ZXNwYWNlQ2hhci50ZXN0KHRoaXMuX2lucHV0LnBlZWsoKSkpIHtcbiAgICB0aGlzLl9jaCA9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICBpZiAoYWxsb3dBdExlYXN0T25lTmV3TGluZSAmJiB0aGlzLl9jaCA9PT0gJ1xcbicpIHtcbiAgICAgIGlmIChuZXdsaW5lX2NvdW50ID09PSAwIHx8IG5ld2xpbmVfY291bnQgPCB0aGlzLl9vcHRpb25zLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcykge1xuICAgICAgICBuZXdsaW5lX2NvdW50Kys7XG4gICAgICAgIHRoaXMuX291dHB1dC5hZGRfbmV3X2xpbmUodHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBOZXN0ZWQgcHNldWRvLWNsYXNzIGlmIHdlIGFyZSBpbnNpZGVSdWxlXG4vLyBhbmQgdGhlIG5leHQgc3BlY2lhbCBjaGFyYWN0ZXIgZm91bmQgb3BlbnNcbi8vIGEgbmV3IGJsb2NrXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5mb3VuZE5lc3RlZFBzZXVkb0NsYXNzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBvcGVuUGFyZW4gPSAwO1xuICB2YXIgaSA9IDE7XG4gIHZhciBjaCA9IHRoaXMuX2lucHV0LnBlZWsoaSk7XG4gIHdoaWxlIChjaCkge1xuICAgIGlmIChjaCA9PT0gXCJ7XCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09ICcoJykge1xuICAgICAgLy8gcHNldWRvY2xhc3NlcyBjYW4gY29udGFpbiAoKVxuICAgICAgb3BlblBhcmVuICs9IDE7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gJyknKSB7XG4gICAgICBpZiAob3BlblBhcmVuID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9wZW5QYXJlbiAtPSAxO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiO1wiIHx8IGNoID09PSBcIn1cIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpKys7XG4gICAgY2ggPSB0aGlzLl9pbnB1dC5wZWVrKGkpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLnByaW50X3N0cmluZyA9IGZ1bmN0aW9uKG91dHB1dF9zdHJpbmcpIHtcbiAgdGhpcy5fb3V0cHV0LnNldF9pbmRlbnQodGhpcy5faW5kZW50TGV2ZWwpO1xuICB0aGlzLl9vdXRwdXQubm9uX2JyZWFraW5nX3NwYWNlID0gdHJ1ZTtcbiAgdGhpcy5fb3V0cHV0LmFkZF90b2tlbihvdXRwdXRfc3RyaW5nKTtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLnByZXNlcnZlU2luZ2xlU3BhY2UgPSBmdW5jdGlvbihpc0FmdGVyU3BhY2UpIHtcbiAgaWYgKGlzQWZ0ZXJTcGFjZSkge1xuICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5pbmRlbnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5faW5kZW50TGV2ZWwrKztcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLm91dGRlbnQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX2luZGVudExldmVsID4gMCkge1xuICAgIHRoaXMuX2luZGVudExldmVsLS07XG4gIH1cbn07XG5cbi8qX19fX19fX19fX19fX19fX19fX19fLS0tLS0tLS0tLS0tLS0tLS0tLS1fX19fX19fX19fX19fX19fX19fX18qL1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5iZWF1dGlmeSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fb3B0aW9ucy5kaXNhYmxlZCkge1xuICAgIHJldHVybiB0aGlzLl9zb3VyY2VfdGV4dDtcbiAgfVxuXG4gIHZhciBzb3VyY2VfdGV4dCA9IHRoaXMuX3NvdXJjZV90ZXh0O1xuICB2YXIgZW9sID0gdGhpcy5fb3B0aW9ucy5lb2w7XG4gIGlmIChlb2wgPT09ICdhdXRvJykge1xuICAgIGVvbCA9ICdcXG4nO1xuICAgIGlmIChzb3VyY2VfdGV4dCAmJiBsaW5lQnJlYWsudGVzdChzb3VyY2VfdGV4dCB8fCAnJykpIHtcbiAgICAgIGVvbCA9IHNvdXJjZV90ZXh0Lm1hdGNoKGxpbmVCcmVhaylbMF07XG4gICAgfVxuICB9XG5cblxuICAvLyBIQUNLOiBuZXdsaW5lIHBhcnNpbmcgaW5jb25zaXN0ZW50LiBUaGlzIGJydXRlIGZvcmNlIG5vcm1hbGl6ZXMgdGhlIHRoaXMuX2lucHV0LlxuICBzb3VyY2VfdGV4dCA9IHNvdXJjZV90ZXh0LnJlcGxhY2UoYWxsTGluZUJyZWFrcywgJ1xcbicpO1xuXG4gIC8vIHJlc2V0XG4gIHZhciBiYXNlSW5kZW50U3RyaW5nID0gc291cmNlX3RleHQubWF0Y2goL15bXFx0IF0qLylbMF07XG5cbiAgdGhpcy5fb3V0cHV0ID0gbmV3IE91dHB1dCh0aGlzLl9vcHRpb25zLCBiYXNlSW5kZW50U3RyaW5nKTtcbiAgdGhpcy5faW5wdXQgPSBuZXcgSW5wdXRTY2FubmVyKHNvdXJjZV90ZXh0KTtcbiAgdGhpcy5faW5kZW50TGV2ZWwgPSAwO1xuICB0aGlzLl9uZXN0ZWRMZXZlbCA9IDA7XG5cbiAgdGhpcy5fY2ggPSBudWxsO1xuICB2YXIgcGFyZW5MZXZlbCA9IDA7XG5cbiAgdmFyIGluc2lkZVJ1bGUgPSBmYWxzZTtcbiAgLy8gVGhpcyBpcyB0aGUgdmFsdWUgc2lkZSBvZiBhIHByb3BlcnR5IHZhbHVlIHBhaXIgKGJsdWUgaW4gdGhlIGZvbGxvd2luZyBleClcbiAgLy8gbGFiZWwgeyBjb250ZW50OiBibHVlIH1cbiAgdmFyIGluc2lkZVByb3BlcnR5VmFsdWUgPSBmYWxzZTtcbiAgdmFyIGVudGVyaW5nQ29uZGl0aW9uYWxHcm91cCA9IGZhbHNlO1xuICB2YXIgaW5zaWRlTm9uTmVzdGVkQXRSdWxlID0gZmFsc2U7XG4gIHZhciBpbnNpZGVTY3NzTWFwID0gZmFsc2U7XG4gIHZhciB0b3BDaGFyYWN0ZXIgPSB0aGlzLl9jaDtcbiAgdmFyIGluc2lkZU5vblNlbWlDb2xvblZhbHVlcyA9IGZhbHNlO1xuICB2YXIgd2hpdGVzcGFjZTtcbiAgdmFyIGlzQWZ0ZXJTcGFjZTtcbiAgdmFyIHByZXZpb3VzX2NoO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgd2hpdGVzcGFjZSA9IHRoaXMuX2lucHV0LnJlYWQod2hpdGVzcGFjZVBhdHRlcm4pO1xuICAgIGlzQWZ0ZXJTcGFjZSA9IHdoaXRlc3BhY2UgIT09ICcnO1xuICAgIHByZXZpb3VzX2NoID0gdG9wQ2hhcmFjdGVyO1xuICAgIHRoaXMuX2NoID0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgIGlmICh0aGlzLl9jaCA9PT0gJ1xcXFwnICYmIHRoaXMuX2lucHV0Lmhhc05leHQoKSkge1xuICAgICAgdGhpcy5fY2ggKz0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgIH1cbiAgICB0b3BDaGFyYWN0ZXIgPSB0aGlzLl9jaDtcblxuICAgIGlmICghdGhpcy5fY2gpIHtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICcvJyAmJiB0aGlzLl9pbnB1dC5wZWVrKCkgPT09ICcqJykge1xuICAgICAgLy8gLyogY3NzIGNvbW1lbnQgKi9cbiAgICAgIC8vIEFsd2F5cyBzdGFydCBibG9jayBjb21tZW50cyBvbiBhIG5ldyBsaW5lLlxuICAgICAgLy8gVGhpcyBoYW5kbGVzIHNjZW5hcmlvcyB3aGVyZSBhIGJsb2NrIGNvbW1lbnQgaW1tZWRpYXRlbHlcbiAgICAgIC8vIGZvbGxvd3MgYSBwcm9wZXJ0eSBkZWZpbml0aW9uIG9uIHRoZSBzYW1lIGxpbmUgb3Igd2hlcmVcbiAgICAgIC8vIG1pbmlmaWVkIGNvZGUgaXMgYmVpbmcgYmVhdXRpZmllZC5cbiAgICAgIHRoaXMuX291dHB1dC5hZGRfbmV3X2xpbmUoKTtcbiAgICAgIHRoaXMuX2lucHV0LmJhY2soKTtcblxuICAgICAgdmFyIGNvbW1lbnQgPSB0aGlzLl9pbnB1dC5yZWFkKGJsb2NrX2NvbW1lbnRfcGF0dGVybik7XG5cbiAgICAgIC8vIEhhbmRsZSBpZ25vcmUgZGlyZWN0aXZlXG4gICAgICB2YXIgZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXNfY29yZS5nZXRfZGlyZWN0aXZlcyhjb21tZW50KTtcbiAgICAgIGlmIChkaXJlY3RpdmVzICYmIGRpcmVjdGl2ZXMuaWdub3JlID09PSAnc3RhcnQnKSB7XG4gICAgICAgIGNvbW1lbnQgKz0gZGlyZWN0aXZlc19jb3JlLnJlYWRJZ25vcmVkKHRoaXMuX2lucHV0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcmludF9zdHJpbmcoY29tbWVudCk7XG5cbiAgICAgIC8vIEVuc3VyZXMgYW55IG5ldyBsaW5lcyBmb2xsb3dpbmcgdGhlIGNvbW1lbnQgYXJlIHByZXNlcnZlZFxuICAgICAgdGhpcy5lYXRXaGl0ZXNwYWNlKHRydWUpO1xuXG4gICAgICAvLyBCbG9jayBjb21tZW50cyBhcmUgZm9sbG93ZWQgYnkgYSBuZXcgbGluZSBzbyB0aGV5IGRvbid0XG4gICAgICAvLyBzaGFyZSBhIGxpbmUgd2l0aCBvdGhlciBwcm9wZXJ0aWVzXG4gICAgICB0aGlzLl9vdXRwdXQuYWRkX25ld19saW5lKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jaCA9PT0gJy8nICYmIHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gJy8nKSB7XG4gICAgICAvLyAvLyBzaW5nbGUgbGluZSBjb21tZW50XG4gICAgICAvLyBQcmVzZXJ2ZXMgdGhlIHNwYWNlIGJlZm9yZSBhIGNvbW1lbnRcbiAgICAgIC8vIG9uIHRoZSBzYW1lIGxpbmUgYXMgYSBydWxlXG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2lucHV0LmJhY2soKTtcbiAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2lucHV0LnJlYWQoY29tbWVudF9wYXR0ZXJuKSk7XG5cbiAgICAgIC8vIEVuc3VyZXMgYW55IG5ldyBsaW5lcyBmb2xsb3dpbmcgdGhlIGNvbW1lbnQgYXJlIHByZXNlcnZlZFxuICAgICAgdGhpcy5lYXRXaGl0ZXNwYWNlKHRydWUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICckJykge1xuICAgICAgdGhpcy5wcmVzZXJ2ZVNpbmdsZVNwYWNlKGlzQWZ0ZXJTcGFjZSk7XG5cbiAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoKTtcblxuICAgICAgLy8gc3RyaXAgdHJhaWxpbmcgc3BhY2UsIGlmIHByZXNlbnQsIGZvciBoYXNoIHByb3BlcnR5IGNoZWNrc1xuICAgICAgdmFyIHZhcmlhYmxlID0gdGhpcy5faW5wdXQucGVla1VudGlsQWZ0ZXIoL1s6ICw7e30oKVtcXF1cXC89J1wiXS9nKTtcblxuICAgICAgaWYgKHZhcmlhYmxlLm1hdGNoKC9bIDpdJC8pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSB2YXJpYWJsZSBvciBwc2V1ZG8tY2xhc3MsIGFkZCBpdCBhbmQgaW5zZXJ0IG9uZSBzcGFjZSBiZWZvcmUgY29udGludWluZ1xuICAgICAgICB2YXJpYWJsZSA9IHRoaXMuZWF0U3RyaW5nKFwiOiBcIikucmVwbGFjZSgvXFxzKyQvLCAnJyk7XG4gICAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHZhcmlhYmxlKTtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIG1pZ2h0IGJlIHNhc3MgdmFyaWFibGVcbiAgICAgIGlmIChwYXJlbkxldmVsID09PSAwICYmIHZhcmlhYmxlLmluZGV4T2YoJzonKSAhPT0gLTEpIHtcbiAgICAgICAgaW5zaWRlUHJvcGVydHlWYWx1ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuaW5kZW50KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jaCA9PT0gJ0AnKSB7XG4gICAgICB0aGlzLnByZXNlcnZlU2luZ2xlU3BhY2UoaXNBZnRlclNwYWNlKTtcblxuICAgICAgLy8gZGVhbCB3aXRoIGxlc3MgcHJvcGVydHkgbWl4aW5zIEB7Li4ufVxuICAgICAgaWYgKHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gJ3snKSB7XG4gICAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoICsgdGhpcy5lYXRTdHJpbmcoJ30nKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCk7XG5cbiAgICAgICAgLy8gc3RyaXAgdHJhaWxpbmcgc3BhY2UsIGlmIHByZXNlbnQsIGZvciBoYXNoIHByb3BlcnR5IGNoZWNrc1xuICAgICAgICB2YXIgdmFyaWFibGVPclJ1bGUgPSB0aGlzLl9pbnB1dC5wZWVrVW50aWxBZnRlcigvWzogLDt7fSgpW1xcXVxcLz0nXCJdL2cpO1xuXG4gICAgICAgIGlmICh2YXJpYWJsZU9yUnVsZS5tYXRjaCgvWyA6XSQvKSkge1xuICAgICAgICAgIC8vIHdlIGhhdmUgYSB2YXJpYWJsZSBvciBwc2V1ZG8tY2xhc3MsIGFkZCBpdCBhbmQgaW5zZXJ0IG9uZSBzcGFjZSBiZWZvcmUgY29udGludWluZ1xuICAgICAgICAgIHZhcmlhYmxlT3JSdWxlID0gdGhpcy5lYXRTdHJpbmcoXCI6IFwiKS5yZXBsYWNlKC9cXHMrJC8sICcnKTtcbiAgICAgICAgICB0aGlzLnByaW50X3N0cmluZyh2YXJpYWJsZU9yUnVsZSk7XG4gICAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtaWdodCBiZSBsZXNzIHZhcmlhYmxlXG4gICAgICAgIGlmIChwYXJlbkxldmVsID09PSAwICYmIHZhcmlhYmxlT3JSdWxlLmluZGV4T2YoJzonKSAhPT0gLTEpIHtcbiAgICAgICAgICBpbnNpZGVQcm9wZXJ0eVZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmluZGVudCgpO1xuXG4gICAgICAgICAgLy8gbWlnaHQgYmUgYSBuZXN0aW5nIGF0LXJ1bGVcbiAgICAgICAgfSBlbHNlIGlmICh2YXJpYWJsZU9yUnVsZSBpbiB0aGlzLk5FU1RFRF9BVF9SVUxFKSB7XG4gICAgICAgICAgdGhpcy5fbmVzdGVkTGV2ZWwgKz0gMTtcbiAgICAgICAgICBpZiAodmFyaWFibGVPclJ1bGUgaW4gdGhpcy5DT05ESVRJT05BTF9HUk9VUF9SVUxFKSB7XG4gICAgICAgICAgICBlbnRlcmluZ0NvbmRpdGlvbmFsR3JvdXAgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIG1pZ2h0IGJlIGEgbm9uLW5lc3RlZCBhdC1ydWxlXG4gICAgICAgIH0gZWxzZSBpZiAocGFyZW5MZXZlbCA9PT0gMCAmJiAhaW5zaWRlUHJvcGVydHlWYWx1ZSkge1xuICAgICAgICAgIGluc2lkZU5vbk5lc3RlZEF0UnVsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NoID09PSAnIycgJiYgdGhpcy5faW5wdXQucGVlaygpID09PSAneycpIHtcbiAgICAgIHRoaXMucHJlc2VydmVTaW5nbGVTcGFjZShpc0FmdGVyU3BhY2UpO1xuICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2ggKyB0aGlzLmVhdFN0cmluZygnfScpKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NoID09PSAneycpIHtcbiAgICAgIGlmIChpbnNpZGVQcm9wZXJ0eVZhbHVlKSB7XG4gICAgICAgIGluc2lkZVByb3BlcnR5VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vdXRkZW50KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIG5vbiBuZXN0ZWQgYXQgcnVsZSBiZWNvbWVzIG5lc3RlZFxuICAgICAgaW5zaWRlTm9uTmVzdGVkQXRSdWxlID0gZmFsc2U7XG5cbiAgICAgIC8vIHdoZW4gZW50ZXJpbmcgY29uZGl0aW9uYWwgZ3JvdXBzLCBvbmx5IHJ1bGVzZXRzIGFyZSBhbGxvd2VkXG4gICAgICBpZiAoZW50ZXJpbmdDb25kaXRpb25hbEdyb3VwKSB7XG4gICAgICAgIGVudGVyaW5nQ29uZGl0aW9uYWxHcm91cCA9IGZhbHNlO1xuICAgICAgICBpbnNpZGVSdWxlID0gKHRoaXMuX2luZGVudExldmVsID49IHRoaXMuX25lc3RlZExldmVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG90aGVyd2lzZSwgZGVjbGFyYXRpb25zIGFyZSBhbHNvIGFsbG93ZWRcbiAgICAgICAgaW5zaWRlUnVsZSA9ICh0aGlzLl9pbmRlbnRMZXZlbCA+PSB0aGlzLl9uZXN0ZWRMZXZlbCAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX29wdGlvbnMubmV3bGluZV9iZXR3ZWVuX3J1bGVzICYmIGluc2lkZVJ1bGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX291dHB1dC5wcmV2aW91c19saW5lICYmIHRoaXMuX291dHB1dC5wcmV2aW91c19saW5lLml0ZW0oLTEpICE9PSAneycpIHtcbiAgICAgICAgICB0aGlzLl9vdXRwdXQuZW5zdXJlX2VtcHR5X2xpbmVfYWJvdmUoJy8nLCAnLCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuXG4gICAgICAvLyBUaGUgZGlmZmVyZW5jZSBpbiBwcmludF9zdHJpbmcgYW5kIGluZGVudCBvcmRlciBpcyBuZWNlc3NhcnkgdG8gaW5kZW50IHRoZSAneycgY29ycmVjdGx5XG4gICAgICBpZiAodGhpcy5fb3B0aW9ucy5icmFjZV9zdHlsZSA9PT0gJ2V4cGFuZCcpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LmFkZF9uZXdfbGluZSgpO1xuICAgICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCk7XG4gICAgICAgIHRoaXMuaW5kZW50KCk7XG4gICAgICAgIHRoaXMuX291dHB1dC5zZXRfaW5kZW50KHRoaXMuX2luZGVudExldmVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGluc2lkZSBtaXhpbiBhbmQgZmlyc3QgcGFyYW0gaXMgb2JqZWN0XG4gICAgICAgIGlmIChwcmV2aW91c19jaCA9PT0gJygnKSB7XG4gICAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHByZXZpb3VzX2NoICE9PSAnLCcpIHtcbiAgICAgICAgICB0aGlzLmluZGVudCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lYXRXaGl0ZXNwYWNlKHRydWUpO1xuICAgICAgdGhpcy5fb3V0cHV0LmFkZF9uZXdfbGluZSgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICd9Jykge1xuICAgICAgdGhpcy5vdXRkZW50KCk7XG4gICAgICB0aGlzLl9vdXRwdXQuYWRkX25ld19saW5lKCk7XG4gICAgICBpZiAocHJldmlvdXNfY2ggPT09ICd7Jykge1xuICAgICAgICB0aGlzLl9vdXRwdXQudHJpbSh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluc2lkZVByb3BlcnR5VmFsdWUpIHtcbiAgICAgICAgdGhpcy5vdXRkZW50KCk7XG4gICAgICAgIGluc2lkZVByb3BlcnR5VmFsdWUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoKTtcbiAgICAgIGluc2lkZVJ1bGUgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLl9uZXN0ZWRMZXZlbCkge1xuICAgICAgICB0aGlzLl9uZXN0ZWRMZXZlbC0tO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVhdFdoaXRlc3BhY2UodHJ1ZSk7XG4gICAgICB0aGlzLl9vdXRwdXQuYWRkX25ld19saW5lKCk7XG5cbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLm5ld2xpbmVfYmV0d2Vlbl9ydWxlcyAmJiAhdGhpcy5fb3V0cHV0Lmp1c3RfYWRkZWRfYmxhbmtsaW5lKCkpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lucHV0LnBlZWsoKSAhPT0gJ30nKSB7XG4gICAgICAgICAgdGhpcy5fb3V0cHV0LmFkZF9uZXdfbGluZSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gJyknKSB7XG4gICAgICAgIHRoaXMuX291dHB1dC50cmltKHRydWUpO1xuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5icmFjZV9zdHlsZSA9PT0gXCJleHBhbmRcIikge1xuICAgICAgICAgIHRoaXMuX291dHB1dC5hZGRfbmV3X2xpbmUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NoID09PSBcIjpcIikge1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuTk9OX1NFTUlDT0xPTl9ORVdMSU5FX1BST1BFUlRZLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnB1dC5sb29rQmFjayh0aGlzLk5PTl9TRU1JQ09MT05fTkVXTElORV9QUk9QRVJUWVtpXSkpIHtcbiAgICAgICAgICBpbnNpZGVOb25TZW1pQ29sb25WYWx1ZXMgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgoaW5zaWRlUnVsZSB8fCBlbnRlcmluZ0NvbmRpdGlvbmFsR3JvdXApICYmICEodGhpcy5faW5wdXQubG9va0JhY2soXCImXCIpIHx8IHRoaXMuZm91bmROZXN0ZWRQc2V1ZG9DbGFzcygpKSAmJiAhdGhpcy5faW5wdXQubG9va0JhY2soXCIoXCIpICYmICFpbnNpZGVOb25OZXN0ZWRBdFJ1bGUgJiYgcGFyZW5MZXZlbCA9PT0gMCkge1xuICAgICAgICAvLyAncHJvcGVydHk6IHZhbHVlJyBkZWxpbWl0ZXJcbiAgICAgICAgLy8gd2hpY2ggY291bGQgYmUgaW4gYSBjb25kaXRpb25hbCBncm91cCBxdWVyeVxuXG4gICAgICAgIHRoaXMucHJpbnRfc3RyaW5nKCc6Jyk7XG4gICAgICAgIGlmICghaW5zaWRlUHJvcGVydHlWYWx1ZSkge1xuICAgICAgICAgIGluc2lkZVByb3BlcnR5VmFsdWUgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZWF0V2hpdGVzcGFjZSh0cnVlKTtcbiAgICAgICAgICB0aGlzLmluZGVudCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzYXNzL2xlc3MgcGFyZW50IHJlZmVyZW5jZSBkb24ndCB1c2UgYSBzcGFjZVxuICAgICAgICAvLyBzYXNzIG5lc3RlZCBwc2V1ZG8tY2xhc3MgZG9uJ3QgdXNlIGEgc3BhY2VcblxuICAgICAgICAvLyBwcmVzZXJ2ZSBzcGFjZSBiZWZvcmUgcHNldWRvY2xhc3Nlcy9wc2V1ZG9lbGVtZW50cywgYXMgaXQgbWVhbnMgXCJpbiBhbnkgY2hpbGRcIlxuICAgICAgICBpZiAodGhpcy5faW5wdXQubG9va0JhY2soXCIgXCIpKSB7XG4gICAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAvLyBwc2V1ZG8tZWxlbWVudFxuICAgICAgICAgIHRoaXMuX2NoID0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgICAgIHRoaXMucHJpbnRfc3RyaW5nKFwiOjpcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gcHNldWRvLWNsYXNzXG4gICAgICAgICAgdGhpcy5wcmludF9zdHJpbmcoJzonKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICdcIicgfHwgdGhpcy5fY2ggPT09ICdcXCcnKSB7XG4gICAgICB2YXIgcHJlc2VydmVRdW90ZVNwYWNlID0gcHJldmlvdXNfY2ggPT09ICdcIicgfHwgcHJldmlvdXNfY2ggPT09ICdcXCcnO1xuICAgICAgdGhpcy5wcmVzZXJ2ZVNpbmdsZVNwYWNlKHByZXNlcnZlUXVvdGVTcGFjZSB8fCBpc0FmdGVyU3BhY2UpO1xuICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2ggKyB0aGlzLmVhdFN0cmluZyh0aGlzLl9jaCkpO1xuICAgICAgdGhpcy5lYXRXaGl0ZXNwYWNlKHRydWUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICc7Jykge1xuICAgICAgaW5zaWRlTm9uU2VtaUNvbG9uVmFsdWVzID0gZmFsc2U7XG4gICAgICBpZiAocGFyZW5MZXZlbCA9PT0gMCkge1xuICAgICAgICBpZiAoaW5zaWRlUHJvcGVydHlWYWx1ZSkge1xuICAgICAgICAgIHRoaXMub3V0ZGVudCgpO1xuICAgICAgICAgIGluc2lkZVByb3BlcnR5VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpbnNpZGVOb25OZXN0ZWRBdFJ1bGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuICAgICAgICB0aGlzLmVhdFdoaXRlc3BhY2UodHJ1ZSk7XG5cbiAgICAgICAgLy8gVGhpcyBtYWludGFpbnMgc2luZ2xlIGxpbmUgY29tbWVudHMgb24gdGhlIHNhbWVcbiAgICAgICAgLy8gbGluZS4gQmxvY2sgY29tbWVudHMgYXJlIGFsc28gYWZmZWN0ZWQsIGJ1dFxuICAgICAgICAvLyBhIG5ldyBsaW5lIGlzIGFsd2F5cyBvdXRwdXQgYmVmb3JlIG9uZSBpbnNpZGVcbiAgICAgICAgLy8gdGhhdCBzZWN0aW9uXG4gICAgICAgIGlmICh0aGlzLl9pbnB1dC5wZWVrKCkgIT09ICcvJykge1xuICAgICAgICAgIHRoaXMuX291dHB1dC5hZGRfbmV3X2xpbmUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuICAgICAgICB0aGlzLmVhdFdoaXRlc3BhY2UodHJ1ZSk7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICcoJykgeyAvLyBtYXkgYmUgYSB1cmxcbiAgICAgIGlmICh0aGlzLl9pbnB1dC5sb29rQmFjayhcInVybFwiKSkge1xuICAgICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCk7XG4gICAgICAgIHRoaXMuZWF0V2hpdGVzcGFjZSgpO1xuICAgICAgICBwYXJlbkxldmVsKys7XG4gICAgICAgIHRoaXMuaW5kZW50KCk7XG4gICAgICAgIHRoaXMuX2NoID0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgICBpZiAodGhpcy5fY2ggPT09ICcpJyB8fCB0aGlzLl9jaCA9PT0gJ1wiJyB8fCB0aGlzLl9jaCA9PT0gJ1xcJycpIHtcbiAgICAgICAgICB0aGlzLl9pbnB1dC5iYWNrKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fY2gpIHtcbiAgICAgICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCArIHRoaXMuZWF0U3RyaW5nKCcpJykpO1xuICAgICAgICAgIGlmIChwYXJlbkxldmVsKSB7XG4gICAgICAgICAgICBwYXJlbkxldmVsLS07XG4gICAgICAgICAgICB0aGlzLm91dGRlbnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzcGFjZV9uZWVkZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX2lucHV0Lmxvb2tCYWNrKFwid2l0aFwiKSkge1xuICAgICAgICAgIC8vIGxvb2sgYmFjayBpcyBub3QgYW4gYWNjdXJhdGUgc29sdXRpb24sIHdlIG5lZWQgdG9rZW5zIHRvIGNvbmZpcm0gd2l0aG91dCB3aGl0ZXNwYWNlc1xuICAgICAgICAgIHNwYWNlX25lZWRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVzZXJ2ZVNpbmdsZVNwYWNlKGlzQWZ0ZXJTcGFjZSB8fCBzcGFjZV9uZWVkZWQpO1xuICAgICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCk7XG5cbiAgICAgICAgLy8gaGFuZGxlIHNjc3Mvc2FzcyBtYXBcbiAgICAgICAgaWYgKGluc2lkZVByb3BlcnR5VmFsdWUgJiYgcHJldmlvdXNfY2ggPT09IFwiJFwiICYmIHRoaXMuX29wdGlvbnMuc2VsZWN0b3Jfc2VwYXJhdG9yX25ld2xpbmUpIHtcbiAgICAgICAgICB0aGlzLl9vdXRwdXQuYWRkX25ld19saW5lKCk7XG4gICAgICAgICAgaW5zaWRlU2Nzc01hcCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lYXRXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgcGFyZW5MZXZlbCsrO1xuICAgICAgICAgIHRoaXMuaW5kZW50KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NoID09PSAnKScpIHtcbiAgICAgIGlmIChwYXJlbkxldmVsKSB7XG4gICAgICAgIHBhcmVuTGV2ZWwtLTtcbiAgICAgICAgdGhpcy5vdXRkZW50KCk7XG4gICAgICB9XG4gICAgICBpZiAoaW5zaWRlU2Nzc01hcCAmJiB0aGlzLl9pbnB1dC5wZWVrKCkgPT09IFwiO1wiICYmIHRoaXMuX29wdGlvbnMuc2VsZWN0b3Jfc2VwYXJhdG9yX25ld2xpbmUpIHtcbiAgICAgICAgaW5zaWRlU2Nzc01hcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm91dGRlbnQoKTtcbiAgICAgICAgdGhpcy5fb3V0cHV0LmFkZF9uZXdfbGluZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICcsJykge1xuICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuICAgICAgdGhpcy5lYXRXaGl0ZXNwYWNlKHRydWUpO1xuICAgICAgaWYgKHRoaXMuX29wdGlvbnMuc2VsZWN0b3Jfc2VwYXJhdG9yX25ld2xpbmUgJiYgKCFpbnNpZGVQcm9wZXJ0eVZhbHVlIHx8IGluc2lkZVNjc3NNYXApICYmIHBhcmVuTGV2ZWwgPT09IDAgJiYgIWluc2lkZU5vbk5lc3RlZEF0UnVsZSkge1xuICAgICAgICB0aGlzLl9vdXRwdXQuYWRkX25ld19saW5lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCh0aGlzLl9jaCA9PT0gJz4nIHx8IHRoaXMuX2NoID09PSAnKycgfHwgdGhpcy5fY2ggPT09ICd+JykgJiYgIWluc2lkZVByb3BlcnR5VmFsdWUgJiYgcGFyZW5MZXZlbCA9PT0gMCkge1xuICAgICAgLy9oYW5kbGUgY29tYmluYXRvciBzcGFjaW5nXG4gICAgICBpZiAodGhpcy5fb3B0aW9ucy5zcGFjZV9hcm91bmRfY29tYmluYXRvcikge1xuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoKTtcbiAgICAgICAgdGhpcy5lYXRXaGl0ZXNwYWNlKCk7XG4gICAgICAgIC8vIHNxdWFzaCBleHRyYSB3aGl0ZXNwYWNlXG4gICAgICAgIGlmICh0aGlzLl9jaCAmJiB3aGl0ZXNwYWNlQ2hhci50ZXN0KHRoaXMuX2NoKSkge1xuICAgICAgICAgIHRoaXMuX2NoID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NoID09PSAnXScpIHtcbiAgICAgIHRoaXMucHJpbnRfc3RyaW5nKHRoaXMuX2NoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NoID09PSAnWycpIHtcbiAgICAgIHRoaXMucHJlc2VydmVTaW5nbGVTcGFjZShpc0FmdGVyU3BhY2UpO1xuICAgICAgdGhpcy5wcmludF9zdHJpbmcodGhpcy5fY2gpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fY2ggPT09ICc9JykgeyAvLyBubyB3aGl0ZXNwYWNlIGJlZm9yZSBvciBhZnRlclxuICAgICAgdGhpcy5lYXRXaGl0ZXNwYWNlKCk7XG4gICAgICB0aGlzLnByaW50X3N0cmluZygnPScpO1xuICAgICAgaWYgKHdoaXRlc3BhY2VDaGFyLnRlc3QodGhpcy5fY2gpKSB7XG4gICAgICAgIHRoaXMuX2NoID0gJyc7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9jaCA9PT0gJyEnICYmICF0aGlzLl9pbnB1dC5sb29rQmFjayhcIlxcXFxcIikpIHsgLy8gIWltcG9ydGFudFxuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcmVzZXJ2ZUFmdGVyU3BhY2UgPSBwcmV2aW91c19jaCA9PT0gJ1wiJyB8fCBwcmV2aW91c19jaCA9PT0gJ1xcJyc7XG4gICAgICB0aGlzLnByZXNlcnZlU2luZ2xlU3BhY2UocHJlc2VydmVBZnRlclNwYWNlIHx8IGlzQWZ0ZXJTcGFjZSk7XG4gICAgICB0aGlzLnByaW50X3N0cmluZyh0aGlzLl9jaCk7XG5cbiAgICAgIGlmICghdGhpcy5fb3V0cHV0Lmp1c3RfYWRkZWRfbmV3bGluZSgpICYmIHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gJ1xcbicgJiYgaW5zaWRlTm9uU2VtaUNvbG9uVmFsdWVzKSB7XG4gICAgICAgIHRoaXMuX291dHB1dC5hZGRfbmV3X2xpbmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgc3dlZXRDb2RlID0gdGhpcy5fb3V0cHV0LmdldF9jb2RlKGVvbCk7XG5cbiAgcmV0dXJuIHN3ZWV0Q29kZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLkJlYXV0aWZpZXIgPSBCZWF1dGlmaWVyO1xuXG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciBCYXNlT3B0aW9ucyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLk9wdGlvbnMpO1xuXG5mdW5jdGlvbiBPcHRpb25zKG9wdGlvbnMpIHtcbiAgQmFzZU9wdGlvbnMuY2FsbCh0aGlzLCBvcHRpb25zLCAnY3NzJyk7XG5cbiAgdGhpcy5zZWxlY3Rvcl9zZXBhcmF0b3JfbmV3bGluZSA9IHRoaXMuX2dldF9ib29sZWFuKCdzZWxlY3Rvcl9zZXBhcmF0b3JfbmV3bGluZScsIHRydWUpO1xuICB0aGlzLm5ld2xpbmVfYmV0d2Vlbl9ydWxlcyA9IHRoaXMuX2dldF9ib29sZWFuKCduZXdsaW5lX2JldHdlZW5fcnVsZXMnLCB0cnVlKTtcbiAgdmFyIHNwYWNlX2Fyb3VuZF9zZWxlY3Rvcl9zZXBhcmF0b3IgPSB0aGlzLl9nZXRfYm9vbGVhbignc3BhY2VfYXJvdW5kX3NlbGVjdG9yX3NlcGFyYXRvcicpO1xuICB0aGlzLnNwYWNlX2Fyb3VuZF9jb21iaW5hdG9yID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ3NwYWNlX2Fyb3VuZF9jb21iaW5hdG9yJykgfHwgc3BhY2VfYXJvdW5kX3NlbGVjdG9yX3NlcGFyYXRvcjtcblxuICB2YXIgYnJhY2Vfc3R5bGVfc3BsaXQgPSB0aGlzLl9nZXRfc2VsZWN0aW9uX2xpc3QoJ2JyYWNlX3N0eWxlJywgWydjb2xsYXBzZScsICdleHBhbmQnLCAnZW5kLWV4cGFuZCcsICdub25lJywgJ3ByZXNlcnZlLWlubGluZSddKTtcbiAgdGhpcy5icmFjZV9zdHlsZSA9ICdjb2xsYXBzZSc7XG4gIGZvciAodmFyIGJzID0gMDsgYnMgPCBicmFjZV9zdHlsZV9zcGxpdC5sZW5ndGg7IGJzKyspIHtcbiAgICBpZiAoYnJhY2Vfc3R5bGVfc3BsaXRbYnNdICE9PSAnZXhwYW5kJykge1xuICAgICAgLy8gZGVmYXVsdCB0byBjb2xsYXBzZSwgYXMgb25seSBjb2xsYXBzZXxleHBhbmQgaXMgaW1wbGVtZW50ZWQgZm9yIG5vd1xuICAgICAgdGhpcy5icmFjZV9zdHlsZSA9ICdjb2xsYXBzZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYnJhY2Vfc3R5bGUgPSBicmFjZV9zdHlsZV9zcGxpdFtic107XG4gICAgfVxuICB9XG59XG5PcHRpb25zLnByb3RvdHlwZSA9IG5ldyBCYXNlT3B0aW9ucygpO1xuXG5cblxubW9kdWxlLmV4cG9ydHMuT3B0aW9ucyA9IE9wdGlvbnM7XG5cblxuLyoqKi8gfSlcbi8qKioqKiovIFx0XSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcbi8qKioqKiovIFx0XHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBzdGFydHVwXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHQvLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuLyoqKioqKi8gXHRsZWdhY3lfYmVhdXRpZnlfY3NzID0gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIFx0XG4vKioqKioqLyB9KSgpXG47XG52YXIgY3NzX2JlYXV0aWZ5ID0gbGVnYWN5X2JlYXV0aWZ5X2Nzcztcbi8qIEZvb3RlciAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQWRkIHN1cHBvcnQgZm9yIEFNRCAoIGh0dHBzOi8vZ2l0aHViLmNvbS9hbWRqcy9hbWRqcy1hcGkvd2lraS9BTUQjZGVmaW5lYW1kLXByb3BlcnR5LSApXG4gICAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNzc19iZWF1dGlmeTogY3NzX2JlYXV0aWZ5XG4gICAgICAgIH07XG4gICAgfSk7XG59IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gQWRkIHN1cHBvcnQgZm9yIENvbW1vbkpTLiBKdXN0IHB1dCB0aGlzIGZpbGUgc29tZXdoZXJlIG9uIHlvdXIgcmVxdWlyZS5wYXRoc1xuICAgIC8vIGFuZCB5b3Ugd2lsbCBiZSBhYmxlIHRvIGB2YXIgaHRtbF9iZWF1dGlmeSA9IHJlcXVpcmUoXCJiZWF1dGlmeVwiKS5odG1sX2JlYXV0aWZ5YC5cbiAgICBleHBvcnRzLmNzc19iZWF1dGlmeSA9IGNzc19iZWF1dGlmeTtcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIElmIHdlJ3JlIHJ1bm5pbmcgYSB3ZWIgcGFnZSBhbmQgZG9uJ3QgaGF2ZSBlaXRoZXIgb2YgdGhlIGFib3ZlLCBhZGQgb3VyIG9uZSBnbG9iYWxcbiAgICB3aW5kb3cuY3NzX2JlYXV0aWZ5ID0gY3NzX2JlYXV0aWZ5O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gSWYgd2UgZG9uJ3QgZXZlbiBoYXZlIHdpbmRvdywgdHJ5IGdsb2JhbC5cbiAgICBnbG9iYWwuY3NzX2JlYXV0aWZ5ID0gY3NzX2JlYXV0aWZ5O1xufVxuXG59KCkpO1xuIl0sIm5hbWVzIjpbImxlZ2FjeV9iZWF1dGlmeV9jc3MiLCJfX3dlYnBhY2tfbW9kdWxlc19fIiwibW9kdWxlIiwiT3V0cHV0TGluZSIsInBhcmVudCIsIl9fcGFyZW50IiwiX19jaGFyYWN0ZXJfY291bnQiLCJfX2luZGVudF9jb3VudCIsIl9fYWxpZ25tZW50X2NvdW50IiwiX193cmFwX3BvaW50X2luZGV4IiwiX193cmFwX3BvaW50X2NoYXJhY3Rlcl9jb3VudCIsIl9fd3JhcF9wb2ludF9pbmRlbnRfY291bnQiLCJfX3dyYXBfcG9pbnRfYWxpZ25tZW50X2NvdW50IiwiX19pdGVtcyIsInByb3RvdHlwZSIsImNsb25lX2VtcHR5IiwibGluZSIsInNldF9pbmRlbnQiLCJpdGVtIiwiaW5kZXgiLCJsZW5ndGgiLCJoYXNfbWF0Y2giLCJwYXR0ZXJuIiwibGFzdENoZWNrZWRPdXRwdXQiLCJtYXRjaCIsImluZGVudCIsImFsaWdubWVudCIsImlzX2VtcHR5IiwiZ2V0X2luZGVudF9zaXplIiwiX3NldF93cmFwX3BvaW50Iiwid3JhcF9saW5lX2xlbmd0aCIsIm5leHRfbGluZSIsIl9zaG91bGRfd3JhcCIsIl9hbGxvd193cmFwIiwiYWRkX25ld19saW5lIiwibmV4dCIsImN1cnJlbnRfbGluZSIsInNsaWNlIiwic3BsaWNlIiwibGFzdCIsInB1c2giLCJsYXN0X25ld2xpbmVfaW5kZXgiLCJsYXN0SW5kZXhPZiIsInBvcCIsIl9yZW1vdmVfaW5kZW50IiwiaW5kZW50X3NpemUiLCJfcmVtb3ZlX3dyYXBfaW5kZW50IiwidHJpbSIsInRvU3RyaW5nIiwicmVzdWx0IiwiaW5kZW50X2VtcHR5X2xpbmVzIiwiZ2V0X2luZGVudF9zdHJpbmciLCJqb2luIiwiSW5kZW50U3RyaW5nQ2FjaGUiLCJvcHRpb25zIiwiYmFzZUluZGVudFN0cmluZyIsIl9fY2FjaGUiLCJfX2luZGVudF9zaXplIiwiX19pbmRlbnRfc3RyaW5nIiwiaW5kZW50X2NoYXIiLCJpbmRlbnRfd2l0aF90YWJzIiwiQXJyYXkiLCJpbmRlbnRfbGV2ZWwiLCJfX2Jhc2Vfc3RyaW5nIiwiX19iYXNlX3N0cmluZ19sZW5ndGgiLCJjb2x1bW4iLCJfX2Vuc3VyZV9jYWNoZSIsIl9fYWRkX2NvbHVtbiIsIk1hdGgiLCJmbG9vciIsIk91dHB1dCIsIl9faW5kZW50X2NhY2hlIiwicmF3IiwiX2VuZF93aXRoX25ld2xpbmUiLCJlbmRfd2l0aF9uZXdsaW5lIiwiX19saW5lcyIsInByZXZpb3VzX2xpbmUiLCJzcGFjZV9iZWZvcmVfdG9rZW4iLCJub25fYnJlYWtpbmdfc3BhY2UiLCJwcmV2aW91c190b2tlbl93cmFwcGVkIiwiX19hZGRfb3V0cHV0bGluZSIsImdldF9saW5lX251bWJlciIsImZvcmNlX25ld2xpbmUiLCJqdXN0X2FkZGVkX25ld2xpbmUiLCJnZXRfY29kZSIsImVvbCIsImxhc3RfaXRlbSIsInJlcGxhY2UiLCJzd2VldF9jb2RlIiwic2V0X3dyYXBfcG9pbnQiLCJhZGRfcmF3X3Rva2VuIiwidG9rZW4iLCJ4IiwibmV3bGluZXMiLCJ3aGl0ZXNwYWNlX2JlZm9yZSIsInRleHQiLCJhZGRfdG9rZW4iLCJwcmludGFibGVfdG9rZW4iLCJfX2FkZF9zcGFjZV9iZWZvcmVfdG9rZW4iLCJyZW1vdmVfaW5kZW50Iiwib3V0cHV0X2xlbmd0aCIsImVhdF9uZXdsaW5lcyIsInVuZGVmaW5lZCIsImp1c3RfYWRkZWRfYmxhbmtsaW5lIiwiZW5zdXJlX2VtcHR5X2xpbmVfYWJvdmUiLCJzdGFydHNfd2l0aCIsImVuZHNfd2l0aCIsInBvdGVudGlhbEVtcHR5TGluZSIsImluZGV4T2YiLCJleHBvcnRzIiwiT3B0aW9ucyIsIm1lcmdlX2NoaWxkX2ZpZWxkIiwicmF3X29wdGlvbnMiLCJfbWVyZ2VPcHRzIiwiZGlzYWJsZWQiLCJfZ2V0X2Jvb2xlYW4iLCJfZ2V0X2NoYXJhY3RlcnMiLCJfZ2V0X251bWJlciIsInByZXNlcnZlX25ld2xpbmVzIiwibWF4X3ByZXNlcnZlX25ld2xpbmVzIiwidGVtcGxhdGluZyIsIl9nZXRfc2VsZWN0aW9uX2xpc3QiLCJfZ2V0X2FycmF5IiwibmFtZSIsImRlZmF1bHRfdmFsdWUiLCJvcHRpb25fdmFsdWUiLCJjb25jYXQiLCJzcGxpdCIsInBhcnNlSW50IiwiaXNOYU4iLCJfZ2V0X3NlbGVjdGlvbiIsInNlbGVjdGlvbl9saXN0IiwiRXJyb3IiLCJfaXNfdmFsaWRfc2VsZWN0aW9uIiwic29tZSIsImFsbE9wdGlvbnMiLCJjaGlsZEZpZWxkTmFtZSIsImZpbmFsT3B0cyIsIl9ub3JtYWxpemVPcHRzIiwiY29udmVydGVkT3B0cyIsImtleSIsIm5ld0tleSIsIm5vcm1hbGl6ZU9wdHMiLCJtZXJnZU9wdHMiLCJyZWdleHBfaGFzX3N0aWNreSIsIlJlZ0V4cCIsImhhc093blByb3BlcnR5IiwiSW5wdXRTY2FubmVyIiwiaW5wdXRfc3RyaW5nIiwiX19pbnB1dCIsIl9faW5wdXRfbGVuZ3RoIiwiX19wb3NpdGlvbiIsInJlc3RhcnQiLCJiYWNrIiwiaGFzTmV4dCIsInZhbCIsImNoYXJBdCIsInBlZWsiLCJfX21hdGNoIiwibGFzdEluZGV4IiwicGF0dGVybl9tYXRjaCIsImV4ZWMiLCJzdGlja3kiLCJ0ZXN0IiwidGVzdENoYXIiLCJyZWFkIiwic3RhcnRpbmdfcGF0dGVybiIsInVudGlsX3BhdHRlcm4iLCJ1bnRpbF9hZnRlciIsInJlYWRVbnRpbCIsIm1hdGNoX2luZGV4Iiwic3Vic3RyaW5nIiwicmVhZFVudGlsQWZ0ZXIiLCJnZXRfcmVnZXhwIiwibWF0Y2hfZnJvbSIsImZsYWdzIiwic291cmNlIiwiZ2V0X2xpdGVyYWxfcmVnZXhwIiwibGl0ZXJhbF9zdHJpbmciLCJwZWVrVW50aWxBZnRlciIsInN0YXJ0IiwibG9va0JhY2siLCJ0ZXN0VmFsIiwidG9Mb3dlckNhc2UiLCJEaXJlY3RpdmVzIiwic3RhcnRfYmxvY2tfcGF0dGVybiIsImVuZF9ibG9ja19wYXR0ZXJuIiwiX19kaXJlY3RpdmVzX2Jsb2NrX3BhdHRlcm4iLCJfX2RpcmVjdGl2ZV9wYXR0ZXJuIiwiX19kaXJlY3RpdmVzX2VuZF9pZ25vcmVfcGF0dGVybiIsImdldF9kaXJlY3RpdmVzIiwiZGlyZWN0aXZlcyIsImRpcmVjdGl2ZV9tYXRjaCIsInJlYWRJZ25vcmVkIiwiaW5wdXQiLCJfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwiQmVhdXRpZmllciIsImNzc19iZWF1dGlmeSIsInNvdXJjZV90ZXh0IiwiYmVhdXRpZmllciIsImJlYXV0aWZ5IiwiZGVmYXVsdE9wdGlvbnMiLCJkaXJlY3RpdmVzX2NvcmUiLCJsaW5lQnJlYWsiLCJhbGxMaW5lQnJlYWtzIiwid2hpdGVzcGFjZUNoYXIiLCJ3aGl0ZXNwYWNlUGF0dGVybiIsImJsb2NrX2NvbW1lbnRfcGF0dGVybiIsImNvbW1lbnRfcGF0dGVybiIsIl9zb3VyY2VfdGV4dCIsIl9vcHRpb25zIiwiX2NoIiwiX2lucHV0IiwiTkVTVEVEX0FUX1JVTEUiLCJDT05ESVRJT05BTF9HUk9VUF9SVUxFIiwiTk9OX1NFTUlDT0xPTl9ORVdMSU5FX1BST1BFUlRZIiwiZWF0U3RyaW5nIiwiZW5kQ2hhcnMiLCJlYXRXaGl0ZXNwYWNlIiwiYWxsb3dBdExlYXN0T25lTmV3TGluZSIsIm5ld2xpbmVfY291bnQiLCJfb3V0cHV0IiwiZm91bmROZXN0ZWRQc2V1ZG9DbGFzcyIsIm9wZW5QYXJlbiIsImkiLCJjaCIsInByaW50X3N0cmluZyIsIm91dHB1dF9zdHJpbmciLCJfaW5kZW50TGV2ZWwiLCJwcmVzZXJ2ZVNpbmdsZVNwYWNlIiwiaXNBZnRlclNwYWNlIiwib3V0ZGVudCIsIl9uZXN0ZWRMZXZlbCIsInBhcmVuTGV2ZWwiLCJpbnNpZGVSdWxlIiwiaW5zaWRlUHJvcGVydHlWYWx1ZSIsImVudGVyaW5nQ29uZGl0aW9uYWxHcm91cCIsImluc2lkZU5vbk5lc3RlZEF0UnVsZSIsImluc2lkZVNjc3NNYXAiLCJ0b3BDaGFyYWN0ZXIiLCJpbnNpZGVOb25TZW1pQ29sb25WYWx1ZXMiLCJ3aGl0ZXNwYWNlIiwicHJldmlvdXNfY2giLCJjb21tZW50IiwiaWdub3JlIiwidmFyaWFibGUiLCJ2YXJpYWJsZU9yUnVsZSIsIm5ld2xpbmVfYmV0d2Vlbl9ydWxlcyIsImJyYWNlX3N0eWxlIiwicHJlc2VydmVRdW90ZVNwYWNlIiwic3BhY2VfbmVlZGVkIiwic2VsZWN0b3Jfc2VwYXJhdG9yX25ld2xpbmUiLCJzcGFjZV9hcm91bmRfY29tYmluYXRvciIsInByZXNlcnZlQWZ0ZXJTcGFjZSIsInN3ZWV0Q29kZSIsIkJhc2VPcHRpb25zIiwiY2FsbCIsInNwYWNlX2Fyb3VuZF9zZWxlY3Rvcl9zZXBhcmF0b3IiLCJicmFjZV9zdHlsZV9zcGxpdCIsImJzIiwiX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fIiwibW9kdWxlSWQiLCJjYWNoZWRNb2R1bGUiLCJfX3dlYnBhY2tfZXhwb3J0c19fIiwiZGVmaW5lIiwiYW1kIiwid2luZG93IiwiZ2xvYmFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/js-beautify/js/lib/beautify-css.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/js-beautify/js/lib/beautify-html.js":
/*!**********************************************************!*\
  !*** ./node_modules/js-beautify/js/lib/beautify-html.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* AUTO-GENERATED. DO NOT MODIFY. */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n\n Style HTML\n---------------\n\n  Written by Nochum Sossonko, (nsossonko@hotmail.com)\n\n  Based on code initially developed by: Einar Lielmanis, <einar@beautifier.io>\n    https://beautifier.io/\n\n  Usage:\n    style_html(html_source);\n\n    style_html(html_source, options);\n\n  The options are:\n    indent_inner_html (default false)  — indent <head> and <body> sections,\n    indent_size (default 4)          — indentation size,\n    indent_char (default space)      — character to indent with,\n    wrap_line_length (default 250)            -  maximum amount of characters per line (0 = disable)\n    brace_style (default \"collapse\") - \"collapse\" | \"expand\" | \"end-expand\" | \"none\"\n            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.\n    inline (defaults to inline tags) - list of tags to be considered inline tags\n    unformatted (defaults to inline tags) - list of tags, that shouldn't be reformatted\n    content_unformatted (defaults to [\"pre\", \"textarea\"] tags) - list of tags, whose content shouldn't be reformatted\n    indent_scripts (default normal)  - \"keep\"|\"separate\"|\"normal\"\n    preserve_newlines (default true) - whether existing line breaks before elements should be preserved\n                                        Only works before elements, not inside tags or for text.\n    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk\n    indent_handlebars (default false) - format and indent {{#foo}} and {{/foo}}\n    end_with_newline (false)          - end with a newline\n    extra_liners (default [head,body,/html]) -List of tags that should have an extra newline before them.\n\n    e.g.\n\n    style_html(html_source, {\n      'indent_inner_html': false,\n      'indent_size': 2,\n      'indent_char': ' ',\n      'wrap_line_length': 78,\n      'brace_style': 'expand',\n      'preserve_newlines': true,\n      'max_preserve_newlines': 5,\n      'indent_handlebars': false,\n      'extra_liners': ['/html']\n    });\n*/ (function() {\n    /* GENERATED_BUILD_OUTPUT */ var legacy_beautify_html;\n    /******/ (function() {\n        /******/ \"use strict\";\n        /******/ var __webpack_modules__ = [\n            ,\n            ,\n            /* 2 */ /***/ function(module) {\n                /*jshint node:true */ /*\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function OutputLine(parent) {\n                    this.__parent = parent;\n                    this.__character_count = 0;\n                    // use indent_count as a marker for this.__lines that have preserved indentation\n                    this.__indent_count = -1;\n                    this.__alignment_count = 0;\n                    this.__wrap_point_index = 0;\n                    this.__wrap_point_character_count = 0;\n                    this.__wrap_point_indent_count = -1;\n                    this.__wrap_point_alignment_count = 0;\n                    this.__items = [];\n                }\n                OutputLine.prototype.clone_empty = function() {\n                    var line = new OutputLine(this.__parent);\n                    line.set_indent(this.__indent_count, this.__alignment_count);\n                    return line;\n                };\n                OutputLine.prototype.item = function(index) {\n                    if (index < 0) {\n                        return this.__items[this.__items.length + index];\n                    } else {\n                        return this.__items[index];\n                    }\n                };\n                OutputLine.prototype.has_match = function(pattern) {\n                    for(var lastCheckedOutput = this.__items.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--){\n                        if (this.__items[lastCheckedOutput].match(pattern)) {\n                            return true;\n                        }\n                    }\n                    return false;\n                };\n                OutputLine.prototype.set_indent = function(indent, alignment) {\n                    if (this.is_empty()) {\n                        this.__indent_count = indent || 0;\n                        this.__alignment_count = alignment || 0;\n                        this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);\n                    }\n                };\n                OutputLine.prototype._set_wrap_point = function() {\n                    if (this.__parent.wrap_line_length) {\n                        this.__wrap_point_index = this.__items.length;\n                        this.__wrap_point_character_count = this.__character_count;\n                        this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;\n                        this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;\n                    }\n                };\n                OutputLine.prototype._should_wrap = function() {\n                    return this.__wrap_point_index && this.__character_count > this.__parent.wrap_line_length && this.__wrap_point_character_count > this.__parent.next_line.__character_count;\n                };\n                OutputLine.prototype._allow_wrap = function() {\n                    if (this._should_wrap()) {\n                        this.__parent.add_new_line();\n                        var next = this.__parent.current_line;\n                        next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);\n                        next.__items = this.__items.slice(this.__wrap_point_index);\n                        this.__items = this.__items.slice(0, this.__wrap_point_index);\n                        next.__character_count += this.__character_count - this.__wrap_point_character_count;\n                        this.__character_count = this.__wrap_point_character_count;\n                        if (next.__items[0] === \" \") {\n                            next.__items.splice(0, 1);\n                            next.__character_count -= 1;\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n                OutputLine.prototype.is_empty = function() {\n                    return this.__items.length === 0;\n                };\n                OutputLine.prototype.last = function() {\n                    if (!this.is_empty()) {\n                        return this.__items[this.__items.length - 1];\n                    } else {\n                        return null;\n                    }\n                };\n                OutputLine.prototype.push = function(item) {\n                    this.__items.push(item);\n                    var last_newline_index = item.lastIndexOf(\"\\n\");\n                    if (last_newline_index !== -1) {\n                        this.__character_count = item.length - last_newline_index;\n                    } else {\n                        this.__character_count += item.length;\n                    }\n                };\n                OutputLine.prototype.pop = function() {\n                    var item = null;\n                    if (!this.is_empty()) {\n                        item = this.__items.pop();\n                        this.__character_count -= item.length;\n                    }\n                    return item;\n                };\n                OutputLine.prototype._remove_indent = function() {\n                    if (this.__indent_count > 0) {\n                        this.__indent_count -= 1;\n                        this.__character_count -= this.__parent.indent_size;\n                    }\n                };\n                OutputLine.prototype._remove_wrap_indent = function() {\n                    if (this.__wrap_point_indent_count > 0) {\n                        this.__wrap_point_indent_count -= 1;\n                    }\n                };\n                OutputLine.prototype.trim = function() {\n                    while(this.last() === \" \"){\n                        this.__items.pop();\n                        this.__character_count -= 1;\n                    }\n                };\n                OutputLine.prototype.toString = function() {\n                    var result = \"\";\n                    if (this.is_empty()) {\n                        if (this.__parent.indent_empty_lines) {\n                            result = this.__parent.get_indent_string(this.__indent_count);\n                        }\n                    } else {\n                        result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);\n                        result += this.__items.join(\"\");\n                    }\n                    return result;\n                };\n                function IndentStringCache(options, baseIndentString) {\n                    this.__cache = [\n                        \"\"\n                    ];\n                    this.__indent_size = options.indent_size;\n                    this.__indent_string = options.indent_char;\n                    if (!options.indent_with_tabs) {\n                        this.__indent_string = new Array(options.indent_size + 1).join(options.indent_char);\n                    }\n                    // Set to null to continue support for auto detection of base indent\n                    baseIndentString = baseIndentString || \"\";\n                    if (options.indent_level > 0) {\n                        baseIndentString = new Array(options.indent_level + 1).join(this.__indent_string);\n                    }\n                    this.__base_string = baseIndentString;\n                    this.__base_string_length = baseIndentString.length;\n                }\n                IndentStringCache.prototype.get_indent_size = function(indent, column) {\n                    var result = this.__base_string_length;\n                    column = column || 0;\n                    if (indent < 0) {\n                        result = 0;\n                    }\n                    result += indent * this.__indent_size;\n                    result += column;\n                    return result;\n                };\n                IndentStringCache.prototype.get_indent_string = function(indent_level, column) {\n                    var result = this.__base_string;\n                    column = column || 0;\n                    if (indent_level < 0) {\n                        indent_level = 0;\n                        result = \"\";\n                    }\n                    column += indent_level * this.__indent_size;\n                    this.__ensure_cache(column);\n                    result += this.__cache[column];\n                    return result;\n                };\n                IndentStringCache.prototype.__ensure_cache = function(column) {\n                    while(column >= this.__cache.length){\n                        this.__add_column();\n                    }\n                };\n                IndentStringCache.prototype.__add_column = function() {\n                    var column = this.__cache.length;\n                    var indent = 0;\n                    var result = \"\";\n                    if (this.__indent_size && column >= this.__indent_size) {\n                        indent = Math.floor(column / this.__indent_size);\n                        column -= indent * this.__indent_size;\n                        result = new Array(indent + 1).join(this.__indent_string);\n                    }\n                    if (column) {\n                        result += new Array(column + 1).join(\" \");\n                    }\n                    this.__cache.push(result);\n                };\n                function Output(options, baseIndentString) {\n                    this.__indent_cache = new IndentStringCache(options, baseIndentString);\n                    this.raw = false;\n                    this._end_with_newline = options.end_with_newline;\n                    this.indent_size = options.indent_size;\n                    this.wrap_line_length = options.wrap_line_length;\n                    this.indent_empty_lines = options.indent_empty_lines;\n                    this.__lines = [];\n                    this.previous_line = null;\n                    this.current_line = null;\n                    this.next_line = new OutputLine(this);\n                    this.space_before_token = false;\n                    this.non_breaking_space = false;\n                    this.previous_token_wrapped = false;\n                    // initialize\n                    this.__add_outputline();\n                }\n                Output.prototype.__add_outputline = function() {\n                    this.previous_line = this.current_line;\n                    this.current_line = this.next_line.clone_empty();\n                    this.__lines.push(this.current_line);\n                };\n                Output.prototype.get_line_number = function() {\n                    return this.__lines.length;\n                };\n                Output.prototype.get_indent_string = function(indent, column) {\n                    return this.__indent_cache.get_indent_string(indent, column);\n                };\n                Output.prototype.get_indent_size = function(indent, column) {\n                    return this.__indent_cache.get_indent_size(indent, column);\n                };\n                Output.prototype.is_empty = function() {\n                    return !this.previous_line && this.current_line.is_empty();\n                };\n                Output.prototype.add_new_line = function(force_newline) {\n                    // never newline at the start of file\n                    // otherwise, newline only if we didn't just add one or we're forced\n                    if (this.is_empty() || !force_newline && this.just_added_newline()) {\n                        return false;\n                    }\n                    // if raw output is enabled, don't print additional newlines,\n                    // but still return True as though you had\n                    if (!this.raw) {\n                        this.__add_outputline();\n                    }\n                    return true;\n                };\n                Output.prototype.get_code = function(eol) {\n                    this.trim(true);\n                    // handle some edge cases where the last tokens\n                    // has text that ends with newline(s)\n                    var last_item = this.current_line.pop();\n                    if (last_item) {\n                        if (last_item[last_item.length - 1] === \"\\n\") {\n                            last_item = last_item.replace(/\\n+$/g, \"\");\n                        }\n                        this.current_line.push(last_item);\n                    }\n                    if (this._end_with_newline) {\n                        this.__add_outputline();\n                    }\n                    var sweet_code = this.__lines.join(\"\\n\");\n                    if (eol !== \"\\n\") {\n                        sweet_code = sweet_code.replace(/[\\n]/g, eol);\n                    }\n                    return sweet_code;\n                };\n                Output.prototype.set_wrap_point = function() {\n                    this.current_line._set_wrap_point();\n                };\n                Output.prototype.set_indent = function(indent, alignment) {\n                    indent = indent || 0;\n                    alignment = alignment || 0;\n                    // Next line stores alignment values\n                    this.next_line.set_indent(indent, alignment);\n                    // Never indent your first output indent at the start of the file\n                    if (this.__lines.length > 1) {\n                        this.current_line.set_indent(indent, alignment);\n                        return true;\n                    }\n                    this.current_line.set_indent();\n                    return false;\n                };\n                Output.prototype.add_raw_token = function(token) {\n                    for(var x = 0; x < token.newlines; x++){\n                        this.__add_outputline();\n                    }\n                    this.current_line.set_indent(-1);\n                    this.current_line.push(token.whitespace_before);\n                    this.current_line.push(token.text);\n                    this.space_before_token = false;\n                    this.non_breaking_space = false;\n                    this.previous_token_wrapped = false;\n                };\n                Output.prototype.add_token = function(printable_token) {\n                    this.__add_space_before_token();\n                    this.current_line.push(printable_token);\n                    this.space_before_token = false;\n                    this.non_breaking_space = false;\n                    this.previous_token_wrapped = this.current_line._allow_wrap();\n                };\n                Output.prototype.__add_space_before_token = function() {\n                    if (this.space_before_token && !this.just_added_newline()) {\n                        if (!this.non_breaking_space) {\n                            this.set_wrap_point();\n                        }\n                        this.current_line.push(\" \");\n                    }\n                };\n                Output.prototype.remove_indent = function(index) {\n                    var output_length = this.__lines.length;\n                    while(index < output_length){\n                        this.__lines[index]._remove_indent();\n                        index++;\n                    }\n                    this.current_line._remove_wrap_indent();\n                };\n                Output.prototype.trim = function(eat_newlines) {\n                    eat_newlines = eat_newlines === undefined ? false : eat_newlines;\n                    this.current_line.trim();\n                    while(eat_newlines && this.__lines.length > 1 && this.current_line.is_empty()){\n                        this.__lines.pop();\n                        this.current_line = this.__lines[this.__lines.length - 1];\n                        this.current_line.trim();\n                    }\n                    this.previous_line = this.__lines.length > 1 ? this.__lines[this.__lines.length - 2] : null;\n                };\n                Output.prototype.just_added_newline = function() {\n                    return this.current_line.is_empty();\n                };\n                Output.prototype.just_added_blankline = function() {\n                    return this.is_empty() || this.current_line.is_empty() && this.previous_line.is_empty();\n                };\n                Output.prototype.ensure_empty_line_above = function(starts_with, ends_with) {\n                    var index = this.__lines.length - 2;\n                    while(index >= 0){\n                        var potentialEmptyLine = this.__lines[index];\n                        if (potentialEmptyLine.is_empty()) {\n                            break;\n                        } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 && potentialEmptyLine.item(-1) !== ends_with) {\n                            this.__lines.splice(index + 1, 0, new OutputLine(this));\n                            this.previous_line = this.__lines[this.__lines.length - 2];\n                            break;\n                        }\n                        index--;\n                    }\n                };\n                module.exports.Output = Output;\n            /***/ },\n            /* 3 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function Token(type, text, newlines, whitespace_before) {\n                    this.type = type;\n                    this.text = text;\n                    // comments_before are\n                    // comments that have a new line before them\n                    // and may or may not have a newline after\n                    // this is a set of comments before\n                    this.comments_before = null; /* inline comment*/ \n                    // this.comments_after =  new TokenStream(); // no new line before and newline after\n                    this.newlines = newlines || 0;\n                    this.whitespace_before = whitespace_before || \"\";\n                    this.parent = null;\n                    this.next = null;\n                    this.previous = null;\n                    this.opened = null;\n                    this.closed = null;\n                    this.directives = null;\n                }\n                module.exports.Token = Token;\n            /***/ },\n            ,\n            ,\n            /* 6 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function Options(options, merge_child_field) {\n                    this.raw_options = _mergeOpts(options, merge_child_field);\n                    // Support passing the source text back with no change\n                    this.disabled = this._get_boolean(\"disabled\");\n                    this.eol = this._get_characters(\"eol\", \"auto\");\n                    this.end_with_newline = this._get_boolean(\"end_with_newline\");\n                    this.indent_size = this._get_number(\"indent_size\", 4);\n                    this.indent_char = this._get_characters(\"indent_char\", \" \");\n                    this.indent_level = this._get_number(\"indent_level\");\n                    this.preserve_newlines = this._get_boolean(\"preserve_newlines\", true);\n                    this.max_preserve_newlines = this._get_number(\"max_preserve_newlines\", 32786);\n                    if (!this.preserve_newlines) {\n                        this.max_preserve_newlines = 0;\n                    }\n                    this.indent_with_tabs = this._get_boolean(\"indent_with_tabs\", this.indent_char === \"\t\");\n                    if (this.indent_with_tabs) {\n                        this.indent_char = \"\t\";\n                        // indent_size behavior changed after 1.8.6\n                        // It used to be that indent_size would be\n                        // set to 1 for indent_with_tabs. That is no longer needed and\n                        // actually doesn't make sense - why not use spaces? Further,\n                        // that might produce unexpected behavior - tabs being used\n                        // for single-column alignment. So, when indent_with_tabs is true\n                        // and indent_size is 1, reset indent_size to 4.\n                        if (this.indent_size === 1) {\n                            this.indent_size = 4;\n                        }\n                    }\n                    // Backwards compat with 1.3.x\n                    this.wrap_line_length = this._get_number(\"wrap_line_length\", this._get_number(\"max_char\"));\n                    this.indent_empty_lines = this._get_boolean(\"indent_empty_lines\");\n                    // valid templating languages ['django', 'erb', 'handlebars', 'php', 'smarty']\n                    // For now, 'auto' = all off for javascript, all on for html (and inline javascript).\n                    // other values ignored\n                    this.templating = this._get_selection_list(\"templating\", [\n                        \"auto\",\n                        \"none\",\n                        \"django\",\n                        \"erb\",\n                        \"handlebars\",\n                        \"php\",\n                        \"smarty\"\n                    ], [\n                        \"auto\"\n                    ]);\n                }\n                Options.prototype._get_array = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    var result = default_value || [];\n                    if (typeof option_value === \"object\") {\n                        if (option_value !== null && typeof option_value.concat === \"function\") {\n                            result = option_value.concat();\n                        }\n                    } else if (typeof option_value === \"string\") {\n                        result = option_value.split(/[^a-zA-Z0-9_\\/\\-]+/);\n                    }\n                    return result;\n                };\n                Options.prototype._get_boolean = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    var result = option_value === undefined ? !!default_value : !!option_value;\n                    return result;\n                };\n                Options.prototype._get_characters = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    var result = default_value || \"\";\n                    if (typeof option_value === \"string\") {\n                        result = option_value.replace(/\\\\r/, \"\\r\").replace(/\\\\n/, \"\\n\").replace(/\\\\t/, \"\t\");\n                    }\n                    return result;\n                };\n                Options.prototype._get_number = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    default_value = parseInt(default_value, 10);\n                    if (isNaN(default_value)) {\n                        default_value = 0;\n                    }\n                    var result = parseInt(option_value, 10);\n                    if (isNaN(result)) {\n                        result = default_value;\n                    }\n                    return result;\n                };\n                Options.prototype._get_selection = function(name, selection_list, default_value) {\n                    var result = this._get_selection_list(name, selection_list, default_value);\n                    if (result.length !== 1) {\n                        throw new Error(\"Invalid Option Value: The option '\" + name + \"' can only be one of the following values:\\n\" + selection_list + \"\\nYou passed in: '\" + this.raw_options[name] + \"'\");\n                    }\n                    return result[0];\n                };\n                Options.prototype._get_selection_list = function(name, selection_list, default_value) {\n                    if (!selection_list || selection_list.length === 0) {\n                        throw new Error(\"Selection list cannot be empty.\");\n                    }\n                    default_value = default_value || [\n                        selection_list[0]\n                    ];\n                    if (!this._is_valid_selection(default_value, selection_list)) {\n                        throw new Error(\"Invalid Default Value!\");\n                    }\n                    var result = this._get_array(name, default_value);\n                    if (!this._is_valid_selection(result, selection_list)) {\n                        throw new Error(\"Invalid Option Value: The option '\" + name + \"' can contain only the following values:\\n\" + selection_list + \"\\nYou passed in: '\" + this.raw_options[name] + \"'\");\n                    }\n                    return result;\n                };\n                Options.prototype._is_valid_selection = function(result, selection_list) {\n                    return result.length && selection_list.length && !result.some(function(item) {\n                        return selection_list.indexOf(item) === -1;\n                    });\n                };\n                // merges child options up with the parent options object\n                // Example: obj = {a: 1, b: {a: 2}}\n                //          mergeOpts(obj, 'b')\n                //\n                //          Returns: {a: 2}\n                function _mergeOpts(allOptions, childFieldName) {\n                    var finalOpts = {};\n                    allOptions = _normalizeOpts(allOptions);\n                    var name;\n                    for(name in allOptions){\n                        if (name !== childFieldName) {\n                            finalOpts[name] = allOptions[name];\n                        }\n                    }\n                    //merge in the per type settings for the childFieldName\n                    if (childFieldName && allOptions[childFieldName]) {\n                        for(name in allOptions[childFieldName]){\n                            finalOpts[name] = allOptions[childFieldName][name];\n                        }\n                    }\n                    return finalOpts;\n                }\n                function _normalizeOpts(options) {\n                    var convertedOpts = {};\n                    var key;\n                    for(key in options){\n                        var newKey = key.replace(/-/g, \"_\");\n                        convertedOpts[newKey] = options[key];\n                    }\n                    return convertedOpts;\n                }\n                module.exports.Options = Options;\n                module.exports.normalizeOpts = _normalizeOpts;\n                module.exports.mergeOpts = _mergeOpts;\n            /***/ },\n            ,\n            /* 8 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var regexp_has_sticky = RegExp.prototype.hasOwnProperty(\"sticky\");\n                function InputScanner(input_string) {\n                    this.__input = input_string || \"\";\n                    this.__input_length = this.__input.length;\n                    this.__position = 0;\n                }\n                InputScanner.prototype.restart = function() {\n                    this.__position = 0;\n                };\n                InputScanner.prototype.back = function() {\n                    if (this.__position > 0) {\n                        this.__position -= 1;\n                    }\n                };\n                InputScanner.prototype.hasNext = function() {\n                    return this.__position < this.__input_length;\n                };\n                InputScanner.prototype.next = function() {\n                    var val = null;\n                    if (this.hasNext()) {\n                        val = this.__input.charAt(this.__position);\n                        this.__position += 1;\n                    }\n                    return val;\n                };\n                InputScanner.prototype.peek = function(index) {\n                    var val = null;\n                    index = index || 0;\n                    index += this.__position;\n                    if (index >= 0 && index < this.__input_length) {\n                        val = this.__input.charAt(index);\n                    }\n                    return val;\n                };\n                // This is a JavaScript only helper function (not in python)\n                // Javascript doesn't have a match method\n                // and not all implementation support \"sticky\" flag.\n                // If they do not support sticky then both this.match() and this.test() method\n                // must get the match and check the index of the match.\n                // If sticky is supported and set, this method will use it.\n                // Otherwise it will check that global is set, and fall back to the slower method.\n                InputScanner.prototype.__match = function(pattern, index) {\n                    pattern.lastIndex = index;\n                    var pattern_match = pattern.exec(this.__input);\n                    if (pattern_match && !(regexp_has_sticky && pattern.sticky)) {\n                        if (pattern_match.index !== index) {\n                            pattern_match = null;\n                        }\n                    }\n                    return pattern_match;\n                };\n                InputScanner.prototype.test = function(pattern, index) {\n                    index = index || 0;\n                    index += this.__position;\n                    if (index >= 0 && index < this.__input_length) {\n                        return !!this.__match(pattern, index);\n                    } else {\n                        return false;\n                    }\n                };\n                InputScanner.prototype.testChar = function(pattern, index) {\n                    // test one character regex match\n                    var val = this.peek(index);\n                    pattern.lastIndex = 0;\n                    return val !== null && pattern.test(val);\n                };\n                InputScanner.prototype.match = function(pattern) {\n                    var pattern_match = this.__match(pattern, this.__position);\n                    if (pattern_match) {\n                        this.__position += pattern_match[0].length;\n                    } else {\n                        pattern_match = null;\n                    }\n                    return pattern_match;\n                };\n                InputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {\n                    var val = \"\";\n                    var match;\n                    if (starting_pattern) {\n                        match = this.match(starting_pattern);\n                        if (match) {\n                            val += match[0];\n                        }\n                    }\n                    if (until_pattern && (match || !starting_pattern)) {\n                        val += this.readUntil(until_pattern, until_after);\n                    }\n                    return val;\n                };\n                InputScanner.prototype.readUntil = function(pattern, until_after) {\n                    var val = \"\";\n                    var match_index = this.__position;\n                    pattern.lastIndex = this.__position;\n                    var pattern_match = pattern.exec(this.__input);\n                    if (pattern_match) {\n                        match_index = pattern_match.index;\n                        if (until_after) {\n                            match_index += pattern_match[0].length;\n                        }\n                    } else {\n                        match_index = this.__input_length;\n                    }\n                    val = this.__input.substring(this.__position, match_index);\n                    this.__position = match_index;\n                    return val;\n                };\n                InputScanner.prototype.readUntilAfter = function(pattern) {\n                    return this.readUntil(pattern, true);\n                };\n                InputScanner.prototype.get_regexp = function(pattern, match_from) {\n                    var result = null;\n                    var flags = \"g\";\n                    if (match_from && regexp_has_sticky) {\n                        flags = \"y\";\n                    }\n                    // strings are converted to regexp\n                    if (typeof pattern === \"string\" && pattern !== \"\") {\n                        // result = new RegExp(pattern.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'), flags);\n                        result = new RegExp(pattern, flags);\n                    } else if (pattern) {\n                        result = new RegExp(pattern.source, flags);\n                    }\n                    return result;\n                };\n                InputScanner.prototype.get_literal_regexp = function(literal_string) {\n                    return RegExp(literal_string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\"));\n                };\n                /* css beautifier legacy helpers */ InputScanner.prototype.peekUntilAfter = function(pattern) {\n                    var start = this.__position;\n                    var val = this.readUntilAfter(pattern);\n                    this.__position = start;\n                    return val;\n                };\n                InputScanner.prototype.lookBack = function(testVal) {\n                    var start = this.__position - 1;\n                    return start >= testVal.length && this.__input.substring(start - testVal.length, start).toLowerCase() === testVal;\n                };\n                module.exports.InputScanner = InputScanner;\n            /***/ },\n            /* 9 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_41623__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var InputScanner = __nested_webpack_require_41623__(8).InputScanner;\n                var Token = __nested_webpack_require_41623__(3).Token;\n                var TokenStream = __nested_webpack_require_41623__(10).TokenStream;\n                var WhitespacePattern = __nested_webpack_require_41623__(11).WhitespacePattern;\n                var TOKEN = {\n                    START: \"TK_START\",\n                    RAW: \"TK_RAW\",\n                    EOF: \"TK_EOF\"\n                };\n                var Tokenizer = function(input_string, options) {\n                    this._input = new InputScanner(input_string);\n                    this._options = options || {};\n                    this.__tokens = null;\n                    this._patterns = {};\n                    this._patterns.whitespace = new WhitespacePattern(this._input);\n                };\n                Tokenizer.prototype.tokenize = function() {\n                    this._input.restart();\n                    this.__tokens = new TokenStream();\n                    this._reset();\n                    var current;\n                    var previous = new Token(TOKEN.START, \"\");\n                    var open_token = null;\n                    var open_stack = [];\n                    var comments = new TokenStream();\n                    while(previous.type !== TOKEN.EOF){\n                        current = this._get_next_token(previous, open_token);\n                        while(this._is_comment(current)){\n                            comments.add(current);\n                            current = this._get_next_token(previous, open_token);\n                        }\n                        if (!comments.isEmpty()) {\n                            current.comments_before = comments;\n                            comments = new TokenStream();\n                        }\n                        current.parent = open_token;\n                        if (this._is_opening(current)) {\n                            open_stack.push(open_token);\n                            open_token = current;\n                        } else if (open_token && this._is_closing(current, open_token)) {\n                            current.opened = open_token;\n                            open_token.closed = current;\n                            open_token = open_stack.pop();\n                            current.parent = open_token;\n                        }\n                        current.previous = previous;\n                        previous.next = current;\n                        this.__tokens.add(current);\n                        previous = current;\n                    }\n                    return this.__tokens;\n                };\n                Tokenizer.prototype._is_first_token = function() {\n                    return this.__tokens.isEmpty();\n                };\n                Tokenizer.prototype._reset = function() {};\n                Tokenizer.prototype._get_next_token = function(previous_token, open_token) {\n                    this._readWhitespace();\n                    var resulting_string = this._input.read(/.+/g);\n                    if (resulting_string) {\n                        return this._create_token(TOKEN.RAW, resulting_string);\n                    } else {\n                        return this._create_token(TOKEN.EOF, \"\");\n                    }\n                };\n                Tokenizer.prototype._is_comment = function(current_token) {\n                    return false;\n                };\n                Tokenizer.prototype._is_opening = function(current_token) {\n                    return false;\n                };\n                Tokenizer.prototype._is_closing = function(current_token, open_token) {\n                    return false;\n                };\n                Tokenizer.prototype._create_token = function(type, text) {\n                    var token = new Token(type, text, this._patterns.whitespace.newline_count, this._patterns.whitespace.whitespace_before_token);\n                    return token;\n                };\n                Tokenizer.prototype._readWhitespace = function() {\n                    return this._patterns.whitespace.read();\n                };\n                module.exports.Tokenizer = Tokenizer;\n                module.exports.TOKEN = TOKEN;\n            /***/ },\n            /* 10 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function TokenStream(parent_token) {\n                    // private\n                    this.__tokens = [];\n                    this.__tokens_length = this.__tokens.length;\n                    this.__position = 0;\n                    this.__parent_token = parent_token;\n                }\n                TokenStream.prototype.restart = function() {\n                    this.__position = 0;\n                };\n                TokenStream.prototype.isEmpty = function() {\n                    return this.__tokens_length === 0;\n                };\n                TokenStream.prototype.hasNext = function() {\n                    return this.__position < this.__tokens_length;\n                };\n                TokenStream.prototype.next = function() {\n                    var val = null;\n                    if (this.hasNext()) {\n                        val = this.__tokens[this.__position];\n                        this.__position += 1;\n                    }\n                    return val;\n                };\n                TokenStream.prototype.peek = function(index) {\n                    var val = null;\n                    index = index || 0;\n                    index += this.__position;\n                    if (index >= 0 && index < this.__tokens_length) {\n                        val = this.__tokens[index];\n                    }\n                    return val;\n                };\n                TokenStream.prototype.add = function(token) {\n                    if (this.__parent_token) {\n                        token.parent = this.__parent_token;\n                    }\n                    this.__tokens.push(token);\n                    this.__tokens_length += 1;\n                };\n                module.exports.TokenStream = TokenStream;\n            /***/ },\n            /* 11 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_50157__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var Pattern = __nested_webpack_require_50157__(12).Pattern;\n                function WhitespacePattern(input_scanner, parent) {\n                    Pattern.call(this, input_scanner, parent);\n                    if (parent) {\n                        this._line_regexp = this._input.get_regexp(parent._line_regexp);\n                    } else {\n                        this.__set_whitespace_patterns(\"\", \"\");\n                    }\n                    this.newline_count = 0;\n                    this.whitespace_before_token = \"\";\n                }\n                WhitespacePattern.prototype = new Pattern();\n                WhitespacePattern.prototype.__set_whitespace_patterns = function(whitespace_chars, newline_chars) {\n                    whitespace_chars += \"\\\\t \";\n                    newline_chars += \"\\\\n\\\\r\";\n                    this._match_pattern = this._input.get_regexp(\"[\" + whitespace_chars + newline_chars + \"]+\", true);\n                    this._newline_regexp = this._input.get_regexp(\"\\\\r\\\\n|[\" + newline_chars + \"]\");\n                };\n                WhitespacePattern.prototype.read = function() {\n                    this.newline_count = 0;\n                    this.whitespace_before_token = \"\";\n                    var resulting_string = this._input.read(this._match_pattern);\n                    if (resulting_string === \" \") {\n                        this.whitespace_before_token = \" \";\n                    } else if (resulting_string) {\n                        var matches = this.__split(this._newline_regexp, resulting_string);\n                        this.newline_count = matches.length - 1;\n                        this.whitespace_before_token = matches[this.newline_count];\n                    }\n                    return resulting_string;\n                };\n                WhitespacePattern.prototype.matching = function(whitespace_chars, newline_chars) {\n                    var result = this._create();\n                    result.__set_whitespace_patterns(whitespace_chars, newline_chars);\n                    result._update();\n                    return result;\n                };\n                WhitespacePattern.prototype._create = function() {\n                    return new WhitespacePattern(this._input, this);\n                };\n                WhitespacePattern.prototype.__split = function(regexp, input_string) {\n                    regexp.lastIndex = 0;\n                    var start_index = 0;\n                    var result = [];\n                    var next_match = regexp.exec(input_string);\n                    while(next_match){\n                        result.push(input_string.substring(start_index, next_match.index));\n                        start_index = next_match.index + next_match[0].length;\n                        next_match = regexp.exec(input_string);\n                    }\n                    if (start_index < input_string.length) {\n                        result.push(input_string.substring(start_index, input_string.length));\n                    } else {\n                        result.push(\"\");\n                    }\n                    return result;\n                };\n                module.exports.WhitespacePattern = WhitespacePattern;\n            /***/ },\n            /* 12 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function Pattern(input_scanner, parent) {\n                    this._input = input_scanner;\n                    this._starting_pattern = null;\n                    this._match_pattern = null;\n                    this._until_pattern = null;\n                    this._until_after = false;\n                    if (parent) {\n                        this._starting_pattern = this._input.get_regexp(parent._starting_pattern, true);\n                        this._match_pattern = this._input.get_regexp(parent._match_pattern, true);\n                        this._until_pattern = this._input.get_regexp(parent._until_pattern);\n                        this._until_after = parent._until_after;\n                    }\n                }\n                Pattern.prototype.read = function() {\n                    var result = this._input.read(this._starting_pattern);\n                    if (!this._starting_pattern || result) {\n                        result += this._input.read(this._match_pattern, this._until_pattern, this._until_after);\n                    }\n                    return result;\n                };\n                Pattern.prototype.read_match = function() {\n                    return this._input.match(this._match_pattern);\n                };\n                Pattern.prototype.until_after = function(pattern) {\n                    var result = this._create();\n                    result._until_after = true;\n                    result._until_pattern = this._input.get_regexp(pattern);\n                    result._update();\n                    return result;\n                };\n                Pattern.prototype.until = function(pattern) {\n                    var result = this._create();\n                    result._until_after = false;\n                    result._until_pattern = this._input.get_regexp(pattern);\n                    result._update();\n                    return result;\n                };\n                Pattern.prototype.starting_with = function(pattern) {\n                    var result = this._create();\n                    result._starting_pattern = this._input.get_regexp(pattern, true);\n                    result._update();\n                    return result;\n                };\n                Pattern.prototype.matching = function(pattern) {\n                    var result = this._create();\n                    result._match_pattern = this._input.get_regexp(pattern, true);\n                    result._update();\n                    return result;\n                };\n                Pattern.prototype._create = function() {\n                    return new Pattern(this._input, this);\n                };\n                Pattern.prototype._update = function() {};\n                module.exports.Pattern = Pattern;\n            /***/ },\n            /* 13 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function Directives(start_block_pattern, end_block_pattern) {\n                    start_block_pattern = typeof start_block_pattern === \"string\" ? start_block_pattern : start_block_pattern.source;\n                    end_block_pattern = typeof end_block_pattern === \"string\" ? end_block_pattern : end_block_pattern.source;\n                    this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \\w+[:]\\w+)+ /.source + end_block_pattern, \"g\");\n                    this.__directive_pattern = / (\\w+)[:](\\w+)/g;\n                    this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\\sbeautify\\signore:end\\s/.source + end_block_pattern, \"g\");\n                }\n                Directives.prototype.get_directives = function(text) {\n                    if (!text.match(this.__directives_block_pattern)) {\n                        return null;\n                    }\n                    var directives = {};\n                    this.__directive_pattern.lastIndex = 0;\n                    var directive_match = this.__directive_pattern.exec(text);\n                    while(directive_match){\n                        directives[directive_match[1]] = directive_match[2];\n                        directive_match = this.__directive_pattern.exec(text);\n                    }\n                    return directives;\n                };\n                Directives.prototype.readIgnored = function(input) {\n                    return input.readUntilAfter(this.__directives_end_ignore_pattern);\n                };\n                module.exports.Directives = Directives;\n            /***/ },\n            /* 14 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_61549__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var Pattern = __nested_webpack_require_61549__(12).Pattern;\n                var template_names = {\n                    django: false,\n                    erb: false,\n                    handlebars: false,\n                    php: false,\n                    smarty: false\n                };\n                // This lets templates appear anywhere we would do a readUntil\n                // The cost is higher but it is pay to play.\n                function TemplatablePattern(input_scanner, parent) {\n                    Pattern.call(this, input_scanner, parent);\n                    this.__template_pattern = null;\n                    this._disabled = Object.assign({}, template_names);\n                    this._excluded = Object.assign({}, template_names);\n                    if (parent) {\n                        this.__template_pattern = this._input.get_regexp(parent.__template_pattern);\n                        this._excluded = Object.assign(this._excluded, parent._excluded);\n                        this._disabled = Object.assign(this._disabled, parent._disabled);\n                    }\n                    var pattern = new Pattern(input_scanner);\n                    this.__patterns = {\n                        handlebars_comment: pattern.starting_with(/{{!--/).until_after(/--}}/),\n                        handlebars_unescaped: pattern.starting_with(/{{{/).until_after(/}}}/),\n                        handlebars: pattern.starting_with(/{{/).until_after(/}}/),\n                        php: pattern.starting_with(/<\\?(?:[= ]|php)/).until_after(/\\?>/),\n                        erb: pattern.starting_with(/<%[^%]/).until_after(/[^%]%>/),\n                        // django coflicts with handlebars a bit.\n                        django: pattern.starting_with(/{%/).until_after(/%}/),\n                        django_value: pattern.starting_with(/{{/).until_after(/}}/),\n                        django_comment: pattern.starting_with(/{#/).until_after(/#}/),\n                        smarty: pattern.starting_with(/{(?=[^}{\\s\\n])/).until_after(/[^\\s\\n]}/),\n                        smarty_comment: pattern.starting_with(/{\\*/).until_after(/\\*}/),\n                        smarty_literal: pattern.starting_with(/{literal}/).until_after(/{\\/literal}/)\n                    };\n                }\n                TemplatablePattern.prototype = new Pattern();\n                TemplatablePattern.prototype._create = function() {\n                    return new TemplatablePattern(this._input, this);\n                };\n                TemplatablePattern.prototype._update = function() {\n                    this.__set_templated_pattern();\n                };\n                TemplatablePattern.prototype.disable = function(language) {\n                    var result = this._create();\n                    result._disabled[language] = true;\n                    result._update();\n                    return result;\n                };\n                TemplatablePattern.prototype.read_options = function(options) {\n                    var result = this._create();\n                    for(var language in template_names){\n                        result._disabled[language] = options.templating.indexOf(language) === -1;\n                    }\n                    result._update();\n                    return result;\n                };\n                TemplatablePattern.prototype.exclude = function(language) {\n                    var result = this._create();\n                    result._excluded[language] = true;\n                    result._update();\n                    return result;\n                };\n                TemplatablePattern.prototype.read = function() {\n                    var result = \"\";\n                    if (this._match_pattern) {\n                        result = this._input.read(this._starting_pattern);\n                    } else {\n                        result = this._input.read(this._starting_pattern, this.__template_pattern);\n                    }\n                    var next = this._read_template();\n                    while(next){\n                        if (this._match_pattern) {\n                            next += this._input.read(this._match_pattern);\n                        } else {\n                            next += this._input.readUntil(this.__template_pattern);\n                        }\n                        result += next;\n                        next = this._read_template();\n                    }\n                    if (this._until_after) {\n                        result += this._input.readUntilAfter(this._until_pattern);\n                    }\n                    return result;\n                };\n                TemplatablePattern.prototype.__set_templated_pattern = function() {\n                    var items = [];\n                    if (!this._disabled.php) {\n                        items.push(this.__patterns.php._starting_pattern.source);\n                    }\n                    if (!this._disabled.handlebars) {\n                        items.push(this.__patterns.handlebars._starting_pattern.source);\n                    }\n                    if (!this._disabled.erb) {\n                        items.push(this.__patterns.erb._starting_pattern.source);\n                    }\n                    if (!this._disabled.django) {\n                        items.push(this.__patterns.django._starting_pattern.source);\n                        // The starting pattern for django is more complex because it has different\n                        // patterns for value, comment, and other sections\n                        items.push(this.__patterns.django_value._starting_pattern.source);\n                        items.push(this.__patterns.django_comment._starting_pattern.source);\n                    }\n                    if (!this._disabled.smarty) {\n                        items.push(this.__patterns.smarty._starting_pattern.source);\n                    }\n                    if (this._until_pattern) {\n                        items.push(this._until_pattern.source);\n                    }\n                    this.__template_pattern = this._input.get_regexp(\"(?:\" + items.join(\"|\") + \")\");\n                };\n                TemplatablePattern.prototype._read_template = function() {\n                    var resulting_string = \"\";\n                    var c = this._input.peek();\n                    if (c === \"<\") {\n                        var peek1 = this._input.peek(1);\n                        //if we're in a comment, do something special\n                        // We treat all comments as literals, even more than preformatted tags\n                        // we just look for the appropriate close tag\n                        if (!this._disabled.php && !this._excluded.php && peek1 === \"?\") {\n                            resulting_string = resulting_string || this.__patterns.php.read();\n                        }\n                        if (!this._disabled.erb && !this._excluded.erb && peek1 === \"%\") {\n                            resulting_string = resulting_string || this.__patterns.erb.read();\n                        }\n                    } else if (c === \"{\") {\n                        if (!this._disabled.handlebars && !this._excluded.handlebars) {\n                            resulting_string = resulting_string || this.__patterns.handlebars_comment.read();\n                            resulting_string = resulting_string || this.__patterns.handlebars_unescaped.read();\n                            resulting_string = resulting_string || this.__patterns.handlebars.read();\n                        }\n                        if (!this._disabled.django) {\n                            // django coflicts with handlebars a bit.\n                            if (!this._excluded.django && !this._excluded.handlebars) {\n                                resulting_string = resulting_string || this.__patterns.django_value.read();\n                            }\n                            if (!this._excluded.django) {\n                                resulting_string = resulting_string || this.__patterns.django_comment.read();\n                                resulting_string = resulting_string || this.__patterns.django.read();\n                            }\n                        }\n                        if (!this._disabled.smarty) {\n                            // smarty cannot be enabled with django or handlebars enabled\n                            if (this._disabled.django && this._disabled.handlebars) {\n                                resulting_string = resulting_string || this.__patterns.smarty_comment.read();\n                                resulting_string = resulting_string || this.__patterns.smarty_literal.read();\n                                resulting_string = resulting_string || this.__patterns.smarty.read();\n                            }\n                        }\n                    }\n                    return resulting_string;\n                };\n                module.exports.TemplatablePattern = TemplatablePattern;\n            /***/ },\n            ,\n            ,\n            ,\n            /* 18 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_71896__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var Beautifier = __nested_webpack_require_71896__(19).Beautifier, Options = __nested_webpack_require_71896__(20).Options;\n                function style_html(html_source, options, js_beautify, css_beautify) {\n                    var beautifier = new Beautifier(html_source, options, js_beautify, css_beautify);\n                    return beautifier.beautify();\n                }\n                module.exports = style_html;\n                module.exports.defaultOptions = function() {\n                    return new Options();\n                };\n            /***/ },\n            /* 19 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_73732__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var Options = __nested_webpack_require_73732__(20).Options;\n                var Output = __nested_webpack_require_73732__(2).Output;\n                var Tokenizer = __nested_webpack_require_73732__(21).Tokenizer;\n                var TOKEN = __nested_webpack_require_73732__(21).TOKEN;\n                var lineBreak = /\\r\\n|[\\r\\n]/;\n                var allLineBreaks = /\\r\\n|[\\r\\n]/g;\n                var Printer = function(options, base_indent_string) {\n                    this.indent_level = 0;\n                    this.alignment_size = 0;\n                    this.max_preserve_newlines = options.max_preserve_newlines;\n                    this.preserve_newlines = options.preserve_newlines;\n                    this._output = new Output(options, base_indent_string);\n                };\n                Printer.prototype.current_line_has_match = function(pattern) {\n                    return this._output.current_line.has_match(pattern);\n                };\n                Printer.prototype.set_space_before_token = function(value, non_breaking) {\n                    this._output.space_before_token = value;\n                    this._output.non_breaking_space = non_breaking;\n                };\n                Printer.prototype.set_wrap_point = function() {\n                    this._output.set_indent(this.indent_level, this.alignment_size);\n                    this._output.set_wrap_point();\n                };\n                Printer.prototype.add_raw_token = function(token) {\n                    this._output.add_raw_token(token);\n                };\n                Printer.prototype.print_preserved_newlines = function(raw_token) {\n                    var newlines = 0;\n                    if (raw_token.type !== TOKEN.TEXT && raw_token.previous.type !== TOKEN.TEXT) {\n                        newlines = raw_token.newlines ? 1 : 0;\n                    }\n                    if (this.preserve_newlines) {\n                        newlines = raw_token.newlines < this.max_preserve_newlines + 1 ? raw_token.newlines : this.max_preserve_newlines + 1;\n                    }\n                    for(var n = 0; n < newlines; n++){\n                        this.print_newline(n > 0);\n                    }\n                    return newlines !== 0;\n                };\n                Printer.prototype.traverse_whitespace = function(raw_token) {\n                    if (raw_token.whitespace_before || raw_token.newlines) {\n                        if (!this.print_preserved_newlines(raw_token)) {\n                            this._output.space_before_token = true;\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n                Printer.prototype.previous_token_wrapped = function() {\n                    return this._output.previous_token_wrapped;\n                };\n                Printer.prototype.print_newline = function(force) {\n                    this._output.add_new_line(force);\n                };\n                Printer.prototype.print_token = function(token) {\n                    if (token.text) {\n                        this._output.set_indent(this.indent_level, this.alignment_size);\n                        this._output.add_token(token.text);\n                    }\n                };\n                Printer.prototype.indent = function() {\n                    this.indent_level++;\n                };\n                Printer.prototype.get_full_indent = function(level) {\n                    level = this.indent_level + (level || 0);\n                    if (level < 1) {\n                        return \"\";\n                    }\n                    return this._output.get_indent_string(level);\n                };\n                var get_type_attribute = function(start_token) {\n                    var result = null;\n                    var raw_token = start_token.next;\n                    // Search attributes for a type attribute\n                    while(raw_token.type !== TOKEN.EOF && start_token.closed !== raw_token){\n                        if (raw_token.type === TOKEN.ATTRIBUTE && raw_token.text === \"type\") {\n                            if (raw_token.next && raw_token.next.type === TOKEN.EQUALS && raw_token.next.next && raw_token.next.next.type === TOKEN.VALUE) {\n                                result = raw_token.next.next.text;\n                            }\n                            break;\n                        }\n                        raw_token = raw_token.next;\n                    }\n                    return result;\n                };\n                var get_custom_beautifier_name = function(tag_check, raw_token) {\n                    var typeAttribute = null;\n                    var result = null;\n                    if (!raw_token.closed) {\n                        return null;\n                    }\n                    if (tag_check === \"script\") {\n                        typeAttribute = \"text/javascript\";\n                    } else if (tag_check === \"style\") {\n                        typeAttribute = \"text/css\";\n                    }\n                    typeAttribute = get_type_attribute(raw_token) || typeAttribute;\n                    // For script and style tags that have a type attribute, only enable custom beautifiers for matching values\n                    // For those without a type attribute use default;\n                    if (typeAttribute.search(\"text/css\") > -1) {\n                        result = \"css\";\n                    } else if (typeAttribute.search(/module|((text|application|dojo)\\/(x-)?(javascript|ecmascript|jscript|livescript|(ld\\+)?json|method|aspect))/) > -1) {\n                        result = \"javascript\";\n                    } else if (typeAttribute.search(/(text|application|dojo)\\/(x-)?(html)/) > -1) {\n                        result = \"html\";\n                    } else if (typeAttribute.search(/test\\/null/) > -1) {\n                        // Test only mime-type for testing the beautifier when null is passed as beautifing function\n                        result = \"null\";\n                    }\n                    return result;\n                };\n                function in_array(what, arr) {\n                    return arr.indexOf(what) !== -1;\n                }\n                function TagFrame(parent, parser_token, indent_level) {\n                    this.parent = parent || null;\n                    this.tag = parser_token ? parser_token.tag_name : \"\";\n                    this.indent_level = indent_level || 0;\n                    this.parser_token = parser_token || null;\n                }\n                function TagStack(printer) {\n                    this._printer = printer;\n                    this._current_frame = null;\n                }\n                TagStack.prototype.get_parser_token = function() {\n                    return this._current_frame ? this._current_frame.parser_token : null;\n                };\n                TagStack.prototype.record_tag = function(parser_token) {\n                    var new_frame = new TagFrame(this._current_frame, parser_token, this._printer.indent_level);\n                    this._current_frame = new_frame;\n                };\n                TagStack.prototype._try_pop_frame = function(frame) {\n                    var parser_token = null;\n                    if (frame) {\n                        parser_token = frame.parser_token;\n                        this._printer.indent_level = frame.indent_level;\n                        this._current_frame = frame.parent;\n                    }\n                    return parser_token;\n                };\n                TagStack.prototype._get_frame = function(tag_list, stop_list) {\n                    var frame = this._current_frame;\n                    while(frame){\n                        if (tag_list.indexOf(frame.tag) !== -1) {\n                            break;\n                        } else if (stop_list && stop_list.indexOf(frame.tag) !== -1) {\n                            frame = null;\n                            break;\n                        }\n                        frame = frame.parent;\n                    }\n                    return frame;\n                };\n                TagStack.prototype.try_pop = function(tag, stop_list) {\n                    var frame = this._get_frame([\n                        tag\n                    ], stop_list);\n                    return this._try_pop_frame(frame);\n                };\n                TagStack.prototype.indent_to_tag = function(tag_list) {\n                    var frame = this._get_frame(tag_list);\n                    if (frame) {\n                        this._printer.indent_level = frame.indent_level;\n                    }\n                };\n                function Beautifier(source_text, options, js_beautify, css_beautify) {\n                    //Wrapper function to invoke all the necessary constructors and deal with the output.\n                    this._source_text = source_text || \"\";\n                    options = options || {};\n                    this._js_beautify = js_beautify;\n                    this._css_beautify = css_beautify;\n                    this._tag_stack = null;\n                    // Allow the setting of language/file-type specific options\n                    // with inheritance of overall settings\n                    var optionHtml = new Options(options, \"html\");\n                    this._options = optionHtml;\n                    this._is_wrap_attributes_force = this._options.wrap_attributes.substr(0, \"force\".length) === \"force\";\n                    this._is_wrap_attributes_force_expand_multiline = this._options.wrap_attributes === \"force-expand-multiline\";\n                    this._is_wrap_attributes_force_aligned = this._options.wrap_attributes === \"force-aligned\";\n                    this._is_wrap_attributes_aligned_multiple = this._options.wrap_attributes === \"aligned-multiple\";\n                    this._is_wrap_attributes_preserve = this._options.wrap_attributes.substr(0, \"preserve\".length) === \"preserve\";\n                    this._is_wrap_attributes_preserve_aligned = this._options.wrap_attributes === \"preserve-aligned\";\n                }\n                Beautifier.prototype.beautify = function() {\n                    // if disabled, return the input unchanged.\n                    if (this._options.disabled) {\n                        return this._source_text;\n                    }\n                    var source_text = this._source_text;\n                    var eol = this._options.eol;\n                    if (this._options.eol === \"auto\") {\n                        eol = \"\\n\";\n                        if (source_text && lineBreak.test(source_text)) {\n                            eol = source_text.match(lineBreak)[0];\n                        }\n                    }\n                    // HACK: newline parsing inconsistent. This brute force normalizes the input.\n                    source_text = source_text.replace(allLineBreaks, \"\\n\");\n                    var baseIndentString = source_text.match(/^[\\t ]*/)[0];\n                    var last_token = {\n                        text: \"\",\n                        type: \"\"\n                    };\n                    var last_tag_token = new TagOpenParserToken();\n                    var printer = new Printer(this._options, baseIndentString);\n                    var tokens = new Tokenizer(source_text, this._options).tokenize();\n                    this._tag_stack = new TagStack(printer);\n                    var parser_token = null;\n                    var raw_token = tokens.next();\n                    while(raw_token.type !== TOKEN.EOF){\n                        if (raw_token.type === TOKEN.TAG_OPEN || raw_token.type === TOKEN.COMMENT) {\n                            parser_token = this._handle_tag_open(printer, raw_token, last_tag_token, last_token, tokens);\n                            last_tag_token = parser_token;\n                        } else if (raw_token.type === TOKEN.ATTRIBUTE || raw_token.type === TOKEN.EQUALS || raw_token.type === TOKEN.VALUE || raw_token.type === TOKEN.TEXT && !last_tag_token.tag_complete) {\n                            parser_token = this._handle_inside_tag(printer, raw_token, last_tag_token, last_token);\n                        } else if (raw_token.type === TOKEN.TAG_CLOSE) {\n                            parser_token = this._handle_tag_close(printer, raw_token, last_tag_token);\n                        } else if (raw_token.type === TOKEN.TEXT) {\n                            parser_token = this._handle_text(printer, raw_token, last_tag_token);\n                        } else {\n                            // This should never happen, but if it does. Print the raw token\n                            printer.add_raw_token(raw_token);\n                        }\n                        last_token = parser_token;\n                        raw_token = tokens.next();\n                    }\n                    var sweet_code = printer._output.get_code(eol);\n                    return sweet_code;\n                };\n                Beautifier.prototype._handle_tag_close = function(printer, raw_token, last_tag_token) {\n                    var parser_token = {\n                        text: raw_token.text,\n                        type: raw_token.type\n                    };\n                    printer.alignment_size = 0;\n                    last_tag_token.tag_complete = true;\n                    printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== \"\", true);\n                    if (last_tag_token.is_unformatted) {\n                        printer.add_raw_token(raw_token);\n                    } else {\n                        if (last_tag_token.tag_start_char === \"<\") {\n                            printer.set_space_before_token(raw_token.text[0] === \"/\", true); // space before />, no space before >\n                            if (this._is_wrap_attributes_force_expand_multiline && last_tag_token.has_wrapped_attrs) {\n                                printer.print_newline(false);\n                            }\n                        }\n                        printer.print_token(raw_token);\n                    }\n                    if (last_tag_token.indent_content && !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {\n                        printer.indent();\n                        // only indent once per opened tag\n                        last_tag_token.indent_content = false;\n                    }\n                    if (!last_tag_token.is_inline_element && !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {\n                        printer.set_wrap_point();\n                    }\n                    return parser_token;\n                };\n                Beautifier.prototype._handle_inside_tag = function(printer, raw_token, last_tag_token, last_token) {\n                    var wrapped = last_tag_token.has_wrapped_attrs;\n                    var parser_token = {\n                        text: raw_token.text,\n                        type: raw_token.type\n                    };\n                    printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== \"\", true);\n                    if (last_tag_token.is_unformatted) {\n                        printer.add_raw_token(raw_token);\n                    } else if (last_tag_token.tag_start_char === \"{\" && raw_token.type === TOKEN.TEXT) {\n                        // For the insides of handlebars allow newlines or a single space between open and contents\n                        if (printer.print_preserved_newlines(raw_token)) {\n                            raw_token.newlines = 0;\n                            printer.add_raw_token(raw_token);\n                        } else {\n                            printer.print_token(raw_token);\n                        }\n                    } else {\n                        if (raw_token.type === TOKEN.ATTRIBUTE) {\n                            printer.set_space_before_token(true);\n                        } else if (raw_token.type === TOKEN.EQUALS) {\n                            printer.set_space_before_token(false);\n                        } else if (raw_token.type === TOKEN.VALUE && raw_token.previous.type === TOKEN.EQUALS) {\n                            printer.set_space_before_token(false);\n                        }\n                        if (raw_token.type === TOKEN.ATTRIBUTE && last_tag_token.tag_start_char === \"<\") {\n                            if (this._is_wrap_attributes_preserve || this._is_wrap_attributes_preserve_aligned) {\n                                printer.traverse_whitespace(raw_token);\n                                wrapped = wrapped || raw_token.newlines !== 0;\n                            }\n                            // Wrap for 'force' options, and if the number of attributes is at least that specified in 'wrap_attributes_min_attrs':\n                            // 1. always wrap the second and beyond attributes\n                            // 2. wrap the first attribute only if 'force-expand-multiline' is specified\n                            if (this._is_wrap_attributes_force && last_tag_token.attr_count >= this._options.wrap_attributes_min_attrs && (last_token.type !== TOKEN.TAG_OPEN || // ie. second attribute and beyond\n                            this._is_wrap_attributes_force_expand_multiline)) {\n                                printer.print_newline(false);\n                                wrapped = true;\n                            }\n                        }\n                        printer.print_token(raw_token);\n                        wrapped = wrapped || printer.previous_token_wrapped();\n                        last_tag_token.has_wrapped_attrs = wrapped;\n                    }\n                    return parser_token;\n                };\n                Beautifier.prototype._handle_text = function(printer, raw_token, last_tag_token) {\n                    var parser_token = {\n                        text: raw_token.text,\n                        type: \"TK_CONTENT\"\n                    };\n                    if (last_tag_token.custom_beautifier_name) {\n                        this._print_custom_beatifier_text(printer, raw_token, last_tag_token);\n                    } else if (last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) {\n                        printer.add_raw_token(raw_token);\n                    } else {\n                        printer.traverse_whitespace(raw_token);\n                        printer.print_token(raw_token);\n                    }\n                    return parser_token;\n                };\n                Beautifier.prototype._print_custom_beatifier_text = function(printer, raw_token, last_tag_token) {\n                    var local = this;\n                    if (raw_token.text !== \"\") {\n                        var text = raw_token.text, _beautifier, script_indent_level = 1, pre = \"\", post = \"\";\n                        if (last_tag_token.custom_beautifier_name === \"javascript\" && typeof this._js_beautify === \"function\") {\n                            _beautifier = this._js_beautify;\n                        } else if (last_tag_token.custom_beautifier_name === \"css\" && typeof this._css_beautify === \"function\") {\n                            _beautifier = this._css_beautify;\n                        } else if (last_tag_token.custom_beautifier_name === \"html\") {\n                            _beautifier = function(html_source, options) {\n                                var beautifier = new Beautifier(html_source, options, local._js_beautify, local._css_beautify);\n                                return beautifier.beautify();\n                            };\n                        }\n                        if (this._options.indent_scripts === \"keep\") {\n                            script_indent_level = 0;\n                        } else if (this._options.indent_scripts === \"separate\") {\n                            script_indent_level = -printer.indent_level;\n                        }\n                        var indentation = printer.get_full_indent(script_indent_level);\n                        // if there is at least one empty line at the end of this text, strip it\n                        // we'll be adding one back after the text but before the containing tag.\n                        text = text.replace(/\\n[ \\t]*$/, \"\");\n                        // Handle the case where content is wrapped in a comment or cdata.\n                        if (last_tag_token.custom_beautifier_name !== \"html\" && text[0] === \"<\" && text.match(/^(<!--|<!\\[CDATA\\[)/)) {\n                            var matched = /^(<!--[^\\n]*|<!\\[CDATA\\[)(\\n?)([ \\t\\n]*)([\\s\\S]*)(-->|]]>)$/.exec(text);\n                            // if we start to wrap but don't finish, print raw\n                            if (!matched) {\n                                printer.add_raw_token(raw_token);\n                                return;\n                            }\n                            pre = indentation + matched[1] + \"\\n\";\n                            text = matched[4];\n                            if (matched[5]) {\n                                post = indentation + matched[5];\n                            }\n                            // if there is at least one empty line at the end of this text, strip it\n                            // we'll be adding one back after the text but before the containing tag.\n                            text = text.replace(/\\n[ \\t]*$/, \"\");\n                            if (matched[2] || matched[3].indexOf(\"\\n\") !== -1) {\n                                // if the first line of the non-comment text has spaces\n                                // use that as the basis for indenting in null case.\n                                matched = matched[3].match(/[ \\t]+$/);\n                                if (matched) {\n                                    raw_token.whitespace_before = matched[0];\n                                }\n                            }\n                        }\n                        if (text) {\n                            if (_beautifier) {\n                                // call the Beautifier if avaliable\n                                var Child_options = function() {\n                                    this.eol = \"\\n\";\n                                };\n                                Child_options.prototype = this._options.raw_options;\n                                var child_options = new Child_options();\n                                text = _beautifier(indentation + text, child_options);\n                            } else {\n                                // simply indent the string otherwise\n                                var white = raw_token.whitespace_before;\n                                if (white) {\n                                    text = text.replace(new RegExp(\"\\n(\" + white + \")?\", \"g\"), \"\\n\");\n                                }\n                                text = indentation + text.replace(/\\n/g, \"\\n\" + indentation);\n                            }\n                        }\n                        if (pre) {\n                            if (!text) {\n                                text = pre + post;\n                            } else {\n                                text = pre + text + \"\\n\" + post;\n                            }\n                        }\n                        printer.print_newline(false);\n                        if (text) {\n                            raw_token.text = text;\n                            raw_token.whitespace_before = \"\";\n                            raw_token.newlines = 0;\n                            printer.add_raw_token(raw_token);\n                            printer.print_newline(true);\n                        }\n                    }\n                };\n                Beautifier.prototype._handle_tag_open = function(printer, raw_token, last_tag_token, last_token, tokens) {\n                    var parser_token = this._get_tag_open_token(raw_token);\n                    if ((last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) && !last_tag_token.is_empty_element && raw_token.type === TOKEN.TAG_OPEN && !parser_token.is_start_tag) {\n                        // End element tags for unformatted or content_unformatted elements\n                        // are printed raw to keep any newlines inside them exactly the same.\n                        printer.add_raw_token(raw_token);\n                        parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name);\n                    } else {\n                        printer.traverse_whitespace(raw_token);\n                        this._set_tag_position(printer, raw_token, parser_token, last_tag_token, last_token);\n                        if (!parser_token.is_inline_element) {\n                            printer.set_wrap_point();\n                        }\n                        printer.print_token(raw_token);\n                    }\n                    // count the number of attributes\n                    if (parser_token.is_start_tag && this._is_wrap_attributes_force) {\n                        var peek_index = 0;\n                        var peek_token;\n                        do {\n                            peek_token = tokens.peek(peek_index);\n                            if (peek_token.type === TOKEN.ATTRIBUTE) {\n                                parser_token.attr_count += 1;\n                            }\n                            peek_index += 1;\n                        }while (peek_token.type !== TOKEN.EOF && peek_token.type !== TOKEN.TAG_CLOSE);\n                    }\n                    //indent attributes an auto, forced, aligned or forced-align line-wrap\n                    if (this._is_wrap_attributes_force_aligned || this._is_wrap_attributes_aligned_multiple || this._is_wrap_attributes_preserve_aligned) {\n                        parser_token.alignment_size = raw_token.text.length + 1;\n                    }\n                    if (!parser_token.tag_complete && !parser_token.is_unformatted) {\n                        printer.alignment_size = parser_token.alignment_size;\n                    }\n                    return parser_token;\n                };\n                var TagOpenParserToken = function(parent, raw_token) {\n                    this.parent = parent || null;\n                    this.text = \"\";\n                    this.type = \"TK_TAG_OPEN\";\n                    this.tag_name = \"\";\n                    this.is_inline_element = false;\n                    this.is_unformatted = false;\n                    this.is_content_unformatted = false;\n                    this.is_empty_element = false;\n                    this.is_start_tag = false;\n                    this.is_end_tag = false;\n                    this.indent_content = false;\n                    this.multiline_content = false;\n                    this.custom_beautifier_name = null;\n                    this.start_tag_token = null;\n                    this.attr_count = 0;\n                    this.has_wrapped_attrs = false;\n                    this.alignment_size = 0;\n                    this.tag_complete = false;\n                    this.tag_start_char = \"\";\n                    this.tag_check = \"\";\n                    if (!raw_token) {\n                        this.tag_complete = true;\n                    } else {\n                        var tag_check_match;\n                        this.tag_start_char = raw_token.text[0];\n                        this.text = raw_token.text;\n                        if (this.tag_start_char === \"<\") {\n                            tag_check_match = raw_token.text.match(/^<([^\\s>]*)/);\n                            this.tag_check = tag_check_match ? tag_check_match[1] : \"\";\n                        } else {\n                            tag_check_match = raw_token.text.match(/^{{~?(?:[\\^]|#\\*?)?([^\\s}]+)/);\n                            this.tag_check = tag_check_match ? tag_check_match[1] : \"\";\n                            // handle \"{{#> myPartial}}\" or \"{{~#> myPartial}}\"\n                            if ((raw_token.text.startsWith(\"{{#>\") || raw_token.text.startsWith(\"{{~#>\")) && this.tag_check[0] === \">\") {\n                                if (this.tag_check === \">\" && raw_token.next !== null) {\n                                    this.tag_check = raw_token.next.text.split(\" \")[0];\n                                } else {\n                                    this.tag_check = raw_token.text.split(\">\")[1];\n                                }\n                            }\n                        }\n                        this.tag_check = this.tag_check.toLowerCase();\n                        if (raw_token.type === TOKEN.COMMENT) {\n                            this.tag_complete = true;\n                        }\n                        this.is_start_tag = this.tag_check.charAt(0) !== \"/\";\n                        this.tag_name = !this.is_start_tag ? this.tag_check.substr(1) : this.tag_check;\n                        this.is_end_tag = !this.is_start_tag || raw_token.closed && raw_token.closed.text === \"/>\";\n                        // if whitespace handler ~ included (i.e. {{~#if true}}), handlebars tags start at pos 3 not pos 2\n                        var handlebar_starts = 2;\n                        if (this.tag_start_char === \"{\" && this.text.length >= 3) {\n                            if (this.text.charAt(2) === \"~\") {\n                                handlebar_starts = 3;\n                            }\n                        }\n                        // handlebars tags that don't start with # or ^ are single_tags, and so also start and end.\n                        this.is_end_tag = this.is_end_tag || this.tag_start_char === \"{\" && (this.text.length < 3 || /[^#\\^]/.test(this.text.charAt(handlebar_starts)));\n                    }\n                };\n                Beautifier.prototype._get_tag_open_token = function(raw_token) {\n                    var parser_token = new TagOpenParserToken(this._tag_stack.get_parser_token(), raw_token);\n                    parser_token.alignment_size = this._options.wrap_attributes_indent_size;\n                    parser_token.is_end_tag = parser_token.is_end_tag || in_array(parser_token.tag_check, this._options.void_elements);\n                    parser_token.is_empty_element = parser_token.tag_complete || parser_token.is_start_tag && parser_token.is_end_tag;\n                    parser_token.is_unformatted = !parser_token.tag_complete && in_array(parser_token.tag_check, this._options.unformatted);\n                    parser_token.is_content_unformatted = !parser_token.is_empty_element && in_array(parser_token.tag_check, this._options.content_unformatted);\n                    parser_token.is_inline_element = in_array(parser_token.tag_name, this._options.inline) || this._options.inline_custom_elements && parser_token.tag_name.includes(\"-\") || parser_token.tag_start_char === \"{\";\n                    return parser_token;\n                };\n                Beautifier.prototype._set_tag_position = function(printer, raw_token, parser_token, last_tag_token, last_token) {\n                    if (!parser_token.is_empty_element) {\n                        if (parser_token.is_end_tag) {\n                            parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name); //remove it and all ancestors\n                        } else {\n                            // check if this tag is starting an element that has optional end element\n                            // and do an ending needed\n                            if (this._do_optional_end_element(parser_token)) {\n                                if (!parser_token.is_inline_element) {\n                                    printer.print_newline(false);\n                                }\n                            }\n                            this._tag_stack.record_tag(parser_token); //push it on the tag stack\n                            if ((parser_token.tag_name === \"script\" || parser_token.tag_name === \"style\") && !(parser_token.is_unformatted || parser_token.is_content_unformatted)) {\n                                parser_token.custom_beautifier_name = get_custom_beautifier_name(parser_token.tag_check, raw_token);\n                            }\n                        }\n                    }\n                    if (in_array(parser_token.tag_check, this._options.extra_liners)) {\n                        printer.print_newline(false);\n                        if (!printer._output.just_added_blankline()) {\n                            printer.print_newline(true);\n                        }\n                    }\n                    if (parser_token.is_empty_element) {\n                        // if you hit an else case, reset the indent level if you are inside an:\n                        // 'if', 'unless', or 'each' block.\n                        if (parser_token.tag_start_char === \"{\" && parser_token.tag_check === \"else\") {\n                            this._tag_stack.indent_to_tag([\n                                \"if\",\n                                \"unless\",\n                                \"each\"\n                            ]);\n                            parser_token.indent_content = true;\n                            // Don't add a newline if opening {{#if}} tag is on the current line\n                            var foundIfOnCurrentLine = printer.current_line_has_match(/{{#if/);\n                            if (!foundIfOnCurrentLine) {\n                                printer.print_newline(false);\n                            }\n                        }\n                        // Don't add a newline before elements that should remain where they are.\n                        if (parser_token.tag_name === \"!--\" && last_token.type === TOKEN.TAG_CLOSE && last_tag_token.is_end_tag && parser_token.text.indexOf(\"\\n\") === -1) {\n                        //Do nothing. Leave comments on same line.\n                        } else {\n                            if (!(parser_token.is_inline_element || parser_token.is_unformatted)) {\n                                printer.print_newline(false);\n                            }\n                            this._calcluate_parent_multiline(printer, parser_token);\n                        }\n                    } else if (parser_token.is_end_tag) {\n                        var do_end_expand = false;\n                        // deciding whether a block is multiline should not be this hard\n                        do_end_expand = parser_token.start_tag_token && parser_token.start_tag_token.multiline_content;\n                        do_end_expand = do_end_expand || !parser_token.is_inline_element && !(last_tag_token.is_inline_element || last_tag_token.is_unformatted) && !(last_token.type === TOKEN.TAG_CLOSE && parser_token.start_tag_token === last_tag_token) && last_token.type !== \"TK_CONTENT\";\n                        if (parser_token.is_content_unformatted || parser_token.is_unformatted) {\n                            do_end_expand = false;\n                        }\n                        if (do_end_expand) {\n                            printer.print_newline(false);\n                        }\n                    } else {\n                        parser_token.indent_content = !parser_token.custom_beautifier_name;\n                        if (parser_token.tag_start_char === \"<\") {\n                            if (parser_token.tag_name === \"html\") {\n                                parser_token.indent_content = this._options.indent_inner_html;\n                            } else if (parser_token.tag_name === \"head\") {\n                                parser_token.indent_content = this._options.indent_head_inner_html;\n                            } else if (parser_token.tag_name === \"body\") {\n                                parser_token.indent_content = this._options.indent_body_inner_html;\n                            }\n                        }\n                        if (!(parser_token.is_inline_element || parser_token.is_unformatted) && (last_token.type !== \"TK_CONTENT\" || parser_token.is_content_unformatted)) {\n                            printer.print_newline(false);\n                        }\n                        this._calcluate_parent_multiline(printer, parser_token);\n                    }\n                };\n                Beautifier.prototype._calcluate_parent_multiline = function(printer, parser_token) {\n                    if (parser_token.parent && printer._output.just_added_newline() && !((parser_token.is_inline_element || parser_token.is_unformatted) && parser_token.parent.is_inline_element)) {\n                        parser_token.parent.multiline_content = true;\n                    }\n                };\n                //To be used for <p> tag special case:\n                var p_closers = [\n                    \"address\",\n                    \"article\",\n                    \"aside\",\n                    \"blockquote\",\n                    \"details\",\n                    \"div\",\n                    \"dl\",\n                    \"fieldset\",\n                    \"figcaption\",\n                    \"figure\",\n                    \"footer\",\n                    \"form\",\n                    \"h1\",\n                    \"h2\",\n                    \"h3\",\n                    \"h4\",\n                    \"h5\",\n                    \"h6\",\n                    \"header\",\n                    \"hr\",\n                    \"main\",\n                    \"menu\",\n                    \"nav\",\n                    \"ol\",\n                    \"p\",\n                    \"pre\",\n                    \"section\",\n                    \"table\",\n                    \"ul\"\n                ];\n                var p_parent_excludes = [\n                    \"a\",\n                    \"audio\",\n                    \"del\",\n                    \"ins\",\n                    \"map\",\n                    \"noscript\",\n                    \"video\"\n                ];\n                Beautifier.prototype._do_optional_end_element = function(parser_token) {\n                    var result = null;\n                    // NOTE: cases of \"if there is no more content in the parent element\"\n                    // are handled automatically by the beautifier.\n                    // It assumes parent or ancestor close tag closes all children.\n                    // https://www.w3.org/TR/html5/syntax.html#optional-tags\n                    if (parser_token.is_empty_element || !parser_token.is_start_tag || !parser_token.parent) {\n                        return;\n                    }\n                    if (parser_token.tag_name === \"body\") {\n                        // A head element’s end tag may be omitted if the head element is not immediately followed by a space character or a comment.\n                        result = result || this._tag_stack.try_pop(\"head\");\n                    //} else if (parser_token.tag_name === 'body') {\n                    // DONE: A body element’s end tag may be omitted if the body element is not immediately followed by a comment.\n                    } else if (parser_token.tag_name === \"li\") {\n                        // An li element’s end tag may be omitted if the li element is immediately followed by another li element or if there is no more content in the parent element.\n                        result = result || this._tag_stack.try_pop(\"li\", [\n                            \"ol\",\n                            \"ul\",\n                            \"menu\"\n                        ]);\n                    } else if (parser_token.tag_name === \"dd\" || parser_token.tag_name === \"dt\") {\n                        // A dd element’s end tag may be omitted if the dd element is immediately followed by another dd element or a dt element, or if there is no more content in the parent element.\n                        // A dt element’s end tag may be omitted if the dt element is immediately followed by another dt element or a dd element.\n                        result = result || this._tag_stack.try_pop(\"dt\", [\n                            \"dl\"\n                        ]);\n                        result = result || this._tag_stack.try_pop(\"dd\", [\n                            \"dl\"\n                        ]);\n                    } else if (parser_token.parent.tag_name === \"p\" && p_closers.indexOf(parser_token.tag_name) !== -1) {\n                        // IMPORTANT: this else-if works because p_closers has no overlap with any other element we look for in this method\n                        // check for the parent element is an HTML element that is not an <a>, <audio>, <del>, <ins>, <map>, <noscript>, or <video> element,  or an autonomous custom element.\n                        // To do this right, this needs to be coded as an inclusion of the inverse of the exclusion above.\n                        // But to start with (if we ignore \"autonomous custom elements\") the exclusion would be fine.\n                        var p_parent = parser_token.parent.parent;\n                        if (!p_parent || p_parent_excludes.indexOf(p_parent.tag_name) === -1) {\n                            result = result || this._tag_stack.try_pop(\"p\");\n                        }\n                    } else if (parser_token.tag_name === \"rp\" || parser_token.tag_name === \"rt\") {\n                        // An rt element’s end tag may be omitted if the rt element is immediately followed by an rt or rp element, or if there is no more content in the parent element.\n                        // An rp element’s end tag may be omitted if the rp element is immediately followed by an rt or rp element, or if there is no more content in the parent element.\n                        result = result || this._tag_stack.try_pop(\"rt\", [\n                            \"ruby\",\n                            \"rtc\"\n                        ]);\n                        result = result || this._tag_stack.try_pop(\"rp\", [\n                            \"ruby\",\n                            \"rtc\"\n                        ]);\n                    } else if (parser_token.tag_name === \"optgroup\") {\n                        // An optgroup element’s end tag may be omitted if the optgroup element is immediately followed by another optgroup element, or if there is no more content in the parent element.\n                        // An option element’s end tag may be omitted if the option element is immediately followed by another option element, or if it is immediately followed by an optgroup element, or if there is no more content in the parent element.\n                        result = result || this._tag_stack.try_pop(\"optgroup\", [\n                            \"select\"\n                        ]);\n                    //result = result || this._tag_stack.try_pop('option', ['select']);\n                    } else if (parser_token.tag_name === \"option\") {\n                        // An option element’s end tag may be omitted if the option element is immediately followed by another option element, or if it is immediately followed by an optgroup element, or if there is no more content in the parent element.\n                        result = result || this._tag_stack.try_pop(\"option\", [\n                            \"select\",\n                            \"datalist\",\n                            \"optgroup\"\n                        ]);\n                    } else if (parser_token.tag_name === \"colgroup\") {\n                        // DONE: A colgroup element’s end tag may be omitted if the colgroup element is not immediately followed by a space character or a comment.\n                        // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.\n                        result = result || this._tag_stack.try_pop(\"caption\", [\n                            \"table\"\n                        ]);\n                    } else if (parser_token.tag_name === \"thead\") {\n                        // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.\n                        // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.\n                        result = result || this._tag_stack.try_pop(\"caption\", [\n                            \"table\"\n                        ]);\n                        result = result || this._tag_stack.try_pop(\"colgroup\", [\n                            \"table\"\n                        ]);\n                    //} else if (parser_token.tag_name === 'caption') {\n                    // DONE: A caption element’s end tag may be omitted if the caption element is not immediately followed by a space character or a comment.\n                    } else if (parser_token.tag_name === \"tbody\" || parser_token.tag_name === \"tfoot\") {\n                        // A thead element’s end tag may be omitted if the thead element is immediately followed by a tbody or tfoot element.\n                        // A tbody element’s end tag may be omitted if the tbody element is immediately followed by a tbody or tfoot element, or if there is no more content in the parent element.\n                        // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.\n                        // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.\n                        result = result || this._tag_stack.try_pop(\"caption\", [\n                            \"table\"\n                        ]);\n                        result = result || this._tag_stack.try_pop(\"colgroup\", [\n                            \"table\"\n                        ]);\n                        result = result || this._tag_stack.try_pop(\"thead\", [\n                            \"table\"\n                        ]);\n                        result = result || this._tag_stack.try_pop(\"tbody\", [\n                            \"table\"\n                        ]);\n                    //} else if (parser_token.tag_name === 'tfoot') {\n                    // DONE: A tfoot element’s end tag may be omitted if there is no more content in the parent element.\n                    } else if (parser_token.tag_name === \"tr\") {\n                        // A tr element’s end tag may be omitted if the tr element is immediately followed by another tr element, or if there is no more content in the parent element.\n                        // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.\n                        // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.\n                        result = result || this._tag_stack.try_pop(\"caption\", [\n                            \"table\"\n                        ]);\n                        result = result || this._tag_stack.try_pop(\"colgroup\", [\n                            \"table\"\n                        ]);\n                        result = result || this._tag_stack.try_pop(\"tr\", [\n                            \"table\",\n                            \"thead\",\n                            \"tbody\",\n                            \"tfoot\"\n                        ]);\n                    } else if (parser_token.tag_name === \"th\" || parser_token.tag_name === \"td\") {\n                        // A td element’s end tag may be omitted if the td element is immediately followed by a td or th element, or if there is no more content in the parent element.\n                        // A th element’s end tag may be omitted if the th element is immediately followed by a td or th element, or if there is no more content in the parent element.\n                        result = result || this._tag_stack.try_pop(\"td\", [\n                            \"table\",\n                            \"thead\",\n                            \"tbody\",\n                            \"tfoot\",\n                            \"tr\"\n                        ]);\n                        result = result || this._tag_stack.try_pop(\"th\", [\n                            \"table\",\n                            \"thead\",\n                            \"tbody\",\n                            \"tfoot\",\n                            \"tr\"\n                        ]);\n                    }\n                    // Start element omission not handled currently\n                    // A head element’s start tag may be omitted if the element is empty, or if the first thing inside the head element is an element.\n                    // A tbody element’s start tag may be omitted if the first thing inside the tbody element is a tr element, and if the element is not immediately preceded by a tbody, thead, or tfoot element whose end tag has been omitted. (It can’t be omitted if the element is empty.)\n                    // A colgroup element’s start tag may be omitted if the first thing inside the colgroup element is a col element, and if the element is not immediately preceded by another colgroup element whose end tag has been omitted. (It can’t be omitted if the element is empty.)\n                    // Fix up the parent of the parser token\n                    parser_token.parent = this._tag_stack.get_parser_token();\n                    return result;\n                };\n                module.exports.Beautifier = Beautifier;\n            /***/ },\n            /* 20 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_124314__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var BaseOptions = __nested_webpack_require_124314__(6).Options;\n                function Options(options) {\n                    BaseOptions.call(this, options, \"html\");\n                    if (this.templating.length === 1 && this.templating[0] === \"auto\") {\n                        this.templating = [\n                            \"django\",\n                            \"erb\",\n                            \"handlebars\",\n                            \"php\"\n                        ];\n                    }\n                    this.indent_inner_html = this._get_boolean(\"indent_inner_html\");\n                    this.indent_body_inner_html = this._get_boolean(\"indent_body_inner_html\", true);\n                    this.indent_head_inner_html = this._get_boolean(\"indent_head_inner_html\", true);\n                    this.indent_handlebars = this._get_boolean(\"indent_handlebars\", true);\n                    this.wrap_attributes = this._get_selection(\"wrap_attributes\", [\n                        \"auto\",\n                        \"force\",\n                        \"force-aligned\",\n                        \"force-expand-multiline\",\n                        \"aligned-multiple\",\n                        \"preserve\",\n                        \"preserve-aligned\"\n                    ]);\n                    this.wrap_attributes_min_attrs = this._get_number(\"wrap_attributes_min_attrs\", 2);\n                    this.wrap_attributes_indent_size = this._get_number(\"wrap_attributes_indent_size\", this.indent_size);\n                    this.extra_liners = this._get_array(\"extra_liners\", [\n                        \"head\",\n                        \"body\",\n                        \"/html\"\n                    ]);\n                    // Block vs inline elements\n                    // https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements\n                    // https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements\n                    // https://www.w3.org/TR/html5/dom.html#phrasing-content\n                    this.inline = this._get_array(\"inline\", [\n                        \"a\",\n                        \"abbr\",\n                        \"area\",\n                        \"audio\",\n                        \"b\",\n                        \"bdi\",\n                        \"bdo\",\n                        \"br\",\n                        \"button\",\n                        \"canvas\",\n                        \"cite\",\n                        \"code\",\n                        \"data\",\n                        \"datalist\",\n                        \"del\",\n                        \"dfn\",\n                        \"em\",\n                        \"embed\",\n                        \"i\",\n                        \"iframe\",\n                        \"img\",\n                        \"input\",\n                        \"ins\",\n                        \"kbd\",\n                        \"keygen\",\n                        \"label\",\n                        \"map\",\n                        \"mark\",\n                        \"math\",\n                        \"meter\",\n                        \"noscript\",\n                        \"object\",\n                        \"output\",\n                        \"progress\",\n                        \"q\",\n                        \"ruby\",\n                        \"s\",\n                        \"samp\",\n                        /* 'script', */ \"select\",\n                        \"small\",\n                        \"span\",\n                        \"strong\",\n                        \"sub\",\n                        \"sup\",\n                        \"svg\",\n                        \"template\",\n                        \"textarea\",\n                        \"time\",\n                        \"u\",\n                        \"var\",\n                        \"video\",\n                        \"wbr\",\n                        \"text\",\n                        // obsolete inline tags\n                        \"acronym\",\n                        \"big\",\n                        \"strike\",\n                        \"tt\"\n                    ]);\n                    this.inline_custom_elements = this._get_boolean(\"inline_custom_elements\", true);\n                    this.void_elements = this._get_array(\"void_elements\", [\n                        // HTLM void elements - aka self-closing tags - aka singletons\n                        // https://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements\n                        \"area\",\n                        \"base\",\n                        \"br\",\n                        \"col\",\n                        \"embed\",\n                        \"hr\",\n                        \"img\",\n                        \"input\",\n                        \"keygen\",\n                        \"link\",\n                        \"menuitem\",\n                        \"meta\",\n                        \"param\",\n                        \"source\",\n                        \"track\",\n                        \"wbr\",\n                        // NOTE: Optional tags are too complex for a simple list\n                        // they are hard coded in _do_optional_end_element\n                        // Doctype and xml elements\n                        \"!doctype\",\n                        \"?xml\",\n                        // obsolete tags\n                        // basefont: https://www.computerhope.com/jargon/h/html-basefont-tag.htm\n                        // isndex: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/isindex\n                        \"basefont\",\n                        \"isindex\"\n                    ]);\n                    this.unformatted = this._get_array(\"unformatted\", []);\n                    this.content_unformatted = this._get_array(\"content_unformatted\", [\n                        \"pre\",\n                        \"textarea\"\n                    ]);\n                    this.unformatted_content_delimiter = this._get_characters(\"unformatted_content_delimiter\");\n                    this.indent_scripts = this._get_selection(\"indent_scripts\", [\n                        \"normal\",\n                        \"keep\",\n                        \"separate\"\n                    ]);\n                }\n                Options.prototype = new BaseOptions();\n                module.exports.Options = Options;\n            /***/ },\n            /* 21 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_131775__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var BaseTokenizer = __nested_webpack_require_131775__(9).Tokenizer;\n                var BASETOKEN = __nested_webpack_require_131775__(9).TOKEN;\n                var Directives = __nested_webpack_require_131775__(13).Directives;\n                var TemplatablePattern = __nested_webpack_require_131775__(14).TemplatablePattern;\n                var Pattern = __nested_webpack_require_131775__(12).Pattern;\n                var TOKEN = {\n                    TAG_OPEN: \"TK_TAG_OPEN\",\n                    TAG_CLOSE: \"TK_TAG_CLOSE\",\n                    ATTRIBUTE: \"TK_ATTRIBUTE\",\n                    EQUALS: \"TK_EQUALS\",\n                    VALUE: \"TK_VALUE\",\n                    COMMENT: \"TK_COMMENT\",\n                    TEXT: \"TK_TEXT\",\n                    UNKNOWN: \"TK_UNKNOWN\",\n                    START: BASETOKEN.START,\n                    RAW: BASETOKEN.RAW,\n                    EOF: BASETOKEN.EOF\n                };\n                var directives_core = new Directives(/<\\!--/, /-->/);\n                var Tokenizer = function(input_string, options) {\n                    BaseTokenizer.call(this, input_string, options);\n                    this._current_tag_name = \"\";\n                    // Words end at whitespace or when a tag starts\n                    // if we are indenting handlebars, they are considered tags\n                    var templatable_reader = new TemplatablePattern(this._input).read_options(this._options);\n                    var pattern_reader = new Pattern(this._input);\n                    this.__patterns = {\n                        word: templatable_reader.until(/[\\n\\r\\t <]/),\n                        single_quote: templatable_reader.until_after(/'/),\n                        double_quote: templatable_reader.until_after(/\"/),\n                        attribute: templatable_reader.until(/[\\n\\r\\t =>]|\\/>/),\n                        element_name: templatable_reader.until(/[\\n\\r\\t >\\/]/),\n                        handlebars_comment: pattern_reader.starting_with(/{{!--/).until_after(/--}}/),\n                        handlebars: pattern_reader.starting_with(/{{/).until_after(/}}/),\n                        handlebars_open: pattern_reader.until(/[\\n\\r\\t }]/),\n                        handlebars_raw_close: pattern_reader.until(/}}/),\n                        comment: pattern_reader.starting_with(/<!--/).until_after(/-->/),\n                        cdata: pattern_reader.starting_with(/<!\\[CDATA\\[/).until_after(/]]>/),\n                        // https://en.wikipedia.org/wiki/Conditional_comment\n                        conditional_comment: pattern_reader.starting_with(/<!\\[/).until_after(/]>/),\n                        processing: pattern_reader.starting_with(/<\\?/).until_after(/\\?>/)\n                    };\n                    if (this._options.indent_handlebars) {\n                        this.__patterns.word = this.__patterns.word.exclude(\"handlebars\");\n                    }\n                    this._unformatted_content_delimiter = null;\n                    if (this._options.unformatted_content_delimiter) {\n                        var literal_regexp = this._input.get_literal_regexp(this._options.unformatted_content_delimiter);\n                        this.__patterns.unformatted_content_delimiter = pattern_reader.matching(literal_regexp).until_after(literal_regexp);\n                    }\n                };\n                Tokenizer.prototype = new BaseTokenizer();\n                Tokenizer.prototype._is_comment = function(current_token) {\n                    return false; //current_token.type === TOKEN.COMMENT || current_token.type === TOKEN.UNKNOWN;\n                };\n                Tokenizer.prototype._is_opening = function(current_token) {\n                    return current_token.type === TOKEN.TAG_OPEN;\n                };\n                Tokenizer.prototype._is_closing = function(current_token, open_token) {\n                    return current_token.type === TOKEN.TAG_CLOSE && open_token && ((current_token.text === \">\" || current_token.text === \"/>\") && open_token.text[0] === \"<\" || current_token.text === \"}}\" && open_token.text[0] === \"{\" && open_token.text[1] === \"{\");\n                };\n                Tokenizer.prototype._reset = function() {\n                    this._current_tag_name = \"\";\n                };\n                Tokenizer.prototype._get_next_token = function(previous_token, open_token) {\n                    var token = null;\n                    this._readWhitespace();\n                    var c = this._input.peek();\n                    if (c === null) {\n                        return this._create_token(TOKEN.EOF, \"\");\n                    }\n                    token = token || this._read_open_handlebars(c, open_token);\n                    token = token || this._read_attribute(c, previous_token, open_token);\n                    token = token || this._read_close(c, open_token);\n                    token = token || this._read_raw_content(c, previous_token, open_token);\n                    token = token || this._read_content_word(c);\n                    token = token || this._read_comment_or_cdata(c);\n                    token = token || this._read_processing(c);\n                    token = token || this._read_open(c, open_token);\n                    token = token || this._create_token(TOKEN.UNKNOWN, this._input.next());\n                    return token;\n                };\n                Tokenizer.prototype._read_comment_or_cdata = function(c) {\n                    var token = null;\n                    var resulting_string = null;\n                    var directives = null;\n                    if (c === \"<\") {\n                        var peek1 = this._input.peek(1);\n                        // We treat all comments as literals, even more than preformatted tags\n                        // we only look for the appropriate closing marker\n                        if (peek1 === \"!\") {\n                            resulting_string = this.__patterns.comment.read();\n                            // only process directive on html comments\n                            if (resulting_string) {\n                                directives = directives_core.get_directives(resulting_string);\n                                if (directives && directives.ignore === \"start\") {\n                                    resulting_string += directives_core.readIgnored(this._input);\n                                }\n                            } else {\n                                resulting_string = this.__patterns.cdata.read();\n                            }\n                        }\n                        if (resulting_string) {\n                            token = this._create_token(TOKEN.COMMENT, resulting_string);\n                            token.directives = directives;\n                        }\n                    }\n                    return token;\n                };\n                Tokenizer.prototype._read_processing = function(c) {\n                    var token = null;\n                    var resulting_string = null;\n                    var directives = null;\n                    if (c === \"<\") {\n                        var peek1 = this._input.peek(1);\n                        if (peek1 === \"!\" || peek1 === \"?\") {\n                            resulting_string = this.__patterns.conditional_comment.read();\n                            resulting_string = resulting_string || this.__patterns.processing.read();\n                        }\n                        if (resulting_string) {\n                            token = this._create_token(TOKEN.COMMENT, resulting_string);\n                            token.directives = directives;\n                        }\n                    }\n                    return token;\n                };\n                Tokenizer.prototype._read_open = function(c, open_token) {\n                    var resulting_string = null;\n                    var token = null;\n                    if (!open_token) {\n                        if (c === \"<\") {\n                            resulting_string = this._input.next();\n                            if (this._input.peek() === \"/\") {\n                                resulting_string += this._input.next();\n                            }\n                            resulting_string += this.__patterns.element_name.read();\n                            token = this._create_token(TOKEN.TAG_OPEN, resulting_string);\n                        }\n                    }\n                    return token;\n                };\n                Tokenizer.prototype._read_open_handlebars = function(c, open_token) {\n                    var resulting_string = null;\n                    var token = null;\n                    if (!open_token) {\n                        if (this._options.indent_handlebars && c === \"{\" && this._input.peek(1) === \"{\") {\n                            if (this._input.peek(2) === \"!\") {\n                                resulting_string = this.__patterns.handlebars_comment.read();\n                                resulting_string = resulting_string || this.__patterns.handlebars.read();\n                                token = this._create_token(TOKEN.COMMENT, resulting_string);\n                            } else {\n                                resulting_string = this.__patterns.handlebars_open.read();\n                                token = this._create_token(TOKEN.TAG_OPEN, resulting_string);\n                            }\n                        }\n                    }\n                    return token;\n                };\n                Tokenizer.prototype._read_close = function(c, open_token) {\n                    var resulting_string = null;\n                    var token = null;\n                    if (open_token) {\n                        if (open_token.text[0] === \"<\" && (c === \">\" || c === \"/\" && this._input.peek(1) === \">\")) {\n                            resulting_string = this._input.next();\n                            if (c === \"/\") {\n                                resulting_string += this._input.next();\n                            }\n                            token = this._create_token(TOKEN.TAG_CLOSE, resulting_string);\n                        } else if (open_token.text[0] === \"{\" && c === \"}\" && this._input.peek(1) === \"}\") {\n                            this._input.next();\n                            this._input.next();\n                            token = this._create_token(TOKEN.TAG_CLOSE, \"}}\");\n                        }\n                    }\n                    return token;\n                };\n                Tokenizer.prototype._read_attribute = function(c, previous_token, open_token) {\n                    var token = null;\n                    var resulting_string = \"\";\n                    if (open_token && open_token.text[0] === \"<\") {\n                        if (c === \"=\") {\n                            token = this._create_token(TOKEN.EQUALS, this._input.next());\n                        } else if (c === '\"' || c === \"'\") {\n                            var content = this._input.next();\n                            if (c === '\"') {\n                                content += this.__patterns.double_quote.read();\n                            } else {\n                                content += this.__patterns.single_quote.read();\n                            }\n                            token = this._create_token(TOKEN.VALUE, content);\n                        } else {\n                            resulting_string = this.__patterns.attribute.read();\n                            if (resulting_string) {\n                                if (previous_token.type === TOKEN.EQUALS) {\n                                    token = this._create_token(TOKEN.VALUE, resulting_string);\n                                } else {\n                                    token = this._create_token(TOKEN.ATTRIBUTE, resulting_string);\n                                }\n                            }\n                        }\n                    }\n                    return token;\n                };\n                Tokenizer.prototype._is_content_unformatted = function(tag_name) {\n                    // void_elements have no content and so cannot have unformatted content\n                    // script and style tags should always be read as unformatted content\n                    // finally content_unformatted and unformatted element contents are unformatted\n                    return this._options.void_elements.indexOf(tag_name) === -1 && (this._options.content_unformatted.indexOf(tag_name) !== -1 || this._options.unformatted.indexOf(tag_name) !== -1);\n                };\n                Tokenizer.prototype._read_raw_content = function(c, previous_token, open_token) {\n                    var resulting_string = \"\";\n                    if (open_token && open_token.text[0] === \"{\") {\n                        resulting_string = this.__patterns.handlebars_raw_close.read();\n                    } else if (previous_token.type === TOKEN.TAG_CLOSE && previous_token.opened.text[0] === \"<\" && previous_token.text[0] !== \"/\") {\n                        // ^^ empty tag has no content \n                        var tag_name = previous_token.opened.text.substr(1).toLowerCase();\n                        if (tag_name === \"script\" || tag_name === \"style\") {\n                            // Script and style tags are allowed to have comments wrapping their content\n                            // or just have regular content.\n                            var token = this._read_comment_or_cdata(c);\n                            if (token) {\n                                token.type = TOKEN.TEXT;\n                                return token;\n                            }\n                            resulting_string = this._input.readUntil(new RegExp(\"</\" + tag_name + \"[\\\\n\\\\r\\\\t ]*?>\", \"ig\"));\n                        } else if (this._is_content_unformatted(tag_name)) {\n                            resulting_string = this._input.readUntil(new RegExp(\"</\" + tag_name + \"[\\\\n\\\\r\\\\t ]*?>\", \"ig\"));\n                        }\n                    }\n                    if (resulting_string) {\n                        return this._create_token(TOKEN.TEXT, resulting_string);\n                    }\n                    return null;\n                };\n                Tokenizer.prototype._read_content_word = function(c) {\n                    var resulting_string = \"\";\n                    if (this._options.unformatted_content_delimiter) {\n                        if (c === this._options.unformatted_content_delimiter[0]) {\n                            resulting_string = this.__patterns.unformatted_content_delimiter.read();\n                        }\n                    }\n                    if (!resulting_string) {\n                        resulting_string = this.__patterns.word.read();\n                    }\n                    if (resulting_string) {\n                        return this._create_token(TOKEN.TEXT, resulting_string);\n                    }\n                };\n                module.exports.Tokenizer = Tokenizer;\n                module.exports.TOKEN = TOKEN;\n            /***/ }\n        ];\n        /************************************************************************/ /******/ // The module cache\n        /******/ var __webpack_module_cache__ = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_148279__(moduleId) {\n            /******/ // Check if module is in cache\n            /******/ var cachedModule = __webpack_module_cache__[moduleId];\n            /******/ if (cachedModule !== undefined) {\n                /******/ return cachedModule.exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module = __webpack_module_cache__[moduleId] = {\n                /******/ // no module.id needed\n                /******/ // no module.loaded needed\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ __webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_148279__);\n            /******/ /******/ // Return the exports of the module\n            /******/ return module.exports;\n        /******/ }\n        /******/ /************************************************************************/ /******/ /******/ // startup\n        /******/ // Load entry module and return exports\n        /******/ // This entry module is referenced by other modules so it can't be inlined\n        /******/ var __nested_webpack_exports__ = __nested_webpack_require_148279__(18);\n        /******/ legacy_beautify_html = __nested_webpack_exports__;\n    /******/ /******/ })();\n    var style_html = legacy_beautify_html;\n    /* Footer */ if (true) {\n        // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n            __webpack_require__,\n            __webpack_require__(/*! ./beautify */ \"(action-browser)/./node_modules/js-beautify/js/lib/beautify.js\"),\n            __webpack_require__(/*! ./beautify-css */ \"(action-browser)/./node_modules/js-beautify/js/lib/beautify-css.js\")\n        ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(requireamd) {\n            var js_beautify = __webpack_require__(/*! ./beautify */ \"(action-browser)/./node_modules/js-beautify/js/lib/beautify.js\");\n            var css_beautify = __webpack_require__(/*! ./beautify-css */ \"(action-browser)/./node_modules/js-beautify/js/lib/beautify-css.js\");\n            return {\n                html_beautify: function(html_source, options) {\n                    return style_html(html_source, options, js_beautify.js_beautify, css_beautify.css_beautify);\n                }\n            };\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else { var css_beautify, js_beautify; }\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qcy1iZWF1dGlmeS9qcy9saWIvYmVhdXRpZnktaHRtbC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrR0FBa0MsR0FDbEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUVBLEdBRUM7SUFFRCwwQkFBMEIsR0FDMUIsSUFBSUE7SUFDSixNQUFNLEdBQUk7UUFDVixNQUFNLEdBQUk7UUFDVixNQUFNLEdBQUksSUFBSUMsc0JBQXVCOzs7WUFHckMsS0FBSyxHQUNMLEdBQUcsR0FBSSxTQUFTQyxNQUFNO2dCQUV0QixtQkFBbUIsR0FDbkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQSxHQUlBLFNBQVNDLFdBQVdDLE1BQU07b0JBQ3hCLElBQUksQ0FBQ0MsUUFBUSxHQUFHRDtvQkFDaEIsSUFBSSxDQUFDRSxpQkFBaUIsR0FBRztvQkFDekIsZ0ZBQWdGO29CQUNoRixJQUFJLENBQUNDLGNBQWMsR0FBRyxDQUFDO29CQUN2QixJQUFJLENBQUNDLGlCQUFpQixHQUFHO29CQUN6QixJQUFJLENBQUNDLGtCQUFrQixHQUFHO29CQUMxQixJQUFJLENBQUNDLDRCQUE0QixHQUFHO29CQUNwQyxJQUFJLENBQUNDLHlCQUF5QixHQUFHLENBQUM7b0JBQ2xDLElBQUksQ0FBQ0MsNEJBQTRCLEdBQUc7b0JBRXBDLElBQUksQ0FBQ0MsT0FBTyxHQUFHLEVBQUU7Z0JBQ25CO2dCQUVBVixXQUFXVyxTQUFTLENBQUNDLFdBQVcsR0FBRztvQkFDakMsSUFBSUMsT0FBTyxJQUFJYixXQUFXLElBQUksQ0FBQ0UsUUFBUTtvQkFDdkNXLEtBQUtDLFVBQVUsQ0FBQyxJQUFJLENBQUNWLGNBQWMsRUFBRSxJQUFJLENBQUNDLGlCQUFpQjtvQkFDM0QsT0FBT1E7Z0JBQ1Q7Z0JBRUFiLFdBQVdXLFNBQVMsQ0FBQ0ksSUFBSSxHQUFHLFNBQVNDLEtBQUs7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QUF1QjhjLDBCQUFtQkE7SUFDcEQsTUFBTSxHQUNOLE1BQU0sR0FBRztJQUVULElBQUk1SyxhQUFhbFM7SUFDakIsVUFBVSxHQUNWLElBQUksSUFBMEMsRUFBRTtRQUM1QywwRkFBMEY7UUFDMUYrYyxpQ0FBTztZQUFDLG1CQUFTO1lBQUUsdUdBQVk7WUFBRSwrR0FBZ0I7U0FBQyxtQ0FBRSxTQUFTRSxVQUFVO1lBQ25FLElBQUk3SyxjQUFjNkssbUJBQVVBLENBQUMsa0ZBQVk7WUFDekMsSUFBSTVLLGVBQWU0SyxtQkFBVUEsQ0FBQywwRkFBZ0I7WUFFOUMsT0FBTztnQkFDSEMsZUFBZSxTQUFTL0ssV0FBVyxFQUFFN08sT0FBTztvQkFDeEMsT0FBTzRPLFdBQVdDLGFBQWE3TyxTQUFTOE8sWUFBWUEsV0FBVyxFQUFFQyxhQUFhQSxZQUFZO2dCQUM5RjtZQUNKO1FBQ0osQ0FBQztBQUFBLGtHQUFDO0lBQ04sT0FBTyxrQ0FtQk47QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL29wZW4tcHJvLW5leHQvLi9ub2RlX21vZHVsZXMvanMtYmVhdXRpZnkvanMvbGliL2JlYXV0aWZ5LWh0bWwuanM/ODEyMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBBVVRPLUdFTkVSQVRFRC4gRE8gTk9UIE1PRElGWS4gKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuXG5cbiBTdHlsZSBIVE1MXG4tLS0tLS0tLS0tLS0tLS1cblxuICBXcml0dGVuIGJ5IE5vY2h1bSBTb3Nzb25rbywgKG5zb3Nzb25rb0Bob3RtYWlsLmNvbSlcblxuICBCYXNlZCBvbiBjb2RlIGluaXRpYWxseSBkZXZlbG9wZWQgYnk6IEVpbmFyIExpZWxtYW5pcywgPGVpbmFyQGJlYXV0aWZpZXIuaW8+XG4gICAgaHR0cHM6Ly9iZWF1dGlmaWVyLmlvL1xuXG4gIFVzYWdlOlxuICAgIHN0eWxlX2h0bWwoaHRtbF9zb3VyY2UpO1xuXG4gICAgc3R5bGVfaHRtbChodG1sX3NvdXJjZSwgb3B0aW9ucyk7XG5cbiAgVGhlIG9wdGlvbnMgYXJlOlxuICAgIGluZGVudF9pbm5lcl9odG1sIChkZWZhdWx0IGZhbHNlKSAg4oCUIGluZGVudCA8aGVhZD4gYW5kIDxib2R5PiBzZWN0aW9ucyxcbiAgICBpbmRlbnRfc2l6ZSAoZGVmYXVsdCA0KSAgICAgICAgICDigJQgaW5kZW50YXRpb24gc2l6ZSxcbiAgICBpbmRlbnRfY2hhciAoZGVmYXVsdCBzcGFjZSkgICAgICDigJQgY2hhcmFjdGVyIHRvIGluZGVudCB3aXRoLFxuICAgIHdyYXBfbGluZV9sZW5ndGggKGRlZmF1bHQgMjUwKSAgICAgICAgICAgIC0gIG1heGltdW0gYW1vdW50IG9mIGNoYXJhY3RlcnMgcGVyIGxpbmUgKDAgPSBkaXNhYmxlKVxuICAgIGJyYWNlX3N0eWxlIChkZWZhdWx0IFwiY29sbGFwc2VcIikgLSBcImNvbGxhcHNlXCIgfCBcImV4cGFuZFwiIHwgXCJlbmQtZXhwYW5kXCIgfCBcIm5vbmVcIlxuICAgICAgICAgICAgcHV0IGJyYWNlcyBvbiB0aGUgc2FtZSBsaW5lIGFzIGNvbnRyb2wgc3RhdGVtZW50cyAoZGVmYXVsdCksIG9yIHB1dCBicmFjZXMgb24gb3duIGxpbmUgKEFsbG1hbiAvIEFOU0kgc3R5bGUpLCBvciBqdXN0IHB1dCBlbmQgYnJhY2VzIG9uIG93biBsaW5lLCBvciBhdHRlbXB0IHRvIGtlZXAgdGhlbSB3aGVyZSB0aGV5IGFyZS5cbiAgICBpbmxpbmUgKGRlZmF1bHRzIHRvIGlubGluZSB0YWdzKSAtIGxpc3Qgb2YgdGFncyB0byBiZSBjb25zaWRlcmVkIGlubGluZSB0YWdzXG4gICAgdW5mb3JtYXR0ZWQgKGRlZmF1bHRzIHRvIGlubGluZSB0YWdzKSAtIGxpc3Qgb2YgdGFncywgdGhhdCBzaG91bGRuJ3QgYmUgcmVmb3JtYXR0ZWRcbiAgICBjb250ZW50X3VuZm9ybWF0dGVkIChkZWZhdWx0cyB0byBbXCJwcmVcIiwgXCJ0ZXh0YXJlYVwiXSB0YWdzKSAtIGxpc3Qgb2YgdGFncywgd2hvc2UgY29udGVudCBzaG91bGRuJ3QgYmUgcmVmb3JtYXR0ZWRcbiAgICBpbmRlbnRfc2NyaXB0cyAoZGVmYXVsdCBub3JtYWwpICAtIFwia2VlcFwifFwic2VwYXJhdGVcInxcIm5vcm1hbFwiXG4gICAgcHJlc2VydmVfbmV3bGluZXMgKGRlZmF1bHQgdHJ1ZSkgLSB3aGV0aGVyIGV4aXN0aW5nIGxpbmUgYnJlYWtzIGJlZm9yZSBlbGVtZW50cyBzaG91bGQgYmUgcHJlc2VydmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT25seSB3b3JrcyBiZWZvcmUgZWxlbWVudHMsIG5vdCBpbnNpZGUgdGFncyBvciBmb3IgdGV4dC5cbiAgICBtYXhfcHJlc2VydmVfbmV3bGluZXMgKGRlZmF1bHQgdW5saW1pdGVkKSAtIG1heGltdW0gbnVtYmVyIG9mIGxpbmUgYnJlYWtzIHRvIGJlIHByZXNlcnZlZCBpbiBvbmUgY2h1bmtcbiAgICBpbmRlbnRfaGFuZGxlYmFycyAoZGVmYXVsdCBmYWxzZSkgLSBmb3JtYXQgYW5kIGluZGVudCB7eyNmb299fSBhbmQge3svZm9vfX1cbiAgICBlbmRfd2l0aF9uZXdsaW5lIChmYWxzZSkgICAgICAgICAgLSBlbmQgd2l0aCBhIG5ld2xpbmVcbiAgICBleHRyYV9saW5lcnMgKGRlZmF1bHQgW2hlYWQsYm9keSwvaHRtbF0pIC1MaXN0IG9mIHRhZ3MgdGhhdCBzaG91bGQgaGF2ZSBhbiBleHRyYSBuZXdsaW5lIGJlZm9yZSB0aGVtLlxuXG4gICAgZS5nLlxuXG4gICAgc3R5bGVfaHRtbChodG1sX3NvdXJjZSwge1xuICAgICAgJ2luZGVudF9pbm5lcl9odG1sJzogZmFsc2UsXG4gICAgICAnaW5kZW50X3NpemUnOiAyLFxuICAgICAgJ2luZGVudF9jaGFyJzogJyAnLFxuICAgICAgJ3dyYXBfbGluZV9sZW5ndGgnOiA3OCxcbiAgICAgICdicmFjZV9zdHlsZSc6ICdleHBhbmQnLFxuICAgICAgJ3ByZXNlcnZlX25ld2xpbmVzJzogdHJ1ZSxcbiAgICAgICdtYXhfcHJlc2VydmVfbmV3bGluZXMnOiA1LFxuICAgICAgJ2luZGVudF9oYW5kbGViYXJzJzogZmFsc2UsXG4gICAgICAnZXh0cmFfbGluZXJzJzogWycvaHRtbCddXG4gICAgfSk7XG4qL1xuXG4oZnVuY3Rpb24oKSB7XG5cbi8qIEdFTkVSQVRFRF9CVUlMRF9PVVRQVVQgKi9cbnZhciBsZWdhY3lfYmVhdXRpZnlfaHRtbDtcbi8qKioqKiovIChmdW5jdGlvbigpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHRcInVzZSBzdHJpY3RcIjtcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoW1xuLyogMCAqLyxcbi8qIDEgKi8sXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbmZ1bmN0aW9uIE91dHB1dExpbmUocGFyZW50KSB7XG4gIHRoaXMuX19wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgPSAwO1xuICAvLyB1c2UgaW5kZW50X2NvdW50IGFzIGEgbWFya2VyIGZvciB0aGlzLl9fbGluZXMgdGhhdCBoYXZlIHByZXNlcnZlZCBpbmRlbnRhdGlvblxuICB0aGlzLl9faW5kZW50X2NvdW50ID0gLTE7XG4gIHRoaXMuX19hbGlnbm1lbnRfY291bnQgPSAwO1xuICB0aGlzLl9fd3JhcF9wb2ludF9pbmRleCA9IDA7XG4gIHRoaXMuX193cmFwX3BvaW50X2NoYXJhY3Rlcl9jb3VudCA9IDA7XG4gIHRoaXMuX193cmFwX3BvaW50X2luZGVudF9jb3VudCA9IC0xO1xuICB0aGlzLl9fd3JhcF9wb2ludF9hbGlnbm1lbnRfY291bnQgPSAwO1xuXG4gIHRoaXMuX19pdGVtcyA9IFtdO1xufVxuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5jbG9uZV9lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbGluZSA9IG5ldyBPdXRwdXRMaW5lKHRoaXMuX19wYXJlbnQpO1xuICBsaW5lLnNldF9pbmRlbnQodGhpcy5fX2luZGVudF9jb3VudCwgdGhpcy5fX2FsaWdubWVudF9jb3VudCk7XG4gIHJldHVybiBsaW5lO1xufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuaXRlbSA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gdGhpcy5fX2l0ZW1zW3RoaXMuX19pdGVtcy5sZW5ndGggKyBpbmRleF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuX19pdGVtc1tpbmRleF07XG4gIH1cbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLmhhc19tYXRjaCA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgZm9yICh2YXIgbGFzdENoZWNrZWRPdXRwdXQgPSB0aGlzLl9faXRlbXMubGVuZ3RoIC0gMTsgbGFzdENoZWNrZWRPdXRwdXQgPj0gMDsgbGFzdENoZWNrZWRPdXRwdXQtLSkge1xuICAgIGlmICh0aGlzLl9faXRlbXNbbGFzdENoZWNrZWRPdXRwdXRdLm1hdGNoKHBhdHRlcm4pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuc2V0X2luZGVudCA9IGZ1bmN0aW9uKGluZGVudCwgYWxpZ25tZW50KSB7XG4gIGlmICh0aGlzLmlzX2VtcHR5KCkpIHtcbiAgICB0aGlzLl9faW5kZW50X2NvdW50ID0gaW5kZW50IHx8IDA7XG4gICAgdGhpcy5fX2FsaWdubWVudF9jb3VudCA9IGFsaWdubWVudCB8fCAwO1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgPSB0aGlzLl9fcGFyZW50LmdldF9pbmRlbnRfc2l6ZSh0aGlzLl9faW5kZW50X2NvdW50LCB0aGlzLl9fYWxpZ25tZW50X2NvdW50KTtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuX3NldF93cmFwX3BvaW50ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9fcGFyZW50LndyYXBfbGluZV9sZW5ndGgpIHtcbiAgICB0aGlzLl9fd3JhcF9wb2ludF9pbmRleCA9IHRoaXMuX19pdGVtcy5sZW5ndGg7XG4gICAgdGhpcy5fX3dyYXBfcG9pbnRfY2hhcmFjdGVyX2NvdW50ID0gdGhpcy5fX2NoYXJhY3Rlcl9jb3VudDtcbiAgICB0aGlzLl9fd3JhcF9wb2ludF9pbmRlbnRfY291bnQgPSB0aGlzLl9fcGFyZW50Lm5leHRfbGluZS5fX2luZGVudF9jb3VudDtcbiAgICB0aGlzLl9fd3JhcF9wb2ludF9hbGlnbm1lbnRfY291bnQgPSB0aGlzLl9fcGFyZW50Lm5leHRfbGluZS5fX2FsaWdubWVudF9jb3VudDtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuX3Nob3VsZF93cmFwID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9fd3JhcF9wb2ludF9pbmRleCAmJlxuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgPiB0aGlzLl9fcGFyZW50LndyYXBfbGluZV9sZW5ndGggJiZcbiAgICB0aGlzLl9fd3JhcF9wb2ludF9jaGFyYWN0ZXJfY291bnQgPiB0aGlzLl9fcGFyZW50Lm5leHRfbGluZS5fX2NoYXJhY3Rlcl9jb3VudDtcbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLl9hbGxvd193cmFwID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9zaG91bGRfd3JhcCgpKSB7XG4gICAgdGhpcy5fX3BhcmVudC5hZGRfbmV3X2xpbmUoKTtcbiAgICB2YXIgbmV4dCA9IHRoaXMuX19wYXJlbnQuY3VycmVudF9saW5lO1xuICAgIG5leHQuc2V0X2luZGVudCh0aGlzLl9fd3JhcF9wb2ludF9pbmRlbnRfY291bnQsIHRoaXMuX193cmFwX3BvaW50X2FsaWdubWVudF9jb3VudCk7XG4gICAgbmV4dC5fX2l0ZW1zID0gdGhpcy5fX2l0ZW1zLnNsaWNlKHRoaXMuX193cmFwX3BvaW50X2luZGV4KTtcbiAgICB0aGlzLl9faXRlbXMgPSB0aGlzLl9faXRlbXMuc2xpY2UoMCwgdGhpcy5fX3dyYXBfcG9pbnRfaW5kZXgpO1xuXG4gICAgbmV4dC5fX2NoYXJhY3Rlcl9jb3VudCArPSB0aGlzLl9fY2hhcmFjdGVyX2NvdW50IC0gdGhpcy5fX3dyYXBfcG9pbnRfY2hhcmFjdGVyX2NvdW50O1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgPSB0aGlzLl9fd3JhcF9wb2ludF9jaGFyYWN0ZXJfY291bnQ7XG5cbiAgICBpZiAobmV4dC5fX2l0ZW1zWzBdID09PSBcIiBcIikge1xuICAgICAgbmV4dC5fX2l0ZW1zLnNwbGljZSgwLCAxKTtcbiAgICAgIG5leHQuX19jaGFyYWN0ZXJfY291bnQgLT0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuaXNfZW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX19pdGVtcy5sZW5ndGggPT09IDA7XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5pc19lbXB0eSgpKSB7XG4gICAgcmV0dXJuIHRoaXMuX19pdGVtc1t0aGlzLl9faXRlbXMubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihpdGVtKSB7XG4gIHRoaXMuX19pdGVtcy5wdXNoKGl0ZW0pO1xuICB2YXIgbGFzdF9uZXdsaW5lX2luZGV4ID0gaXRlbS5sYXN0SW5kZXhPZignXFxuJyk7XG4gIGlmIChsYXN0X25ld2xpbmVfaW5kZXggIT09IC0xKSB7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCA9IGl0ZW0ubGVuZ3RoIC0gbGFzdF9uZXdsaW5lX2luZGV4O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgKz0gaXRlbS5sZW5ndGg7XG4gIH1cbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbSA9IG51bGw7XG4gIGlmICghdGhpcy5pc19lbXB0eSgpKSB7XG4gICAgaXRlbSA9IHRoaXMuX19pdGVtcy5wb3AoKTtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50IC09IGl0ZW0ubGVuZ3RoO1xuICB9XG4gIHJldHVybiBpdGVtO1xufTtcblxuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5fcmVtb3ZlX2luZGVudCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fX2luZGVudF9jb3VudCA+IDApIHtcbiAgICB0aGlzLl9faW5kZW50X2NvdW50IC09IDE7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCAtPSB0aGlzLl9fcGFyZW50LmluZGVudF9zaXplO1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5fcmVtb3ZlX3dyYXBfaW5kZW50ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9fd3JhcF9wb2ludF9pbmRlbnRfY291bnQgPiAwKSB7XG4gICAgdGhpcy5fX3dyYXBfcG9pbnRfaW5kZW50X2NvdW50IC09IDE7XG4gIH1cbn07XG5PdXRwdXRMaW5lLnByb3RvdHlwZS50cmltID0gZnVuY3Rpb24oKSB7XG4gIHdoaWxlICh0aGlzLmxhc3QoKSA9PT0gJyAnKSB7XG4gICAgdGhpcy5fX2l0ZW1zLnBvcCgpO1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgLT0gMTtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhpcy5pc19lbXB0eSgpKSB7XG4gICAgaWYgKHRoaXMuX19wYXJlbnQuaW5kZW50X2VtcHR5X2xpbmVzKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLl9fcGFyZW50LmdldF9pbmRlbnRfc3RyaW5nKHRoaXMuX19pbmRlbnRfY291bnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSB0aGlzLl9fcGFyZW50LmdldF9pbmRlbnRfc3RyaW5nKHRoaXMuX19pbmRlbnRfY291bnQsIHRoaXMuX19hbGlnbm1lbnRfY291bnQpO1xuICAgIHJlc3VsdCArPSB0aGlzLl9faXRlbXMuam9pbignJyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmZ1bmN0aW9uIEluZGVudFN0cmluZ0NhY2hlKG9wdGlvbnMsIGJhc2VJbmRlbnRTdHJpbmcpIHtcbiAgdGhpcy5fX2NhY2hlID0gWycnXTtcbiAgdGhpcy5fX2luZGVudF9zaXplID0gb3B0aW9ucy5pbmRlbnRfc2l6ZTtcbiAgdGhpcy5fX2luZGVudF9zdHJpbmcgPSBvcHRpb25zLmluZGVudF9jaGFyO1xuICBpZiAoIW9wdGlvbnMuaW5kZW50X3dpdGhfdGFicykge1xuICAgIHRoaXMuX19pbmRlbnRfc3RyaW5nID0gbmV3IEFycmF5KG9wdGlvbnMuaW5kZW50X3NpemUgKyAxKS5qb2luKG9wdGlvbnMuaW5kZW50X2NoYXIpO1xuICB9XG5cbiAgLy8gU2V0IHRvIG51bGwgdG8gY29udGludWUgc3VwcG9ydCBmb3IgYXV0byBkZXRlY3Rpb24gb2YgYmFzZSBpbmRlbnRcbiAgYmFzZUluZGVudFN0cmluZyA9IGJhc2VJbmRlbnRTdHJpbmcgfHwgJyc7XG4gIGlmIChvcHRpb25zLmluZGVudF9sZXZlbCA+IDApIHtcbiAgICBiYXNlSW5kZW50U3RyaW5nID0gbmV3IEFycmF5KG9wdGlvbnMuaW5kZW50X2xldmVsICsgMSkuam9pbih0aGlzLl9faW5kZW50X3N0cmluZyk7XG4gIH1cblxuICB0aGlzLl9fYmFzZV9zdHJpbmcgPSBiYXNlSW5kZW50U3RyaW5nO1xuICB0aGlzLl9fYmFzZV9zdHJpbmdfbGVuZ3RoID0gYmFzZUluZGVudFN0cmluZy5sZW5ndGg7XG59XG5cbkluZGVudFN0cmluZ0NhY2hlLnByb3RvdHlwZS5nZXRfaW5kZW50X3NpemUgPSBmdW5jdGlvbihpbmRlbnQsIGNvbHVtbikge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fX2Jhc2Vfc3RyaW5nX2xlbmd0aDtcbiAgY29sdW1uID0gY29sdW1uIHx8IDA7XG4gIGlmIChpbmRlbnQgPCAwKSB7XG4gICAgcmVzdWx0ID0gMDtcbiAgfVxuICByZXN1bHQgKz0gaW5kZW50ICogdGhpcy5fX2luZGVudF9zaXplO1xuICByZXN1bHQgKz0gY29sdW1uO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuSW5kZW50U3RyaW5nQ2FjaGUucHJvdG90eXBlLmdldF9pbmRlbnRfc3RyaW5nID0gZnVuY3Rpb24oaW5kZW50X2xldmVsLCBjb2x1bW4pIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX19iYXNlX3N0cmluZztcbiAgY29sdW1uID0gY29sdW1uIHx8IDA7XG4gIGlmIChpbmRlbnRfbGV2ZWwgPCAwKSB7XG4gICAgaW5kZW50X2xldmVsID0gMDtcbiAgICByZXN1bHQgPSAnJztcbiAgfVxuICBjb2x1bW4gKz0gaW5kZW50X2xldmVsICogdGhpcy5fX2luZGVudF9zaXplO1xuICB0aGlzLl9fZW5zdXJlX2NhY2hlKGNvbHVtbik7XG4gIHJlc3VsdCArPSB0aGlzLl9fY2FjaGVbY29sdW1uXTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkluZGVudFN0cmluZ0NhY2hlLnByb3RvdHlwZS5fX2Vuc3VyZV9jYWNoZSA9IGZ1bmN0aW9uKGNvbHVtbikge1xuICB3aGlsZSAoY29sdW1uID49IHRoaXMuX19jYWNoZS5sZW5ndGgpIHtcbiAgICB0aGlzLl9fYWRkX2NvbHVtbigpO1xuICB9XG59O1xuXG5JbmRlbnRTdHJpbmdDYWNoZS5wcm90b3R5cGUuX19hZGRfY29sdW1uID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb2x1bW4gPSB0aGlzLl9fY2FjaGUubGVuZ3RoO1xuICB2YXIgaW5kZW50ID0gMDtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhpcy5fX2luZGVudF9zaXplICYmIGNvbHVtbiA+PSB0aGlzLl9faW5kZW50X3NpemUpIHtcbiAgICBpbmRlbnQgPSBNYXRoLmZsb29yKGNvbHVtbiAvIHRoaXMuX19pbmRlbnRfc2l6ZSk7XG4gICAgY29sdW1uIC09IGluZGVudCAqIHRoaXMuX19pbmRlbnRfc2l6ZTtcbiAgICByZXN1bHQgPSBuZXcgQXJyYXkoaW5kZW50ICsgMSkuam9pbih0aGlzLl9faW5kZW50X3N0cmluZyk7XG4gIH1cbiAgaWYgKGNvbHVtbikge1xuICAgIHJlc3VsdCArPSBuZXcgQXJyYXkoY29sdW1uICsgMSkuam9pbignICcpO1xuICB9XG5cbiAgdGhpcy5fX2NhY2hlLnB1c2gocmVzdWx0KTtcbn07XG5cbmZ1bmN0aW9uIE91dHB1dChvcHRpb25zLCBiYXNlSW5kZW50U3RyaW5nKSB7XG4gIHRoaXMuX19pbmRlbnRfY2FjaGUgPSBuZXcgSW5kZW50U3RyaW5nQ2FjaGUob3B0aW9ucywgYmFzZUluZGVudFN0cmluZyk7XG4gIHRoaXMucmF3ID0gZmFsc2U7XG4gIHRoaXMuX2VuZF93aXRoX25ld2xpbmUgPSBvcHRpb25zLmVuZF93aXRoX25ld2xpbmU7XG4gIHRoaXMuaW5kZW50X3NpemUgPSBvcHRpb25zLmluZGVudF9zaXplO1xuICB0aGlzLndyYXBfbGluZV9sZW5ndGggPSBvcHRpb25zLndyYXBfbGluZV9sZW5ndGg7XG4gIHRoaXMuaW5kZW50X2VtcHR5X2xpbmVzID0gb3B0aW9ucy5pbmRlbnRfZW1wdHlfbGluZXM7XG4gIHRoaXMuX19saW5lcyA9IFtdO1xuICB0aGlzLnByZXZpb3VzX2xpbmUgPSBudWxsO1xuICB0aGlzLmN1cnJlbnRfbGluZSA9IG51bGw7XG4gIHRoaXMubmV4dF9saW5lID0gbmV3IE91dHB1dExpbmUodGhpcyk7XG4gIHRoaXMuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gIHRoaXMubm9uX2JyZWFraW5nX3NwYWNlID0gZmFsc2U7XG4gIHRoaXMucHJldmlvdXNfdG9rZW5fd3JhcHBlZCA9IGZhbHNlO1xuICAvLyBpbml0aWFsaXplXG4gIHRoaXMuX19hZGRfb3V0cHV0bGluZSgpO1xufVxuXG5PdXRwdXQucHJvdG90eXBlLl9fYWRkX291dHB1dGxpbmUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5wcmV2aW91c19saW5lID0gdGhpcy5jdXJyZW50X2xpbmU7XG4gIHRoaXMuY3VycmVudF9saW5lID0gdGhpcy5uZXh0X2xpbmUuY2xvbmVfZW1wdHkoKTtcbiAgdGhpcy5fX2xpbmVzLnB1c2godGhpcy5jdXJyZW50X2xpbmUpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5nZXRfbGluZV9udW1iZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX19saW5lcy5sZW5ndGg7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmdldF9pbmRlbnRfc3RyaW5nID0gZnVuY3Rpb24oaW5kZW50LCBjb2x1bW4pIHtcbiAgcmV0dXJuIHRoaXMuX19pbmRlbnRfY2FjaGUuZ2V0X2luZGVudF9zdHJpbmcoaW5kZW50LCBjb2x1bW4pO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5nZXRfaW5kZW50X3NpemUgPSBmdW5jdGlvbihpbmRlbnQsIGNvbHVtbikge1xuICByZXR1cm4gdGhpcy5fX2luZGVudF9jYWNoZS5nZXRfaW5kZW50X3NpemUoaW5kZW50LCBjb2x1bW4pO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5pc19lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gIXRoaXMucHJldmlvdXNfbGluZSAmJiB0aGlzLmN1cnJlbnRfbGluZS5pc19lbXB0eSgpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5hZGRfbmV3X2xpbmUgPSBmdW5jdGlvbihmb3JjZV9uZXdsaW5lKSB7XG4gIC8vIG5ldmVyIG5ld2xpbmUgYXQgdGhlIHN0YXJ0IG9mIGZpbGVcbiAgLy8gb3RoZXJ3aXNlLCBuZXdsaW5lIG9ubHkgaWYgd2UgZGlkbid0IGp1c3QgYWRkIG9uZSBvciB3ZSdyZSBmb3JjZWRcbiAgaWYgKHRoaXMuaXNfZW1wdHkoKSB8fFxuICAgICghZm9yY2VfbmV3bGluZSAmJiB0aGlzLmp1c3RfYWRkZWRfbmV3bGluZSgpKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGlmIHJhdyBvdXRwdXQgaXMgZW5hYmxlZCwgZG9uJ3QgcHJpbnQgYWRkaXRpb25hbCBuZXdsaW5lcyxcbiAgLy8gYnV0IHN0aWxsIHJldHVybiBUcnVlIGFzIHRob3VnaCB5b3UgaGFkXG4gIGlmICghdGhpcy5yYXcpIHtcbiAgICB0aGlzLl9fYWRkX291dHB1dGxpbmUoKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuZ2V0X2NvZGUgPSBmdW5jdGlvbihlb2wpIHtcbiAgdGhpcy50cmltKHRydWUpO1xuXG4gIC8vIGhhbmRsZSBzb21lIGVkZ2UgY2FzZXMgd2hlcmUgdGhlIGxhc3QgdG9rZW5zXG4gIC8vIGhhcyB0ZXh0IHRoYXQgZW5kcyB3aXRoIG5ld2xpbmUocylcbiAgdmFyIGxhc3RfaXRlbSA9IHRoaXMuY3VycmVudF9saW5lLnBvcCgpO1xuICBpZiAobGFzdF9pdGVtKSB7XG4gICAgaWYgKGxhc3RfaXRlbVtsYXN0X2l0ZW0ubGVuZ3RoIC0gMV0gPT09ICdcXG4nKSB7XG4gICAgICBsYXN0X2l0ZW0gPSBsYXN0X2l0ZW0ucmVwbGFjZSgvXFxuKyQvZywgJycpO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKGxhc3RfaXRlbSk7XG4gIH1cblxuICBpZiAodGhpcy5fZW5kX3dpdGhfbmV3bGluZSkge1xuICAgIHRoaXMuX19hZGRfb3V0cHV0bGluZSgpO1xuICB9XG5cbiAgdmFyIHN3ZWV0X2NvZGUgPSB0aGlzLl9fbGluZXMuam9pbignXFxuJyk7XG5cbiAgaWYgKGVvbCAhPT0gJ1xcbicpIHtcbiAgICBzd2VldF9jb2RlID0gc3dlZXRfY29kZS5yZXBsYWNlKC9bXFxuXS9nLCBlb2wpO1xuICB9XG4gIHJldHVybiBzd2VldF9jb2RlO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5zZXRfd3JhcF9wb2ludCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmN1cnJlbnRfbGluZS5fc2V0X3dyYXBfcG9pbnQoKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuc2V0X2luZGVudCA9IGZ1bmN0aW9uKGluZGVudCwgYWxpZ25tZW50KSB7XG4gIGluZGVudCA9IGluZGVudCB8fCAwO1xuICBhbGlnbm1lbnQgPSBhbGlnbm1lbnQgfHwgMDtcblxuICAvLyBOZXh0IGxpbmUgc3RvcmVzIGFsaWdubWVudCB2YWx1ZXNcbiAgdGhpcy5uZXh0X2xpbmUuc2V0X2luZGVudChpbmRlbnQsIGFsaWdubWVudCk7XG5cbiAgLy8gTmV2ZXIgaW5kZW50IHlvdXIgZmlyc3Qgb3V0cHV0IGluZGVudCBhdCB0aGUgc3RhcnQgb2YgdGhlIGZpbGVcbiAgaWYgKHRoaXMuX19saW5lcy5sZW5ndGggPiAxKSB7XG4gICAgdGhpcy5jdXJyZW50X2xpbmUuc2V0X2luZGVudChpbmRlbnQsIGFsaWdubWVudCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB0aGlzLmN1cnJlbnRfbGluZS5zZXRfaW5kZW50KCk7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuYWRkX3Jhd190b2tlbiA9IGZ1bmN0aW9uKHRva2VuKSB7XG4gIGZvciAodmFyIHggPSAwOyB4IDwgdG9rZW4ubmV3bGluZXM7IHgrKykge1xuICAgIHRoaXMuX19hZGRfb3V0cHV0bGluZSgpO1xuICB9XG4gIHRoaXMuY3VycmVudF9saW5lLnNldF9pbmRlbnQoLTEpO1xuICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKHRva2VuLndoaXRlc3BhY2VfYmVmb3JlKTtcbiAgdGhpcy5jdXJyZW50X2xpbmUucHVzaCh0b2tlbi50ZXh0KTtcbiAgdGhpcy5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgdGhpcy5ub25fYnJlYWtpbmdfc3BhY2UgPSBmYWxzZTtcbiAgdGhpcy5wcmV2aW91c190b2tlbl93cmFwcGVkID0gZmFsc2U7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmFkZF90b2tlbiA9IGZ1bmN0aW9uKHByaW50YWJsZV90b2tlbikge1xuICB0aGlzLl9fYWRkX3NwYWNlX2JlZm9yZV90b2tlbigpO1xuICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKHByaW50YWJsZV90b2tlbik7XG4gIHRoaXMuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gIHRoaXMubm9uX2JyZWFraW5nX3NwYWNlID0gZmFsc2U7XG4gIHRoaXMucHJldmlvdXNfdG9rZW5fd3JhcHBlZCA9IHRoaXMuY3VycmVudF9saW5lLl9hbGxvd193cmFwKCk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLl9fYWRkX3NwYWNlX2JlZm9yZV90b2tlbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5zcGFjZV9iZWZvcmVfdG9rZW4gJiYgIXRoaXMuanVzdF9hZGRlZF9uZXdsaW5lKCkpIHtcbiAgICBpZiAoIXRoaXMubm9uX2JyZWFraW5nX3NwYWNlKSB7XG4gICAgICB0aGlzLnNldF93cmFwX3BvaW50KCk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudF9saW5lLnB1c2goJyAnKTtcbiAgfVxufTtcblxuT3V0cHV0LnByb3RvdHlwZS5yZW1vdmVfaW5kZW50ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgdmFyIG91dHB1dF9sZW5ndGggPSB0aGlzLl9fbGluZXMubGVuZ3RoO1xuICB3aGlsZSAoaW5kZXggPCBvdXRwdXRfbGVuZ3RoKSB7XG4gICAgdGhpcy5fX2xpbmVzW2luZGV4XS5fcmVtb3ZlX2luZGVudCgpO1xuICAgIGluZGV4Kys7XG4gIH1cbiAgdGhpcy5jdXJyZW50X2xpbmUuX3JlbW92ZV93cmFwX2luZGVudCgpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS50cmltID0gZnVuY3Rpb24oZWF0X25ld2xpbmVzKSB7XG4gIGVhdF9uZXdsaW5lcyA9IChlYXRfbmV3bGluZXMgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IGVhdF9uZXdsaW5lcztcblxuICB0aGlzLmN1cnJlbnRfbGluZS50cmltKCk7XG5cbiAgd2hpbGUgKGVhdF9uZXdsaW5lcyAmJiB0aGlzLl9fbGluZXMubGVuZ3RoID4gMSAmJlxuICAgIHRoaXMuY3VycmVudF9saW5lLmlzX2VtcHR5KCkpIHtcbiAgICB0aGlzLl9fbGluZXMucG9wKCk7XG4gICAgdGhpcy5jdXJyZW50X2xpbmUgPSB0aGlzLl9fbGluZXNbdGhpcy5fX2xpbmVzLmxlbmd0aCAtIDFdO1xuICAgIHRoaXMuY3VycmVudF9saW5lLnRyaW0oKTtcbiAgfVxuXG4gIHRoaXMucHJldmlvdXNfbGluZSA9IHRoaXMuX19saW5lcy5sZW5ndGggPiAxID9cbiAgICB0aGlzLl9fbGluZXNbdGhpcy5fX2xpbmVzLmxlbmd0aCAtIDJdIDogbnVsbDtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuanVzdF9hZGRlZF9uZXdsaW5lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmN1cnJlbnRfbGluZS5pc19lbXB0eSgpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5qdXN0X2FkZGVkX2JsYW5rbGluZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5pc19lbXB0eSgpIHx8XG4gICAgKHRoaXMuY3VycmVudF9saW5lLmlzX2VtcHR5KCkgJiYgdGhpcy5wcmV2aW91c19saW5lLmlzX2VtcHR5KCkpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5lbnN1cmVfZW1wdHlfbGluZV9hYm92ZSA9IGZ1bmN0aW9uKHN0YXJ0c193aXRoLCBlbmRzX3dpdGgpIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5fX2xpbmVzLmxlbmd0aCAtIDI7XG4gIHdoaWxlIChpbmRleCA+PSAwKSB7XG4gICAgdmFyIHBvdGVudGlhbEVtcHR5TGluZSA9IHRoaXMuX19saW5lc1tpbmRleF07XG4gICAgaWYgKHBvdGVudGlhbEVtcHR5TGluZS5pc19lbXB0eSgpKSB7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKHBvdGVudGlhbEVtcHR5TGluZS5pdGVtKDApLmluZGV4T2Yoc3RhcnRzX3dpdGgpICE9PSAwICYmXG4gICAgICBwb3RlbnRpYWxFbXB0eUxpbmUuaXRlbSgtMSkgIT09IGVuZHNfd2l0aCkge1xuICAgICAgdGhpcy5fX2xpbmVzLnNwbGljZShpbmRleCArIDEsIDAsIG5ldyBPdXRwdXRMaW5lKHRoaXMpKTtcbiAgICAgIHRoaXMucHJldmlvdXNfbGluZSA9IHRoaXMuX19saW5lc1t0aGlzLl9fbGluZXMubGVuZ3RoIC0gMl07XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaW5kZXgtLTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuT3V0cHV0ID0gT3V0cHV0O1xuXG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbmZ1bmN0aW9uIFRva2VuKHR5cGUsIHRleHQsIG5ld2xpbmVzLCB3aGl0ZXNwYWNlX2JlZm9yZSkge1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnRleHQgPSB0ZXh0O1xuXG4gIC8vIGNvbW1lbnRzX2JlZm9yZSBhcmVcbiAgLy8gY29tbWVudHMgdGhhdCBoYXZlIGEgbmV3IGxpbmUgYmVmb3JlIHRoZW1cbiAgLy8gYW5kIG1heSBvciBtYXkgbm90IGhhdmUgYSBuZXdsaW5lIGFmdGVyXG4gIC8vIHRoaXMgaXMgYSBzZXQgb2YgY29tbWVudHMgYmVmb3JlXG4gIHRoaXMuY29tbWVudHNfYmVmb3JlID0gbnVsbDsgLyogaW5saW5lIGNvbW1lbnQqL1xuXG5cbiAgLy8gdGhpcy5jb21tZW50c19hZnRlciA9ICBuZXcgVG9rZW5TdHJlYW0oKTsgLy8gbm8gbmV3IGxpbmUgYmVmb3JlIGFuZCBuZXdsaW5lIGFmdGVyXG4gIHRoaXMubmV3bGluZXMgPSBuZXdsaW5lcyB8fCAwO1xuICB0aGlzLndoaXRlc3BhY2VfYmVmb3JlID0gd2hpdGVzcGFjZV9iZWZvcmUgfHwgJyc7XG4gIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5wcmV2aW91cyA9IG51bGw7XG4gIHRoaXMub3BlbmVkID0gbnVsbDtcbiAgdGhpcy5jbG9zZWQgPSBudWxsO1xuICB0aGlzLmRpcmVjdGl2ZXMgPSBudWxsO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzLlRva2VuID0gVG9rZW47XG5cblxuLyoqKi8gfSksXG4vKiA0ICovLFxuLyogNSAqLyxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG5mdW5jdGlvbiBPcHRpb25zKG9wdGlvbnMsIG1lcmdlX2NoaWxkX2ZpZWxkKSB7XG4gIHRoaXMucmF3X29wdGlvbnMgPSBfbWVyZ2VPcHRzKG9wdGlvbnMsIG1lcmdlX2NoaWxkX2ZpZWxkKTtcblxuICAvLyBTdXBwb3J0IHBhc3NpbmcgdGhlIHNvdXJjZSB0ZXh0IGJhY2sgd2l0aCBubyBjaGFuZ2VcbiAgdGhpcy5kaXNhYmxlZCA9IHRoaXMuX2dldF9ib29sZWFuKCdkaXNhYmxlZCcpO1xuXG4gIHRoaXMuZW9sID0gdGhpcy5fZ2V0X2NoYXJhY3RlcnMoJ2VvbCcsICdhdXRvJyk7XG4gIHRoaXMuZW5kX3dpdGhfbmV3bGluZSA9IHRoaXMuX2dldF9ib29sZWFuKCdlbmRfd2l0aF9uZXdsaW5lJyk7XG4gIHRoaXMuaW5kZW50X3NpemUgPSB0aGlzLl9nZXRfbnVtYmVyKCdpbmRlbnRfc2l6ZScsIDQpO1xuICB0aGlzLmluZGVudF9jaGFyID0gdGhpcy5fZ2V0X2NoYXJhY3RlcnMoJ2luZGVudF9jaGFyJywgJyAnKTtcbiAgdGhpcy5pbmRlbnRfbGV2ZWwgPSB0aGlzLl9nZXRfbnVtYmVyKCdpbmRlbnRfbGV2ZWwnKTtcblxuICB0aGlzLnByZXNlcnZlX25ld2xpbmVzID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ3ByZXNlcnZlX25ld2xpbmVzJywgdHJ1ZSk7XG4gIHRoaXMubWF4X3ByZXNlcnZlX25ld2xpbmVzID0gdGhpcy5fZ2V0X251bWJlcignbWF4X3ByZXNlcnZlX25ld2xpbmVzJywgMzI3ODYpO1xuICBpZiAoIXRoaXMucHJlc2VydmVfbmV3bGluZXMpIHtcbiAgICB0aGlzLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcyA9IDA7XG4gIH1cblxuICB0aGlzLmluZGVudF93aXRoX3RhYnMgPSB0aGlzLl9nZXRfYm9vbGVhbignaW5kZW50X3dpdGhfdGFicycsIHRoaXMuaW5kZW50X2NoYXIgPT09ICdcXHQnKTtcbiAgaWYgKHRoaXMuaW5kZW50X3dpdGhfdGFicykge1xuICAgIHRoaXMuaW5kZW50X2NoYXIgPSAnXFx0JztcblxuICAgIC8vIGluZGVudF9zaXplIGJlaGF2aW9yIGNoYW5nZWQgYWZ0ZXIgMS44LjZcbiAgICAvLyBJdCB1c2VkIHRvIGJlIHRoYXQgaW5kZW50X3NpemUgd291bGQgYmVcbiAgICAvLyBzZXQgdG8gMSBmb3IgaW5kZW50X3dpdGhfdGFicy4gVGhhdCBpcyBubyBsb25nZXIgbmVlZGVkIGFuZFxuICAgIC8vIGFjdHVhbGx5IGRvZXNuJ3QgbWFrZSBzZW5zZSAtIHdoeSBub3QgdXNlIHNwYWNlcz8gRnVydGhlcixcbiAgICAvLyB0aGF0IG1pZ2h0IHByb2R1Y2UgdW5leHBlY3RlZCBiZWhhdmlvciAtIHRhYnMgYmVpbmcgdXNlZFxuICAgIC8vIGZvciBzaW5nbGUtY29sdW1uIGFsaWdubWVudC4gU28sIHdoZW4gaW5kZW50X3dpdGhfdGFicyBpcyB0cnVlXG4gICAgLy8gYW5kIGluZGVudF9zaXplIGlzIDEsIHJlc2V0IGluZGVudF9zaXplIHRvIDQuXG4gICAgaWYgKHRoaXMuaW5kZW50X3NpemUgPT09IDEpIHtcbiAgICAgIHRoaXMuaW5kZW50X3NpemUgPSA0O1xuICAgIH1cbiAgfVxuXG4gIC8vIEJhY2t3YXJkcyBjb21wYXQgd2l0aCAxLjMueFxuICB0aGlzLndyYXBfbGluZV9sZW5ndGggPSB0aGlzLl9nZXRfbnVtYmVyKCd3cmFwX2xpbmVfbGVuZ3RoJywgdGhpcy5fZ2V0X251bWJlcignbWF4X2NoYXInKSk7XG5cbiAgdGhpcy5pbmRlbnRfZW1wdHlfbGluZXMgPSB0aGlzLl9nZXRfYm9vbGVhbignaW5kZW50X2VtcHR5X2xpbmVzJyk7XG5cbiAgLy8gdmFsaWQgdGVtcGxhdGluZyBsYW5ndWFnZXMgWydkamFuZ28nLCAnZXJiJywgJ2hhbmRsZWJhcnMnLCAncGhwJywgJ3NtYXJ0eSddXG4gIC8vIEZvciBub3csICdhdXRvJyA9IGFsbCBvZmYgZm9yIGphdmFzY3JpcHQsIGFsbCBvbiBmb3IgaHRtbCAoYW5kIGlubGluZSBqYXZhc2NyaXB0KS5cbiAgLy8gb3RoZXIgdmFsdWVzIGlnbm9yZWRcbiAgdGhpcy50ZW1wbGF0aW5nID0gdGhpcy5fZ2V0X3NlbGVjdGlvbl9saXN0KCd0ZW1wbGF0aW5nJywgWydhdXRvJywgJ25vbmUnLCAnZGphbmdvJywgJ2VyYicsICdoYW5kbGViYXJzJywgJ3BocCcsICdzbWFydHknXSwgWydhdXRvJ10pO1xufVxuXG5PcHRpb25zLnByb3RvdHlwZS5fZ2V0X2FycmF5ID0gZnVuY3Rpb24obmFtZSwgZGVmYXVsdF92YWx1ZSkge1xuICB2YXIgb3B0aW9uX3ZhbHVlID0gdGhpcy5yYXdfb3B0aW9uc1tuYW1lXTtcbiAgdmFyIHJlc3VsdCA9IGRlZmF1bHRfdmFsdWUgfHwgW107XG4gIGlmICh0eXBlb2Ygb3B0aW9uX3ZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChvcHRpb25fdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIG9wdGlvbl92YWx1ZS5jb25jYXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlc3VsdCA9IG9wdGlvbl92YWx1ZS5jb25jYXQoKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbl92YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXN1bHQgPSBvcHRpb25fdmFsdWUuc3BsaXQoL1teYS16QS1aMC05X1xcL1xcLV0rLyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk9wdGlvbnMucHJvdG90eXBlLl9nZXRfYm9vbGVhbiA9IGZ1bmN0aW9uKG5hbWUsIGRlZmF1bHRfdmFsdWUpIHtcbiAgdmFyIG9wdGlvbl92YWx1ZSA9IHRoaXMucmF3X29wdGlvbnNbbmFtZV07XG4gIHZhciByZXN1bHQgPSBvcHRpb25fdmFsdWUgPT09IHVuZGVmaW5lZCA/ICEhZGVmYXVsdF92YWx1ZSA6ICEhb3B0aW9uX3ZhbHVlO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuT3B0aW9ucy5wcm90b3R5cGUuX2dldF9jaGFyYWN0ZXJzID0gZnVuY3Rpb24obmFtZSwgZGVmYXVsdF92YWx1ZSkge1xuICB2YXIgb3B0aW9uX3ZhbHVlID0gdGhpcy5yYXdfb3B0aW9uc1tuYW1lXTtcbiAgdmFyIHJlc3VsdCA9IGRlZmF1bHRfdmFsdWUgfHwgJyc7XG4gIGlmICh0eXBlb2Ygb3B0aW9uX3ZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJlc3VsdCA9IG9wdGlvbl92YWx1ZS5yZXBsYWNlKC9cXFxcci8sICdcXHInKS5yZXBsYWNlKC9cXFxcbi8sICdcXG4nKS5yZXBsYWNlKC9cXFxcdC8sICdcXHQnKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuT3B0aW9ucy5wcm90b3R5cGUuX2dldF9udW1iZXIgPSBmdW5jdGlvbihuYW1lLCBkZWZhdWx0X3ZhbHVlKSB7XG4gIHZhciBvcHRpb25fdmFsdWUgPSB0aGlzLnJhd19vcHRpb25zW25hbWVdO1xuICBkZWZhdWx0X3ZhbHVlID0gcGFyc2VJbnQoZGVmYXVsdF92YWx1ZSwgMTApO1xuICBpZiAoaXNOYU4oZGVmYXVsdF92YWx1ZSkpIHtcbiAgICBkZWZhdWx0X3ZhbHVlID0gMDtcbiAgfVxuICB2YXIgcmVzdWx0ID0gcGFyc2VJbnQob3B0aW9uX3ZhbHVlLCAxMCk7XG4gIGlmIChpc05hTihyZXN1bHQpKSB7XG4gICAgcmVzdWx0ID0gZGVmYXVsdF92YWx1ZTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuT3B0aW9ucy5wcm90b3R5cGUuX2dldF9zZWxlY3Rpb24gPSBmdW5jdGlvbihuYW1lLCBzZWxlY3Rpb25fbGlzdCwgZGVmYXVsdF92YWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fZ2V0X3NlbGVjdGlvbl9saXN0KG5hbWUsIHNlbGVjdGlvbl9saXN0LCBkZWZhdWx0X3ZhbHVlKTtcbiAgaWYgKHJlc3VsdC5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkludmFsaWQgT3B0aW9uIFZhbHVlOiBUaGUgb3B0aW9uICdcIiArIG5hbWUgKyBcIicgY2FuIG9ubHkgYmUgb25lIG9mIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxcblwiICtcbiAgICAgIHNlbGVjdGlvbl9saXN0ICsgXCJcXG5Zb3UgcGFzc2VkIGluOiAnXCIgKyB0aGlzLnJhd19vcHRpb25zW25hbWVdICsgXCInXCIpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFswXTtcbn07XG5cblxuT3B0aW9ucy5wcm90b3R5cGUuX2dldF9zZWxlY3Rpb25fbGlzdCA9IGZ1bmN0aW9uKG5hbWUsIHNlbGVjdGlvbl9saXN0LCBkZWZhdWx0X3ZhbHVlKSB7XG4gIGlmICghc2VsZWN0aW9uX2xpc3QgfHwgc2VsZWN0aW9uX2xpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2VsZWN0aW9uIGxpc3QgY2Fubm90IGJlIGVtcHR5LlwiKTtcbiAgfVxuXG4gIGRlZmF1bHRfdmFsdWUgPSBkZWZhdWx0X3ZhbHVlIHx8IFtzZWxlY3Rpb25fbGlzdFswXV07XG4gIGlmICghdGhpcy5faXNfdmFsaWRfc2VsZWN0aW9uKGRlZmF1bHRfdmFsdWUsIHNlbGVjdGlvbl9saXN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgRGVmYXVsdCBWYWx1ZSFcIik7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gdGhpcy5fZ2V0X2FycmF5KG5hbWUsIGRlZmF1bHRfdmFsdWUpO1xuICBpZiAoIXRoaXMuX2lzX3ZhbGlkX3NlbGVjdGlvbihyZXN1bHQsIHNlbGVjdGlvbl9saXN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiSW52YWxpZCBPcHRpb24gVmFsdWU6IFRoZSBvcHRpb24gJ1wiICsgbmFtZSArIFwiJyBjYW4gY29udGFpbiBvbmx5IHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxcblwiICtcbiAgICAgIHNlbGVjdGlvbl9saXN0ICsgXCJcXG5Zb3UgcGFzc2VkIGluOiAnXCIgKyB0aGlzLnJhd19vcHRpb25zW25hbWVdICsgXCInXCIpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbk9wdGlvbnMucHJvdG90eXBlLl9pc192YWxpZF9zZWxlY3Rpb24gPSBmdW5jdGlvbihyZXN1bHQsIHNlbGVjdGlvbl9saXN0KSB7XG4gIHJldHVybiByZXN1bHQubGVuZ3RoICYmIHNlbGVjdGlvbl9saXN0Lmxlbmd0aCAmJlxuICAgICFyZXN1bHQuc29tZShmdW5jdGlvbihpdGVtKSB7IHJldHVybiBzZWxlY3Rpb25fbGlzdC5pbmRleE9mKGl0ZW0pID09PSAtMTsgfSk7XG59O1xuXG5cbi8vIG1lcmdlcyBjaGlsZCBvcHRpb25zIHVwIHdpdGggdGhlIHBhcmVudCBvcHRpb25zIG9iamVjdFxuLy8gRXhhbXBsZTogb2JqID0ge2E6IDEsIGI6IHthOiAyfX1cbi8vICAgICAgICAgIG1lcmdlT3B0cyhvYmosICdiJylcbi8vXG4vLyAgICAgICAgICBSZXR1cm5zOiB7YTogMn1cbmZ1bmN0aW9uIF9tZXJnZU9wdHMoYWxsT3B0aW9ucywgY2hpbGRGaWVsZE5hbWUpIHtcbiAgdmFyIGZpbmFsT3B0cyA9IHt9O1xuICBhbGxPcHRpb25zID0gX25vcm1hbGl6ZU9wdHMoYWxsT3B0aW9ucyk7XG4gIHZhciBuYW1lO1xuXG4gIGZvciAobmFtZSBpbiBhbGxPcHRpb25zKSB7XG4gICAgaWYgKG5hbWUgIT09IGNoaWxkRmllbGROYW1lKSB7XG4gICAgICBmaW5hbE9wdHNbbmFtZV0gPSBhbGxPcHRpb25zW25hbWVdO1xuICAgIH1cbiAgfVxuXG4gIC8vbWVyZ2UgaW4gdGhlIHBlciB0eXBlIHNldHRpbmdzIGZvciB0aGUgY2hpbGRGaWVsZE5hbWVcbiAgaWYgKGNoaWxkRmllbGROYW1lICYmIGFsbE9wdGlvbnNbY2hpbGRGaWVsZE5hbWVdKSB7XG4gICAgZm9yIChuYW1lIGluIGFsbE9wdGlvbnNbY2hpbGRGaWVsZE5hbWVdKSB7XG4gICAgICBmaW5hbE9wdHNbbmFtZV0gPSBhbGxPcHRpb25zW2NoaWxkRmllbGROYW1lXVtuYW1lXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZpbmFsT3B0cztcbn1cblxuZnVuY3Rpb24gX25vcm1hbGl6ZU9wdHMob3B0aW9ucykge1xuICB2YXIgY29udmVydGVkT3B0cyA9IHt9O1xuICB2YXIga2V5O1xuXG4gIGZvciAoa2V5IGluIG9wdGlvbnMpIHtcbiAgICB2YXIgbmV3S2V5ID0ga2V5LnJlcGxhY2UoLy0vZywgXCJfXCIpO1xuICAgIGNvbnZlcnRlZE9wdHNbbmV3S2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgfVxuICByZXR1cm4gY29udmVydGVkT3B0cztcbn1cblxubW9kdWxlLmV4cG9ydHMuT3B0aW9ucyA9IE9wdGlvbnM7XG5tb2R1bGUuZXhwb3J0cy5ub3JtYWxpemVPcHRzID0gX25vcm1hbGl6ZU9wdHM7XG5tb2R1bGUuZXhwb3J0cy5tZXJnZU9wdHMgPSBfbWVyZ2VPcHRzO1xuXG5cbi8qKiovIH0pLFxuLyogNyAqLyxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG52YXIgcmVnZXhwX2hhc19zdGlja3kgPSBSZWdFeHAucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdzdGlja3knKTtcblxuZnVuY3Rpb24gSW5wdXRTY2FubmVyKGlucHV0X3N0cmluZykge1xuICB0aGlzLl9faW5wdXQgPSBpbnB1dF9zdHJpbmcgfHwgJyc7XG4gIHRoaXMuX19pbnB1dF9sZW5ndGggPSB0aGlzLl9faW5wdXQubGVuZ3RoO1xuICB0aGlzLl9fcG9zaXRpb24gPSAwO1xufVxuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnJlc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fX3Bvc2l0aW9uID0gMDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUuYmFjayA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fX3Bvc2l0aW9uID4gMCkge1xuICAgIHRoaXMuX19wb3NpdGlvbiAtPSAxO1xuICB9XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLmhhc05leHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX19wb3NpdGlvbiA8IHRoaXMuX19pbnB1dF9sZW5ndGg7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHZhbCA9IG51bGw7XG4gIGlmICh0aGlzLmhhc05leHQoKSkge1xuICAgIHZhbCA9IHRoaXMuX19pbnB1dC5jaGFyQXQodGhpcy5fX3Bvc2l0aW9uKTtcbiAgICB0aGlzLl9fcG9zaXRpb24gKz0gMTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgdmFyIHZhbCA9IG51bGw7XG4gIGluZGV4ID0gaW5kZXggfHwgMDtcbiAgaW5kZXggKz0gdGhpcy5fX3Bvc2l0aW9uO1xuICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuX19pbnB1dF9sZW5ndGgpIHtcbiAgICB2YWwgPSB0aGlzLl9faW5wdXQuY2hhckF0KGluZGV4KTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuLy8gVGhpcyBpcyBhIEphdmFTY3JpcHQgb25seSBoZWxwZXIgZnVuY3Rpb24gKG5vdCBpbiBweXRob24pXG4vLyBKYXZhc2NyaXB0IGRvZXNuJ3QgaGF2ZSBhIG1hdGNoIG1ldGhvZFxuLy8gYW5kIG5vdCBhbGwgaW1wbGVtZW50YXRpb24gc3VwcG9ydCBcInN0aWNreVwiIGZsYWcuXG4vLyBJZiB0aGV5IGRvIG5vdCBzdXBwb3J0IHN0aWNreSB0aGVuIGJvdGggdGhpcy5tYXRjaCgpIGFuZCB0aGlzLnRlc3QoKSBtZXRob2Rcbi8vIG11c3QgZ2V0IHRoZSBtYXRjaCBhbmQgY2hlY2sgdGhlIGluZGV4IG9mIHRoZSBtYXRjaC5cbi8vIElmIHN0aWNreSBpcyBzdXBwb3J0ZWQgYW5kIHNldCwgdGhpcyBtZXRob2Qgd2lsbCB1c2UgaXQuXG4vLyBPdGhlcndpc2UgaXQgd2lsbCBjaGVjayB0aGF0IGdsb2JhbCBpcyBzZXQsIGFuZCBmYWxsIGJhY2sgdG8gdGhlIHNsb3dlciBtZXRob2QuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLl9fbWF0Y2ggPSBmdW5jdGlvbihwYXR0ZXJuLCBpbmRleCkge1xuICBwYXR0ZXJuLmxhc3RJbmRleCA9IGluZGV4O1xuICB2YXIgcGF0dGVybl9tYXRjaCA9IHBhdHRlcm4uZXhlYyh0aGlzLl9faW5wdXQpO1xuXG4gIGlmIChwYXR0ZXJuX21hdGNoICYmICEocmVnZXhwX2hhc19zdGlja3kgJiYgcGF0dGVybi5zdGlja3kpKSB7XG4gICAgaWYgKHBhdHRlcm5fbWF0Y2guaW5kZXggIT09IGluZGV4KSB7XG4gICAgICBwYXR0ZXJuX21hdGNoID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGF0dGVybl9tYXRjaDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uKHBhdHRlcm4sIGluZGV4KSB7XG4gIGluZGV4ID0gaW5kZXggfHwgMDtcbiAgaW5kZXggKz0gdGhpcy5fX3Bvc2l0aW9uO1xuXG4gIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fX2lucHV0X2xlbmd0aCkge1xuICAgIHJldHVybiAhIXRoaXMuX19tYXRjaChwYXR0ZXJuLCBpbmRleCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnRlc3RDaGFyID0gZnVuY3Rpb24ocGF0dGVybiwgaW5kZXgpIHtcbiAgLy8gdGVzdCBvbmUgY2hhcmFjdGVyIHJlZ2V4IG1hdGNoXG4gIHZhciB2YWwgPSB0aGlzLnBlZWsoaW5kZXgpO1xuICBwYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgcGF0dGVybi50ZXN0KHZhbCk7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgcGF0dGVybl9tYXRjaCA9IHRoaXMuX19tYXRjaChwYXR0ZXJuLCB0aGlzLl9fcG9zaXRpb24pO1xuICBpZiAocGF0dGVybl9tYXRjaCkge1xuICAgIHRoaXMuX19wb3NpdGlvbiArPSBwYXR0ZXJuX21hdGNoWzBdLmxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICBwYXR0ZXJuX21hdGNoID0gbnVsbDtcbiAgfVxuICByZXR1cm4gcGF0dGVybl9tYXRjaDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKHN0YXJ0aW5nX3BhdHRlcm4sIHVudGlsX3BhdHRlcm4sIHVudGlsX2FmdGVyKSB7XG4gIHZhciB2YWwgPSAnJztcbiAgdmFyIG1hdGNoO1xuICBpZiAoc3RhcnRpbmdfcGF0dGVybikge1xuICAgIG1hdGNoID0gdGhpcy5tYXRjaChzdGFydGluZ19wYXR0ZXJuKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhbCArPSBtYXRjaFswXTtcbiAgICB9XG4gIH1cbiAgaWYgKHVudGlsX3BhdHRlcm4gJiYgKG1hdGNoIHx8ICFzdGFydGluZ19wYXR0ZXJuKSkge1xuICAgIHZhbCArPSB0aGlzLnJlYWRVbnRpbCh1bnRpbF9wYXR0ZXJuLCB1bnRpbF9hZnRlcik7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUucmVhZFVudGlsID0gZnVuY3Rpb24ocGF0dGVybiwgdW50aWxfYWZ0ZXIpIHtcbiAgdmFyIHZhbCA9ICcnO1xuICB2YXIgbWF0Y2hfaW5kZXggPSB0aGlzLl9fcG9zaXRpb247XG4gIHBhdHRlcm4ubGFzdEluZGV4ID0gdGhpcy5fX3Bvc2l0aW9uO1xuICB2YXIgcGF0dGVybl9tYXRjaCA9IHBhdHRlcm4uZXhlYyh0aGlzLl9faW5wdXQpO1xuICBpZiAocGF0dGVybl9tYXRjaCkge1xuICAgIG1hdGNoX2luZGV4ID0gcGF0dGVybl9tYXRjaC5pbmRleDtcbiAgICBpZiAodW50aWxfYWZ0ZXIpIHtcbiAgICAgIG1hdGNoX2luZGV4ICs9IHBhdHRlcm5fbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXRjaF9pbmRleCA9IHRoaXMuX19pbnB1dF9sZW5ndGg7XG4gIH1cblxuICB2YWwgPSB0aGlzLl9faW5wdXQuc3Vic3RyaW5nKHRoaXMuX19wb3NpdGlvbiwgbWF0Y2hfaW5kZXgpO1xuICB0aGlzLl9fcG9zaXRpb24gPSBtYXRjaF9pbmRleDtcbiAgcmV0dXJuIHZhbDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUucmVhZFVudGlsQWZ0ZXIgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHJldHVybiB0aGlzLnJlYWRVbnRpbChwYXR0ZXJuLCB0cnVlKTtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUuZ2V0X3JlZ2V4cCA9IGZ1bmN0aW9uKHBhdHRlcm4sIG1hdGNoX2Zyb20pIHtcbiAgdmFyIHJlc3VsdCA9IG51bGw7XG4gIHZhciBmbGFncyA9ICdnJztcbiAgaWYgKG1hdGNoX2Zyb20gJiYgcmVnZXhwX2hhc19zdGlja3kpIHtcbiAgICBmbGFncyA9ICd5JztcbiAgfVxuICAvLyBzdHJpbmdzIGFyZSBjb252ZXJ0ZWQgdG8gcmVnZXhwXG4gIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gXCJzdHJpbmdcIiAmJiBwYXR0ZXJuICE9PSAnJykge1xuICAgIC8vIHJlc3VsdCA9IG5ldyBSZWdFeHAocGF0dGVybi5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKSwgZmxhZ3MpO1xuICAgIHJlc3VsdCA9IG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xuICB9IGVsc2UgaWYgKHBhdHRlcm4pIHtcbiAgICByZXN1bHQgPSBuZXcgUmVnRXhwKHBhdHRlcm4uc291cmNlLCBmbGFncyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUuZ2V0X2xpdGVyYWxfcmVnZXhwID0gZnVuY3Rpb24obGl0ZXJhbF9zdHJpbmcpIHtcbiAgcmV0dXJuIFJlZ0V4cChsaXRlcmFsX3N0cmluZy5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKSk7XG59O1xuXG4vKiBjc3MgYmVhdXRpZmllciBsZWdhY3kgaGVscGVycyAqL1xuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5wZWVrVW50aWxBZnRlciA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5fX3Bvc2l0aW9uO1xuICB2YXIgdmFsID0gdGhpcy5yZWFkVW50aWxBZnRlcihwYXR0ZXJuKTtcbiAgdGhpcy5fX3Bvc2l0aW9uID0gc3RhcnQ7XG4gIHJldHVybiB2YWw7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLmxvb2tCYWNrID0gZnVuY3Rpb24odGVzdFZhbCkge1xuICB2YXIgc3RhcnQgPSB0aGlzLl9fcG9zaXRpb24gLSAxO1xuICByZXR1cm4gc3RhcnQgPj0gdGVzdFZhbC5sZW5ndGggJiYgdGhpcy5fX2lucHV0LnN1YnN0cmluZyhzdGFydCAtIHRlc3RWYWwubGVuZ3RoLCBzdGFydClcbiAgICAudG9Mb3dlckNhc2UoKSA9PT0gdGVzdFZhbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzLklucHV0U2Nhbm5lciA9IElucHV0U2Nhbm5lcjtcblxuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciBJbnB1dFNjYW5uZXIgPSAoX193ZWJwYWNrX3JlcXVpcmVfXyg4KS5JbnB1dFNjYW5uZXIpO1xudmFyIFRva2VuID0gKF9fd2VicGFja19yZXF1aXJlX18oMykuVG9rZW4pO1xudmFyIFRva2VuU3RyZWFtID0gKF9fd2VicGFja19yZXF1aXJlX18oMTApLlRva2VuU3RyZWFtKTtcbnZhciBXaGl0ZXNwYWNlUGF0dGVybiA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDExKS5XaGl0ZXNwYWNlUGF0dGVybik7XG5cbnZhciBUT0tFTiA9IHtcbiAgU1RBUlQ6ICdUS19TVEFSVCcsXG4gIFJBVzogJ1RLX1JBVycsXG4gIEVPRjogJ1RLX0VPRidcbn07XG5cbnZhciBUb2tlbml6ZXIgPSBmdW5jdGlvbihpbnB1dF9zdHJpbmcsIG9wdGlvbnMpIHtcbiAgdGhpcy5faW5wdXQgPSBuZXcgSW5wdXRTY2FubmVyKGlucHV0X3N0cmluZyk7XG4gIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLl9fdG9rZW5zID0gbnVsbDtcblxuICB0aGlzLl9wYXR0ZXJucyA9IHt9O1xuICB0aGlzLl9wYXR0ZXJucy53aGl0ZXNwYWNlID0gbmV3IFdoaXRlc3BhY2VQYXR0ZXJuKHRoaXMuX2lucHV0KTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5faW5wdXQucmVzdGFydCgpO1xuICB0aGlzLl9fdG9rZW5zID0gbmV3IFRva2VuU3RyZWFtKCk7XG5cbiAgdGhpcy5fcmVzZXQoKTtcblxuICB2YXIgY3VycmVudDtcbiAgdmFyIHByZXZpb3VzID0gbmV3IFRva2VuKFRPS0VOLlNUQVJULCAnJyk7XG4gIHZhciBvcGVuX3Rva2VuID0gbnVsbDtcbiAgdmFyIG9wZW5fc3RhY2sgPSBbXTtcbiAgdmFyIGNvbW1lbnRzID0gbmV3IFRva2VuU3RyZWFtKCk7XG5cbiAgd2hpbGUgKHByZXZpb3VzLnR5cGUgIT09IFRPS0VOLkVPRikge1xuICAgIGN1cnJlbnQgPSB0aGlzLl9nZXRfbmV4dF90b2tlbihwcmV2aW91cywgb3Blbl90b2tlbik7XG4gICAgd2hpbGUgKHRoaXMuX2lzX2NvbW1lbnQoY3VycmVudCkpIHtcbiAgICAgIGNvbW1lbnRzLmFkZChjdXJyZW50KTtcbiAgICAgIGN1cnJlbnQgPSB0aGlzLl9nZXRfbmV4dF90b2tlbihwcmV2aW91cywgb3Blbl90b2tlbik7XG4gICAgfVxuXG4gICAgaWYgKCFjb21tZW50cy5pc0VtcHR5KCkpIHtcbiAgICAgIGN1cnJlbnQuY29tbWVudHNfYmVmb3JlID0gY29tbWVudHM7XG4gICAgICBjb21tZW50cyA9IG5ldyBUb2tlblN0cmVhbSgpO1xuICAgIH1cblxuICAgIGN1cnJlbnQucGFyZW50ID0gb3Blbl90b2tlbjtcblxuICAgIGlmICh0aGlzLl9pc19vcGVuaW5nKGN1cnJlbnQpKSB7XG4gICAgICBvcGVuX3N0YWNrLnB1c2gob3Blbl90b2tlbik7XG4gICAgICBvcGVuX3Rva2VuID0gY3VycmVudDtcbiAgICB9IGVsc2UgaWYgKG9wZW5fdG9rZW4gJiYgdGhpcy5faXNfY2xvc2luZyhjdXJyZW50LCBvcGVuX3Rva2VuKSkge1xuICAgICAgY3VycmVudC5vcGVuZWQgPSBvcGVuX3Rva2VuO1xuICAgICAgb3Blbl90b2tlbi5jbG9zZWQgPSBjdXJyZW50O1xuICAgICAgb3Blbl90b2tlbiA9IG9wZW5fc3RhY2sucG9wKCk7XG4gICAgICBjdXJyZW50LnBhcmVudCA9IG9wZW5fdG9rZW47XG4gICAgfVxuXG4gICAgY3VycmVudC5wcmV2aW91cyA9IHByZXZpb3VzO1xuICAgIHByZXZpb3VzLm5leHQgPSBjdXJyZW50O1xuXG4gICAgdGhpcy5fX3Rva2Vucy5hZGQoY3VycmVudCk7XG4gICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX190b2tlbnM7XG59O1xuXG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX2ZpcnN0X3Rva2VuID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9fdG9rZW5zLmlzRW1wdHkoKTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24oKSB7fTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fZ2V0X25leHRfdG9rZW4gPSBmdW5jdGlvbihwcmV2aW91c190b2tlbiwgb3Blbl90b2tlbikgeyAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5faW5wdXQucmVhZCgvLisvZyk7XG4gIGlmIChyZXN1bHRpbmdfc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5SQVcsIHJlc3VsdGluZ19zdHJpbmcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uRU9GLCAnJyk7XG4gIH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX2NvbW1lbnQgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7IC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5faXNfb3BlbmluZyA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHsgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9pc19jbG9zaW5nID0gZnVuY3Rpb24oY3VycmVudF90b2tlbiwgb3Blbl90b2tlbikgeyAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHJldHVybiBmYWxzZTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2NyZWF0ZV90b2tlbiA9IGZ1bmN0aW9uKHR5cGUsIHRleHQpIHtcbiAgdmFyIHRva2VuID0gbmV3IFRva2VuKHR5cGUsIHRleHQsXG4gICAgdGhpcy5fcGF0dGVybnMud2hpdGVzcGFjZS5uZXdsaW5lX2NvdW50LFxuICAgIHRoaXMuX3BhdHRlcm5zLndoaXRlc3BhY2Uud2hpdGVzcGFjZV9iZWZvcmVfdG9rZW4pO1xuICByZXR1cm4gdG9rZW47XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkV2hpdGVzcGFjZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcGF0dGVybnMud2hpdGVzcGFjZS5yZWFkKCk7XG59O1xuXG5cblxubW9kdWxlLmV4cG9ydHMuVG9rZW5pemVyID0gVG9rZW5pemVyO1xubW9kdWxlLmV4cG9ydHMuVE9LRU4gPSBUT0tFTjtcblxuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxuZnVuY3Rpb24gVG9rZW5TdHJlYW0ocGFyZW50X3Rva2VuKSB7XG4gIC8vIHByaXZhdGVcbiAgdGhpcy5fX3Rva2VucyA9IFtdO1xuICB0aGlzLl9fdG9rZW5zX2xlbmd0aCA9IHRoaXMuX190b2tlbnMubGVuZ3RoO1xuICB0aGlzLl9fcG9zaXRpb24gPSAwO1xuICB0aGlzLl9fcGFyZW50X3Rva2VuID0gcGFyZW50X3Rva2VuO1xufVxuXG5Ub2tlblN0cmVhbS5wcm90b3R5cGUucmVzdGFydCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9fcG9zaXRpb24gPSAwO1xufTtcblxuVG9rZW5TdHJlYW0ucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX190b2tlbnNfbGVuZ3RoID09PSAwO1xufTtcblxuVG9rZW5TdHJlYW0ucHJvdG90eXBlLmhhc05leHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX19wb3NpdGlvbiA8IHRoaXMuX190b2tlbnNfbGVuZ3RoO1xufTtcblxuVG9rZW5TdHJlYW0ucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHZhbCA9IG51bGw7XG4gIGlmICh0aGlzLmhhc05leHQoKSkge1xuICAgIHZhbCA9IHRoaXMuX190b2tlbnNbdGhpcy5fX3Bvc2l0aW9uXTtcbiAgICB0aGlzLl9fcG9zaXRpb24gKz0gMTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuVG9rZW5TdHJlYW0ucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbihpbmRleCkge1xuICB2YXIgdmFsID0gbnVsbDtcbiAgaW5kZXggPSBpbmRleCB8fCAwO1xuICBpbmRleCArPSB0aGlzLl9fcG9zaXRpb247XG4gIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fX3Rva2Vuc19sZW5ndGgpIHtcbiAgICB2YWwgPSB0aGlzLl9fdG9rZW5zW2luZGV4XTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuVG9rZW5TdHJlYW0ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHRva2VuKSB7XG4gIGlmICh0aGlzLl9fcGFyZW50X3Rva2VuKSB7XG4gICAgdG9rZW4ucGFyZW50ID0gdGhpcy5fX3BhcmVudF90b2tlbjtcbiAgfVxuICB0aGlzLl9fdG9rZW5zLnB1c2godG9rZW4pO1xuICB0aGlzLl9fdG9rZW5zX2xlbmd0aCArPSAxO1xufTtcblxubW9kdWxlLmV4cG9ydHMuVG9rZW5TdHJlYW0gPSBUb2tlblN0cmVhbTtcblxuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG52YXIgUGF0dGVybiA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKS5QYXR0ZXJuKTtcblxuZnVuY3Rpb24gV2hpdGVzcGFjZVBhdHRlcm4oaW5wdXRfc2Nhbm5lciwgcGFyZW50KSB7XG4gIFBhdHRlcm4uY2FsbCh0aGlzLCBpbnB1dF9zY2FubmVyLCBwYXJlbnQpO1xuICBpZiAocGFyZW50KSB7XG4gICAgdGhpcy5fbGluZV9yZWdleHAgPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhcmVudC5fbGluZV9yZWdleHApO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX19zZXRfd2hpdGVzcGFjZV9wYXR0ZXJucygnJywgJycpO1xuICB9XG5cbiAgdGhpcy5uZXdsaW5lX2NvdW50ID0gMDtcbiAgdGhpcy53aGl0ZXNwYWNlX2JlZm9yZV90b2tlbiA9ICcnO1xufVxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlID0gbmV3IFBhdHRlcm4oKTtcblxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlLl9fc2V0X3doaXRlc3BhY2VfcGF0dGVybnMgPSBmdW5jdGlvbih3aGl0ZXNwYWNlX2NoYXJzLCBuZXdsaW5lX2NoYXJzKSB7XG4gIHdoaXRlc3BhY2VfY2hhcnMgKz0gJ1xcXFx0ICc7XG4gIG5ld2xpbmVfY2hhcnMgKz0gJ1xcXFxuXFxcXHInO1xuXG4gIHRoaXMuX21hdGNoX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKFxuICAgICdbJyArIHdoaXRlc3BhY2VfY2hhcnMgKyBuZXdsaW5lX2NoYXJzICsgJ10rJywgdHJ1ZSk7XG4gIHRoaXMuX25ld2xpbmVfcmVnZXhwID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChcbiAgICAnXFxcXHJcXFxcbnxbJyArIG5ld2xpbmVfY2hhcnMgKyAnXScpO1xufTtcblxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5uZXdsaW5lX2NvdW50ID0gMDtcbiAgdGhpcy53aGl0ZXNwYWNlX2JlZm9yZV90b2tlbiA9ICcnO1xuXG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5faW5wdXQucmVhZCh0aGlzLl9tYXRjaF9wYXR0ZXJuKTtcbiAgaWYgKHJlc3VsdGluZ19zdHJpbmcgPT09ICcgJykge1xuICAgIHRoaXMud2hpdGVzcGFjZV9iZWZvcmVfdG9rZW4gPSAnICc7XG4gIH0gZWxzZSBpZiAocmVzdWx0aW5nX3N0cmluZykge1xuICAgIHZhciBtYXRjaGVzID0gdGhpcy5fX3NwbGl0KHRoaXMuX25ld2xpbmVfcmVnZXhwLCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICB0aGlzLm5ld2xpbmVfY291bnQgPSBtYXRjaGVzLmxlbmd0aCAtIDE7XG4gICAgdGhpcy53aGl0ZXNwYWNlX2JlZm9yZV90b2tlbiA9IG1hdGNoZXNbdGhpcy5uZXdsaW5lX2NvdW50XTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHRpbmdfc3RyaW5nO1xufTtcblxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlLm1hdGNoaW5nID0gZnVuY3Rpb24od2hpdGVzcGFjZV9jaGFycywgbmV3bGluZV9jaGFycykge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fY3JlYXRlKCk7XG4gIHJlc3VsdC5fX3NldF93aGl0ZXNwYWNlX3BhdHRlcm5zKHdoaXRlc3BhY2VfY2hhcnMsIG5ld2xpbmVfY2hhcnMpO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBXaGl0ZXNwYWNlUGF0dGVybih0aGlzLl9pbnB1dCwgdGhpcyk7XG59O1xuXG5XaGl0ZXNwYWNlUGF0dGVybi5wcm90b3R5cGUuX19zcGxpdCA9IGZ1bmN0aW9uKHJlZ2V4cCwgaW5wdXRfc3RyaW5nKSB7XG4gIHJlZ2V4cC5sYXN0SW5kZXggPSAwO1xuICB2YXIgc3RhcnRfaW5kZXggPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBuZXh0X21hdGNoID0gcmVnZXhwLmV4ZWMoaW5wdXRfc3RyaW5nKTtcbiAgd2hpbGUgKG5leHRfbWF0Y2gpIHtcbiAgICByZXN1bHQucHVzaChpbnB1dF9zdHJpbmcuc3Vic3RyaW5nKHN0YXJ0X2luZGV4LCBuZXh0X21hdGNoLmluZGV4KSk7XG4gICAgc3RhcnRfaW5kZXggPSBuZXh0X21hdGNoLmluZGV4ICsgbmV4dF9tYXRjaFswXS5sZW5ndGg7XG4gICAgbmV4dF9tYXRjaCA9IHJlZ2V4cC5leGVjKGlucHV0X3N0cmluZyk7XG4gIH1cblxuICBpZiAoc3RhcnRfaW5kZXggPCBpbnB1dF9zdHJpbmcubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnB1c2goaW5wdXRfc3RyaW5nLnN1YnN0cmluZyhzdGFydF9pbmRleCwgaW5wdXRfc3RyaW5nLmxlbmd0aCkpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxubW9kdWxlLmV4cG9ydHMuV2hpdGVzcGFjZVBhdHRlcm4gPSBXaGl0ZXNwYWNlUGF0dGVybjtcblxuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxuZnVuY3Rpb24gUGF0dGVybihpbnB1dF9zY2FubmVyLCBwYXJlbnQpIHtcbiAgdGhpcy5faW5wdXQgPSBpbnB1dF9zY2FubmVyO1xuICB0aGlzLl9zdGFydGluZ19wYXR0ZXJuID0gbnVsbDtcbiAgdGhpcy5fbWF0Y2hfcGF0dGVybiA9IG51bGw7XG4gIHRoaXMuX3VudGlsX3BhdHRlcm4gPSBudWxsO1xuICB0aGlzLl91bnRpbF9hZnRlciA9IGZhbHNlO1xuXG4gIGlmIChwYXJlbnQpIHtcbiAgICB0aGlzLl9zdGFydGluZ19wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChwYXJlbnQuX3N0YXJ0aW5nX3BhdHRlcm4sIHRydWUpO1xuICAgIHRoaXMuX21hdGNoX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhcmVudC5fbWF0Y2hfcGF0dGVybiwgdHJ1ZSk7XG4gICAgdGhpcy5fdW50aWxfcGF0dGVybiA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAocGFyZW50Ll91bnRpbF9wYXR0ZXJuKTtcbiAgICB0aGlzLl91bnRpbF9hZnRlciA9IHBhcmVudC5fdW50aWxfYWZ0ZXI7XG4gIH1cbn1cblxuUGF0dGVybi5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5faW5wdXQucmVhZCh0aGlzLl9zdGFydGluZ19wYXR0ZXJuKTtcbiAgaWYgKCF0aGlzLl9zdGFydGluZ19wYXR0ZXJuIHx8IHJlc3VsdCkge1xuICAgIHJlc3VsdCArPSB0aGlzLl9pbnB1dC5yZWFkKHRoaXMuX21hdGNoX3BhdHRlcm4sIHRoaXMuX3VudGlsX3BhdHRlcm4sIHRoaXMuX3VudGlsX2FmdGVyKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuUGF0dGVybi5wcm90b3R5cGUucmVhZF9tYXRjaCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5faW5wdXQubWF0Y2godGhpcy5fbWF0Y2hfcGF0dGVybik7XG59O1xuXG5QYXR0ZXJuLnByb3RvdHlwZS51bnRpbF9hZnRlciA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2NyZWF0ZSgpO1xuICByZXN1bHQuX3VudGlsX2FmdGVyID0gdHJ1ZTtcbiAgcmVzdWx0Ll91bnRpbF9wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChwYXR0ZXJuKTtcbiAgcmVzdWx0Ll91cGRhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblBhdHRlcm4ucHJvdG90eXBlLnVudGlsID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fY3JlYXRlKCk7XG4gIHJlc3VsdC5fdW50aWxfYWZ0ZXIgPSBmYWxzZTtcbiAgcmVzdWx0Ll91bnRpbF9wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChwYXR0ZXJuKTtcbiAgcmVzdWx0Ll91cGRhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblBhdHRlcm4ucHJvdG90eXBlLnN0YXJ0aW5nX3dpdGggPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgcmVzdWx0Ll9zdGFydGluZ19wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChwYXR0ZXJuLCB0cnVlKTtcbiAgcmVzdWx0Ll91cGRhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblBhdHRlcm4ucHJvdG90eXBlLm1hdGNoaW5nID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fY3JlYXRlKCk7XG4gIHJlc3VsdC5fbWF0Y2hfcGF0dGVybiA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAocGF0dGVybiwgdHJ1ZSk7XG4gIHJlc3VsdC5fdXBkYXRlKCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5QYXR0ZXJuLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgUGF0dGVybih0aGlzLl9pbnB1dCwgdGhpcyk7XG59O1xuXG5QYXR0ZXJuLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24oKSB7fTtcblxubW9kdWxlLmV4cG9ydHMuUGF0dGVybiA9IFBhdHRlcm47XG5cblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbmZ1bmN0aW9uIERpcmVjdGl2ZXMoc3RhcnRfYmxvY2tfcGF0dGVybiwgZW5kX2Jsb2NrX3BhdHRlcm4pIHtcbiAgc3RhcnRfYmxvY2tfcGF0dGVybiA9IHR5cGVvZiBzdGFydF9ibG9ja19wYXR0ZXJuID09PSAnc3RyaW5nJyA/IHN0YXJ0X2Jsb2NrX3BhdHRlcm4gOiBzdGFydF9ibG9ja19wYXR0ZXJuLnNvdXJjZTtcbiAgZW5kX2Jsb2NrX3BhdHRlcm4gPSB0eXBlb2YgZW5kX2Jsb2NrX3BhdHRlcm4gPT09ICdzdHJpbmcnID8gZW5kX2Jsb2NrX3BhdHRlcm4gOiBlbmRfYmxvY2tfcGF0dGVybi5zb3VyY2U7XG4gIHRoaXMuX19kaXJlY3RpdmVzX2Jsb2NrX3BhdHRlcm4gPSBuZXcgUmVnRXhwKHN0YXJ0X2Jsb2NrX3BhdHRlcm4gKyAvIGJlYXV0aWZ5KCBcXHcrWzpdXFx3KykrIC8uc291cmNlICsgZW5kX2Jsb2NrX3BhdHRlcm4sICdnJyk7XG4gIHRoaXMuX19kaXJlY3RpdmVfcGF0dGVybiA9IC8gKFxcdyspWzpdKFxcdyspL2c7XG5cbiAgdGhpcy5fX2RpcmVjdGl2ZXNfZW5kX2lnbm9yZV9wYXR0ZXJuID0gbmV3IFJlZ0V4cChzdGFydF9ibG9ja19wYXR0ZXJuICsgL1xcc2JlYXV0aWZ5XFxzaWdub3JlOmVuZFxccy8uc291cmNlICsgZW5kX2Jsb2NrX3BhdHRlcm4sICdnJyk7XG59XG5cbkRpcmVjdGl2ZXMucHJvdG90eXBlLmdldF9kaXJlY3RpdmVzID0gZnVuY3Rpb24odGV4dCkge1xuICBpZiAoIXRleHQubWF0Y2godGhpcy5fX2RpcmVjdGl2ZXNfYmxvY2tfcGF0dGVybikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBkaXJlY3RpdmVzID0ge307XG4gIHRoaXMuX19kaXJlY3RpdmVfcGF0dGVybi5sYXN0SW5kZXggPSAwO1xuICB2YXIgZGlyZWN0aXZlX21hdGNoID0gdGhpcy5fX2RpcmVjdGl2ZV9wYXR0ZXJuLmV4ZWModGV4dCk7XG5cbiAgd2hpbGUgKGRpcmVjdGl2ZV9tYXRjaCkge1xuICAgIGRpcmVjdGl2ZXNbZGlyZWN0aXZlX21hdGNoWzFdXSA9IGRpcmVjdGl2ZV9tYXRjaFsyXTtcbiAgICBkaXJlY3RpdmVfbWF0Y2ggPSB0aGlzLl9fZGlyZWN0aXZlX3BhdHRlcm4uZXhlYyh0ZXh0KTtcbiAgfVxuXG4gIHJldHVybiBkaXJlY3RpdmVzO1xufTtcblxuRGlyZWN0aXZlcy5wcm90b3R5cGUucmVhZElnbm9yZWQgPSBmdW5jdGlvbihpbnB1dCkge1xuICByZXR1cm4gaW5wdXQucmVhZFVudGlsQWZ0ZXIodGhpcy5fX2RpcmVjdGl2ZXNfZW5kX2lnbm9yZV9wYXR0ZXJuKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMuRGlyZWN0aXZlcyA9IERpcmVjdGl2ZXM7XG5cblxuLyoqKi8gfSksXG4vKiAxNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxudmFyIFBhdHRlcm4gPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxMikuUGF0dGVybik7XG5cblxudmFyIHRlbXBsYXRlX25hbWVzID0ge1xuICBkamFuZ286IGZhbHNlLFxuICBlcmI6IGZhbHNlLFxuICBoYW5kbGViYXJzOiBmYWxzZSxcbiAgcGhwOiBmYWxzZSxcbiAgc21hcnR5OiBmYWxzZVxufTtcblxuLy8gVGhpcyBsZXRzIHRlbXBsYXRlcyBhcHBlYXIgYW55d2hlcmUgd2Ugd291bGQgZG8gYSByZWFkVW50aWxcbi8vIFRoZSBjb3N0IGlzIGhpZ2hlciBidXQgaXQgaXMgcGF5IHRvIHBsYXkuXG5mdW5jdGlvbiBUZW1wbGF0YWJsZVBhdHRlcm4oaW5wdXRfc2Nhbm5lciwgcGFyZW50KSB7XG4gIFBhdHRlcm4uY2FsbCh0aGlzLCBpbnB1dF9zY2FubmVyLCBwYXJlbnQpO1xuICB0aGlzLl9fdGVtcGxhdGVfcGF0dGVybiA9IG51bGw7XG4gIHRoaXMuX2Rpc2FibGVkID0gT2JqZWN0LmFzc2lnbih7fSwgdGVtcGxhdGVfbmFtZXMpO1xuICB0aGlzLl9leGNsdWRlZCA9IE9iamVjdC5hc3NpZ24oe30sIHRlbXBsYXRlX25hbWVzKTtcblxuICBpZiAocGFyZW50KSB7XG4gICAgdGhpcy5fX3RlbXBsYXRlX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhcmVudC5fX3RlbXBsYXRlX3BhdHRlcm4pO1xuICAgIHRoaXMuX2V4Y2x1ZGVkID0gT2JqZWN0LmFzc2lnbih0aGlzLl9leGNsdWRlZCwgcGFyZW50Ll9leGNsdWRlZCk7XG4gICAgdGhpcy5fZGlzYWJsZWQgPSBPYmplY3QuYXNzaWduKHRoaXMuX2Rpc2FibGVkLCBwYXJlbnQuX2Rpc2FibGVkKTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IG5ldyBQYXR0ZXJuKGlucHV0X3NjYW5uZXIpO1xuICB0aGlzLl9fcGF0dGVybnMgPSB7XG4gICAgaGFuZGxlYmFyc19jb21tZW50OiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoL3t7IS0tLykudW50aWxfYWZ0ZXIoLy0tfX0vKSxcbiAgICBoYW5kbGViYXJzX3VuZXNjYXBlZDogcGF0dGVybi5zdGFydGluZ193aXRoKC97e3svKS51bnRpbF9hZnRlcigvfX19LyksXG4gICAgaGFuZGxlYmFyczogcGF0dGVybi5zdGFydGluZ193aXRoKC97ey8pLnVudGlsX2FmdGVyKC99fS8pLFxuICAgIHBocDogcGF0dGVybi5zdGFydGluZ193aXRoKC88XFw/KD86Wz0gXXxwaHApLykudW50aWxfYWZ0ZXIoL1xcPz4vKSxcbiAgICBlcmI6IHBhdHRlcm4uc3RhcnRpbmdfd2l0aCgvPCVbXiVdLykudW50aWxfYWZ0ZXIoL1teJV0lPi8pLFxuICAgIC8vIGRqYW5nbyBjb2ZsaWN0cyB3aXRoIGhhbmRsZWJhcnMgYSBiaXQuXG4gICAgZGphbmdvOiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoL3slLykudW50aWxfYWZ0ZXIoLyV9LyksXG4gICAgZGphbmdvX3ZhbHVlOiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoL3t7LykudW50aWxfYWZ0ZXIoL319LyksXG4gICAgZGphbmdvX2NvbW1lbnQ6IHBhdHRlcm4uc3RhcnRpbmdfd2l0aCgveyMvKS51bnRpbF9hZnRlcigvI30vKSxcbiAgICBzbWFydHk6IHBhdHRlcm4uc3RhcnRpbmdfd2l0aCgveyg/PVtefXtcXHNcXG5dKS8pLnVudGlsX2FmdGVyKC9bXlxcc1xcbl19LyksXG4gICAgc21hcnR5X2NvbW1lbnQ6IHBhdHRlcm4uc3RhcnRpbmdfd2l0aCgve1xcKi8pLnVudGlsX2FmdGVyKC9cXCp9LyksXG4gICAgc21hcnR5X2xpdGVyYWw6IHBhdHRlcm4uc3RhcnRpbmdfd2l0aCgve2xpdGVyYWx9LykudW50aWxfYWZ0ZXIoL3tcXC9saXRlcmFsfS8pXG4gIH07XG59XG5UZW1wbGF0YWJsZVBhdHRlcm4ucHJvdG90eXBlID0gbmV3IFBhdHRlcm4oKTtcblxuVGVtcGxhdGFibGVQYXR0ZXJuLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGVtcGxhdGFibGVQYXR0ZXJuKHRoaXMuX2lucHV0LCB0aGlzKTtcbn07XG5cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9fc2V0X3RlbXBsYXRlZF9wYXR0ZXJuKCk7XG59O1xuXG5UZW1wbGF0YWJsZVBhdHRlcm4ucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbihsYW5ndWFnZSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fY3JlYXRlKCk7XG4gIHJlc3VsdC5fZGlzYWJsZWRbbGFuZ3VhZ2VdID0gdHJ1ZTtcbiAgcmVzdWx0Ll91cGRhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUucmVhZF9vcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fY3JlYXRlKCk7XG4gIGZvciAodmFyIGxhbmd1YWdlIGluIHRlbXBsYXRlX25hbWVzKSB7XG4gICAgcmVzdWx0Ll9kaXNhYmxlZFtsYW5ndWFnZV0gPSBvcHRpb25zLnRlbXBsYXRpbmcuaW5kZXhPZihsYW5ndWFnZSkgPT09IC0xO1xuICB9XG4gIHJlc3VsdC5fdXBkYXRlKCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5UZW1wbGF0YWJsZVBhdHRlcm4ucHJvdG90eXBlLmV4Y2x1ZGUgPSBmdW5jdGlvbihsYW5ndWFnZSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fY3JlYXRlKCk7XG4gIHJlc3VsdC5fZXhjbHVkZWRbbGFuZ3VhZ2VdID0gdHJ1ZTtcbiAgcmVzdWx0Ll91cGRhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGlzLl9tYXRjaF9wYXR0ZXJuKSB7XG4gICAgcmVzdWx0ID0gdGhpcy5faW5wdXQucmVhZCh0aGlzLl9zdGFydGluZ19wYXR0ZXJuKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSB0aGlzLl9pbnB1dC5yZWFkKHRoaXMuX3N0YXJ0aW5nX3BhdHRlcm4sIHRoaXMuX190ZW1wbGF0ZV9wYXR0ZXJuKTtcbiAgfVxuICB2YXIgbmV4dCA9IHRoaXMuX3JlYWRfdGVtcGxhdGUoKTtcbiAgd2hpbGUgKG5leHQpIHtcbiAgICBpZiAodGhpcy5fbWF0Y2hfcGF0dGVybikge1xuICAgICAgbmV4dCArPSB0aGlzLl9pbnB1dC5yZWFkKHRoaXMuX21hdGNoX3BhdHRlcm4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0ICs9IHRoaXMuX2lucHV0LnJlYWRVbnRpbCh0aGlzLl9fdGVtcGxhdGVfcGF0dGVybik7XG4gICAgfVxuICAgIHJlc3VsdCArPSBuZXh0O1xuICAgIG5leHQgPSB0aGlzLl9yZWFkX3RlbXBsYXRlKCk7XG4gIH1cblxuICBpZiAodGhpcy5fdW50aWxfYWZ0ZXIpIHtcbiAgICByZXN1bHQgKz0gdGhpcy5faW5wdXQucmVhZFVudGlsQWZ0ZXIodGhpcy5fdW50aWxfcGF0dGVybik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUuX19zZXRfdGVtcGxhdGVkX3BhdHRlcm4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGl0ZW1zID0gW107XG5cbiAgaWYgKCF0aGlzLl9kaXNhYmxlZC5waHApIHtcbiAgICBpdGVtcy5wdXNoKHRoaXMuX19wYXR0ZXJucy5waHAuX3N0YXJ0aW5nX3BhdHRlcm4uc291cmNlKTtcbiAgfVxuICBpZiAoIXRoaXMuX2Rpc2FibGVkLmhhbmRsZWJhcnMpIHtcbiAgICBpdGVtcy5wdXNoKHRoaXMuX19wYXR0ZXJucy5oYW5kbGViYXJzLl9zdGFydGluZ19wYXR0ZXJuLnNvdXJjZSk7XG4gIH1cbiAgaWYgKCF0aGlzLl9kaXNhYmxlZC5lcmIpIHtcbiAgICBpdGVtcy5wdXNoKHRoaXMuX19wYXR0ZXJucy5lcmIuX3N0YXJ0aW5nX3BhdHRlcm4uc291cmNlKTtcbiAgfVxuICBpZiAoIXRoaXMuX2Rpc2FibGVkLmRqYW5nbykge1xuICAgIGl0ZW1zLnB1c2godGhpcy5fX3BhdHRlcm5zLmRqYW5nby5fc3RhcnRpbmdfcGF0dGVybi5zb3VyY2UpO1xuICAgIC8vIFRoZSBzdGFydGluZyBwYXR0ZXJuIGZvciBkamFuZ28gaXMgbW9yZSBjb21wbGV4IGJlY2F1c2UgaXQgaGFzIGRpZmZlcmVudFxuICAgIC8vIHBhdHRlcm5zIGZvciB2YWx1ZSwgY29tbWVudCwgYW5kIG90aGVyIHNlY3Rpb25zXG4gICAgaXRlbXMucHVzaCh0aGlzLl9fcGF0dGVybnMuZGphbmdvX3ZhbHVlLl9zdGFydGluZ19wYXR0ZXJuLnNvdXJjZSk7XG4gICAgaXRlbXMucHVzaCh0aGlzLl9fcGF0dGVybnMuZGphbmdvX2NvbW1lbnQuX3N0YXJ0aW5nX3BhdHRlcm4uc291cmNlKTtcbiAgfVxuICBpZiAoIXRoaXMuX2Rpc2FibGVkLnNtYXJ0eSkge1xuICAgIGl0ZW1zLnB1c2godGhpcy5fX3BhdHRlcm5zLnNtYXJ0eS5fc3RhcnRpbmdfcGF0dGVybi5zb3VyY2UpO1xuICB9XG5cbiAgaWYgKHRoaXMuX3VudGlsX3BhdHRlcm4pIHtcbiAgICBpdGVtcy5wdXNoKHRoaXMuX3VudGlsX3BhdHRlcm4uc291cmNlKTtcbiAgfVxuICB0aGlzLl9fdGVtcGxhdGVfcGF0dGVybiA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAoJyg/OicgKyBpdGVtcy5qb2luKCd8JykgKyAnKScpO1xufTtcblxuVGVtcGxhdGFibGVQYXR0ZXJuLnByb3RvdHlwZS5fcmVhZF90ZW1wbGF0ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzdWx0aW5nX3N0cmluZyA9ICcnO1xuICB2YXIgYyA9IHRoaXMuX2lucHV0LnBlZWsoKTtcbiAgaWYgKGMgPT09ICc8Jykge1xuICAgIHZhciBwZWVrMSA9IHRoaXMuX2lucHV0LnBlZWsoMSk7XG4gICAgLy9pZiB3ZSdyZSBpbiBhIGNvbW1lbnQsIGRvIHNvbWV0aGluZyBzcGVjaWFsXG4gICAgLy8gV2UgdHJlYXQgYWxsIGNvbW1lbnRzIGFzIGxpdGVyYWxzLCBldmVuIG1vcmUgdGhhbiBwcmVmb3JtYXR0ZWQgdGFnc1xuICAgIC8vIHdlIGp1c3QgbG9vayBmb3IgdGhlIGFwcHJvcHJpYXRlIGNsb3NlIHRhZ1xuICAgIGlmICghdGhpcy5fZGlzYWJsZWQucGhwICYmICF0aGlzLl9leGNsdWRlZC5waHAgJiYgcGVlazEgPT09ICc/Jykge1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHxcbiAgICAgICAgdGhpcy5fX3BhdHRlcm5zLnBocC5yZWFkKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fZGlzYWJsZWQuZXJiICYmICF0aGlzLl9leGNsdWRlZC5lcmIgJiYgcGVlazEgPT09ICclJykge1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHxcbiAgICAgICAgdGhpcy5fX3BhdHRlcm5zLmVyYi5yZWFkKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGMgPT09ICd7Jykge1xuICAgIGlmICghdGhpcy5fZGlzYWJsZWQuaGFuZGxlYmFycyAmJiAhdGhpcy5fZXhjbHVkZWQuaGFuZGxlYmFycykge1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHxcbiAgICAgICAgdGhpcy5fX3BhdHRlcm5zLmhhbmRsZWJhcnNfY29tbWVudC5yZWFkKCk7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fFxuICAgICAgICB0aGlzLl9fcGF0dGVybnMuaGFuZGxlYmFyc191bmVzY2FwZWQucmVhZCgpO1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHxcbiAgICAgICAgdGhpcy5fX3BhdHRlcm5zLmhhbmRsZWJhcnMucmVhZCgpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2Rpc2FibGVkLmRqYW5nbykge1xuICAgICAgLy8gZGphbmdvIGNvZmxpY3RzIHdpdGggaGFuZGxlYmFycyBhIGJpdC5cbiAgICAgIGlmICghdGhpcy5fZXhjbHVkZWQuZGphbmdvICYmICF0aGlzLl9leGNsdWRlZC5oYW5kbGViYXJzKSB7XG4gICAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgICAgdGhpcy5fX3BhdHRlcm5zLmRqYW5nb192YWx1ZS5yZWFkKCk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX2V4Y2x1ZGVkLmRqYW5nbykge1xuICAgICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fFxuICAgICAgICAgIHRoaXMuX19wYXR0ZXJucy5kamFuZ29fY29tbWVudC5yZWFkKCk7XG4gICAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgICAgdGhpcy5fX3BhdHRlcm5zLmRqYW5nby5yZWFkKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5fZGlzYWJsZWQuc21hcnR5KSB7XG4gICAgICAvLyBzbWFydHkgY2Fubm90IGJlIGVuYWJsZWQgd2l0aCBkamFuZ28gb3IgaGFuZGxlYmFycyBlbmFibGVkXG4gICAgICBpZiAodGhpcy5fZGlzYWJsZWQuZGphbmdvICYmIHRoaXMuX2Rpc2FibGVkLmhhbmRsZWJhcnMpIHtcbiAgICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHxcbiAgICAgICAgICB0aGlzLl9fcGF0dGVybnMuc21hcnR5X2NvbW1lbnQucmVhZCgpO1xuICAgICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fFxuICAgICAgICAgIHRoaXMuX19wYXR0ZXJucy5zbWFydHlfbGl0ZXJhbC5yZWFkKCk7XG4gICAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgICAgdGhpcy5fX3BhdHRlcm5zLnNtYXJ0eS5yZWFkKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRpbmdfc3RyaW5nO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cy5UZW1wbGF0YWJsZVBhdHRlcm4gPSBUZW1wbGF0YWJsZVBhdHRlcm47XG5cblxuLyoqKi8gfSksXG4vKiAxNSAqLyxcbi8qIDE2ICovLFxuLyogMTcgKi8sXG4vKiAxOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxudmFyIEJlYXV0aWZpZXIgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxOSkuQmVhdXRpZmllciksXG4gIE9wdGlvbnMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygyMCkuT3B0aW9ucyk7XG5cbmZ1bmN0aW9uIHN0eWxlX2h0bWwoaHRtbF9zb3VyY2UsIG9wdGlvbnMsIGpzX2JlYXV0aWZ5LCBjc3NfYmVhdXRpZnkpIHtcbiAgdmFyIGJlYXV0aWZpZXIgPSBuZXcgQmVhdXRpZmllcihodG1sX3NvdXJjZSwgb3B0aW9ucywganNfYmVhdXRpZnksIGNzc19iZWF1dGlmeSk7XG4gIHJldHVybiBiZWF1dGlmaWVyLmJlYXV0aWZ5KCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5bGVfaHRtbDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgT3B0aW9ucygpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG52YXIgT3B0aW9ucyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKS5PcHRpb25zKTtcbnZhciBPdXRwdXQgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygyKS5PdXRwdXQpO1xudmFyIFRva2VuaXplciA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKS5Ub2tlbml6ZXIpO1xudmFyIFRPS0VOID0gKF9fd2VicGFja19yZXF1aXJlX18oMjEpLlRPS0VOKTtcblxudmFyIGxpbmVCcmVhayA9IC9cXHJcXG58W1xcclxcbl0vO1xudmFyIGFsbExpbmVCcmVha3MgPSAvXFxyXFxufFtcXHJcXG5dL2c7XG5cbnZhciBQcmludGVyID0gZnVuY3Rpb24ob3B0aW9ucywgYmFzZV9pbmRlbnRfc3RyaW5nKSB7IC8vaGFuZGxlcyBpbnB1dC9vdXRwdXQgYW5kIHNvbWUgb3RoZXIgcHJpbnRpbmcgZnVuY3Rpb25zXG5cbiAgdGhpcy5pbmRlbnRfbGV2ZWwgPSAwO1xuICB0aGlzLmFsaWdubWVudF9zaXplID0gMDtcbiAgdGhpcy5tYXhfcHJlc2VydmVfbmV3bGluZXMgPSBvcHRpb25zLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcztcbiAgdGhpcy5wcmVzZXJ2ZV9uZXdsaW5lcyA9IG9wdGlvbnMucHJlc2VydmVfbmV3bGluZXM7XG5cbiAgdGhpcy5fb3V0cHV0ID0gbmV3IE91dHB1dChvcHRpb25zLCBiYXNlX2luZGVudF9zdHJpbmcpO1xuXG59O1xuXG5QcmludGVyLnByb3RvdHlwZS5jdXJyZW50X2xpbmVfaGFzX21hdGNoID0gZnVuY3Rpb24ocGF0dGVybikge1xuICByZXR1cm4gdGhpcy5fb3V0cHV0LmN1cnJlbnRfbGluZS5oYXNfbWF0Y2gocGF0dGVybik7XG59O1xuXG5QcmludGVyLnByb3RvdHlwZS5zZXRfc3BhY2VfYmVmb3JlX3Rva2VuID0gZnVuY3Rpb24odmFsdWUsIG5vbl9icmVha2luZykge1xuICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdmFsdWU7XG4gIHRoaXMuX291dHB1dC5ub25fYnJlYWtpbmdfc3BhY2UgPSBub25fYnJlYWtpbmc7XG59O1xuXG5QcmludGVyLnByb3RvdHlwZS5zZXRfd3JhcF9wb2ludCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9vdXRwdXQuc2V0X2luZGVudCh0aGlzLmluZGVudF9sZXZlbCwgdGhpcy5hbGlnbm1lbnRfc2l6ZSk7XG4gIHRoaXMuX291dHB1dC5zZXRfd3JhcF9wb2ludCgpO1xufTtcblxuXG5QcmludGVyLnByb3RvdHlwZS5hZGRfcmF3X3Rva2VuID0gZnVuY3Rpb24odG9rZW4pIHtcbiAgdGhpcy5fb3V0cHV0LmFkZF9yYXdfdG9rZW4odG9rZW4pO1xufTtcblxuUHJpbnRlci5wcm90b3R5cGUucHJpbnRfcHJlc2VydmVkX25ld2xpbmVzID0gZnVuY3Rpb24ocmF3X3Rva2VuKSB7XG4gIHZhciBuZXdsaW5lcyA9IDA7XG4gIGlmIChyYXdfdG9rZW4udHlwZSAhPT0gVE9LRU4uVEVYVCAmJiByYXdfdG9rZW4ucHJldmlvdXMudHlwZSAhPT0gVE9LRU4uVEVYVCkge1xuICAgIG5ld2xpbmVzID0gcmF3X3Rva2VuLm5ld2xpbmVzID8gMSA6IDA7XG4gIH1cblxuICBpZiAodGhpcy5wcmVzZXJ2ZV9uZXdsaW5lcykge1xuICAgIG5ld2xpbmVzID0gcmF3X3Rva2VuLm5ld2xpbmVzIDwgdGhpcy5tYXhfcHJlc2VydmVfbmV3bGluZXMgKyAxID8gcmF3X3Rva2VuLm5ld2xpbmVzIDogdGhpcy5tYXhfcHJlc2VydmVfbmV3bGluZXMgKyAxO1xuICB9XG4gIGZvciAodmFyIG4gPSAwOyBuIDwgbmV3bGluZXM7IG4rKykge1xuICAgIHRoaXMucHJpbnRfbmV3bGluZShuID4gMCk7XG4gIH1cblxuICByZXR1cm4gbmV3bGluZXMgIT09IDA7XG59O1xuXG5QcmludGVyLnByb3RvdHlwZS50cmF2ZXJzZV93aGl0ZXNwYWNlID0gZnVuY3Rpb24ocmF3X3Rva2VuKSB7XG4gIGlmIChyYXdfdG9rZW4ud2hpdGVzcGFjZV9iZWZvcmUgfHwgcmF3X3Rva2VuLm5ld2xpbmVzKSB7XG4gICAgaWYgKCF0aGlzLnByaW50X3ByZXNlcnZlZF9uZXdsaW5lcyhyYXdfdG9rZW4pKSB7XG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuUHJpbnRlci5wcm90b3R5cGUucHJldmlvdXNfdG9rZW5fd3JhcHBlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fb3V0cHV0LnByZXZpb3VzX3Rva2VuX3dyYXBwZWQ7XG59O1xuXG5QcmludGVyLnByb3RvdHlwZS5wcmludF9uZXdsaW5lID0gZnVuY3Rpb24oZm9yY2UpIHtcbiAgdGhpcy5fb3V0cHV0LmFkZF9uZXdfbGluZShmb3JjZSk7XG59O1xuXG5QcmludGVyLnByb3RvdHlwZS5wcmludF90b2tlbiA9IGZ1bmN0aW9uKHRva2VuKSB7XG4gIGlmICh0b2tlbi50ZXh0KSB7XG4gICAgdGhpcy5fb3V0cHV0LnNldF9pbmRlbnQodGhpcy5pbmRlbnRfbGV2ZWwsIHRoaXMuYWxpZ25tZW50X3NpemUpO1xuICAgIHRoaXMuX291dHB1dC5hZGRfdG9rZW4odG9rZW4udGV4dCk7XG4gIH1cbn07XG5cblByaW50ZXIucHJvdG90eXBlLmluZGVudCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmluZGVudF9sZXZlbCsrO1xufTtcblxuUHJpbnRlci5wcm90b3R5cGUuZ2V0X2Z1bGxfaW5kZW50ID0gZnVuY3Rpb24obGV2ZWwpIHtcbiAgbGV2ZWwgPSB0aGlzLmluZGVudF9sZXZlbCArIChsZXZlbCB8fCAwKTtcbiAgaWYgKGxldmVsIDwgMSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9vdXRwdXQuZ2V0X2luZGVudF9zdHJpbmcobGV2ZWwpO1xufTtcblxudmFyIGdldF90eXBlX2F0dHJpYnV0ZSA9IGZ1bmN0aW9uKHN0YXJ0X3Rva2VuKSB7XG4gIHZhciByZXN1bHQgPSBudWxsO1xuICB2YXIgcmF3X3Rva2VuID0gc3RhcnRfdG9rZW4ubmV4dDtcblxuICAvLyBTZWFyY2ggYXR0cmlidXRlcyBmb3IgYSB0eXBlIGF0dHJpYnV0ZVxuICB3aGlsZSAocmF3X3Rva2VuLnR5cGUgIT09IFRPS0VOLkVPRiAmJiBzdGFydF90b2tlbi5jbG9zZWQgIT09IHJhd190b2tlbikge1xuICAgIGlmIChyYXdfdG9rZW4udHlwZSA9PT0gVE9LRU4uQVRUUklCVVRFICYmIHJhd190b2tlbi50ZXh0ID09PSAndHlwZScpIHtcbiAgICAgIGlmIChyYXdfdG9rZW4ubmV4dCAmJiByYXdfdG9rZW4ubmV4dC50eXBlID09PSBUT0tFTi5FUVVBTFMgJiZcbiAgICAgICAgcmF3X3Rva2VuLm5leHQubmV4dCAmJiByYXdfdG9rZW4ubmV4dC5uZXh0LnR5cGUgPT09IFRPS0VOLlZBTFVFKSB7XG4gICAgICAgIHJlc3VsdCA9IHJhd190b2tlbi5uZXh0Lm5leHQudGV4dDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByYXdfdG9rZW4gPSByYXdfdG9rZW4ubmV4dDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgZ2V0X2N1c3RvbV9iZWF1dGlmaWVyX25hbWUgPSBmdW5jdGlvbih0YWdfY2hlY2ssIHJhd190b2tlbikge1xuICB2YXIgdHlwZUF0dHJpYnV0ZSA9IG51bGw7XG4gIHZhciByZXN1bHQgPSBudWxsO1xuXG4gIGlmICghcmF3X3Rva2VuLmNsb3NlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHRhZ19jaGVjayA9PT0gJ3NjcmlwdCcpIHtcbiAgICB0eXBlQXR0cmlidXRlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gIH0gZWxzZSBpZiAodGFnX2NoZWNrID09PSAnc3R5bGUnKSB7XG4gICAgdHlwZUF0dHJpYnV0ZSA9ICd0ZXh0L2Nzcyc7XG4gIH1cblxuICB0eXBlQXR0cmlidXRlID0gZ2V0X3R5cGVfYXR0cmlidXRlKHJhd190b2tlbikgfHwgdHlwZUF0dHJpYnV0ZTtcblxuICAvLyBGb3Igc2NyaXB0IGFuZCBzdHlsZSB0YWdzIHRoYXQgaGF2ZSBhIHR5cGUgYXR0cmlidXRlLCBvbmx5IGVuYWJsZSBjdXN0b20gYmVhdXRpZmllcnMgZm9yIG1hdGNoaW5nIHZhbHVlc1xuICAvLyBGb3IgdGhvc2Ugd2l0aG91dCBhIHR5cGUgYXR0cmlidXRlIHVzZSBkZWZhdWx0O1xuICBpZiAodHlwZUF0dHJpYnV0ZS5zZWFyY2goJ3RleHQvY3NzJykgPiAtMSkge1xuICAgIHJlc3VsdCA9ICdjc3MnO1xuICB9IGVsc2UgaWYgKHR5cGVBdHRyaWJ1dGUuc2VhcmNoKC9tb2R1bGV8KCh0ZXh0fGFwcGxpY2F0aW9ufGRvam8pXFwvKHgtKT8oamF2YXNjcmlwdHxlY21hc2NyaXB0fGpzY3JpcHR8bGl2ZXNjcmlwdHwobGRcXCspP2pzb258bWV0aG9kfGFzcGVjdCkpLykgPiAtMSkge1xuICAgIHJlc3VsdCA9ICdqYXZhc2NyaXB0JztcbiAgfSBlbHNlIGlmICh0eXBlQXR0cmlidXRlLnNlYXJjaCgvKHRleHR8YXBwbGljYXRpb258ZG9qbylcXC8oeC0pPyhodG1sKS8pID4gLTEpIHtcbiAgICByZXN1bHQgPSAnaHRtbCc7XG4gIH0gZWxzZSBpZiAodHlwZUF0dHJpYnV0ZS5zZWFyY2goL3Rlc3RcXC9udWxsLykgPiAtMSkge1xuICAgIC8vIFRlc3Qgb25seSBtaW1lLXR5cGUgZm9yIHRlc3RpbmcgdGhlIGJlYXV0aWZpZXIgd2hlbiBudWxsIGlzIHBhc3NlZCBhcyBiZWF1dGlmaW5nIGZ1bmN0aW9uXG4gICAgcmVzdWx0ID0gJ251bGwnO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmZ1bmN0aW9uIGluX2FycmF5KHdoYXQsIGFycikge1xuICByZXR1cm4gYXJyLmluZGV4T2Yod2hhdCkgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBUYWdGcmFtZShwYXJlbnQsIHBhcnNlcl90b2tlbiwgaW5kZW50X2xldmVsKSB7XG4gIHRoaXMucGFyZW50ID0gcGFyZW50IHx8IG51bGw7XG4gIHRoaXMudGFnID0gcGFyc2VyX3Rva2VuID8gcGFyc2VyX3Rva2VuLnRhZ19uYW1lIDogJyc7XG4gIHRoaXMuaW5kZW50X2xldmVsID0gaW5kZW50X2xldmVsIHx8IDA7XG4gIHRoaXMucGFyc2VyX3Rva2VuID0gcGFyc2VyX3Rva2VuIHx8IG51bGw7XG59XG5cbmZ1bmN0aW9uIFRhZ1N0YWNrKHByaW50ZXIpIHtcbiAgdGhpcy5fcHJpbnRlciA9IHByaW50ZXI7XG4gIHRoaXMuX2N1cnJlbnRfZnJhbWUgPSBudWxsO1xufVxuXG5UYWdTdGFjay5wcm90b3R5cGUuZ2V0X3BhcnNlcl90b2tlbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY3VycmVudF9mcmFtZSA/IHRoaXMuX2N1cnJlbnRfZnJhbWUucGFyc2VyX3Rva2VuIDogbnVsbDtcbn07XG5cblRhZ1N0YWNrLnByb3RvdHlwZS5yZWNvcmRfdGFnID0gZnVuY3Rpb24ocGFyc2VyX3Rva2VuKSB7IC8vZnVuY3Rpb24gdG8gcmVjb3JkIGEgdGFnIGFuZCBpdHMgcGFyZW50IGluIHRoaXMudGFncyBPYmplY3RcbiAgdmFyIG5ld19mcmFtZSA9IG5ldyBUYWdGcmFtZSh0aGlzLl9jdXJyZW50X2ZyYW1lLCBwYXJzZXJfdG9rZW4sIHRoaXMuX3ByaW50ZXIuaW5kZW50X2xldmVsKTtcbiAgdGhpcy5fY3VycmVudF9mcmFtZSA9IG5ld19mcmFtZTtcbn07XG5cblRhZ1N0YWNrLnByb3RvdHlwZS5fdHJ5X3BvcF9mcmFtZSA9IGZ1bmN0aW9uKGZyYW1lKSB7IC8vZnVuY3Rpb24gdG8gcmV0cmlldmUgdGhlIG9wZW5pbmcgdGFnIHRvIHRoZSBjb3JyZXNwb25kaW5nIGNsb3NlclxuICB2YXIgcGFyc2VyX3Rva2VuID0gbnVsbDtcblxuICBpZiAoZnJhbWUpIHtcbiAgICBwYXJzZXJfdG9rZW4gPSBmcmFtZS5wYXJzZXJfdG9rZW47XG4gICAgdGhpcy5fcHJpbnRlci5pbmRlbnRfbGV2ZWwgPSBmcmFtZS5pbmRlbnRfbGV2ZWw7XG4gICAgdGhpcy5fY3VycmVudF9mcmFtZSA9IGZyYW1lLnBhcmVudDtcbiAgfVxuXG4gIHJldHVybiBwYXJzZXJfdG9rZW47XG59O1xuXG5UYWdTdGFjay5wcm90b3R5cGUuX2dldF9mcmFtZSA9IGZ1bmN0aW9uKHRhZ19saXN0LCBzdG9wX2xpc3QpIHsgLy9mdW5jdGlvbiB0byByZXRyaWV2ZSB0aGUgb3BlbmluZyB0YWcgdG8gdGhlIGNvcnJlc3BvbmRpbmcgY2xvc2VyXG4gIHZhciBmcmFtZSA9IHRoaXMuX2N1cnJlbnRfZnJhbWU7XG5cbiAgd2hpbGUgKGZyYW1lKSB7IC8vdGlsbCB3ZSByZWFjaCAnJyAodGhlIGluaXRpYWwgdmFsdWUpO1xuICAgIGlmICh0YWdfbGlzdC5pbmRleE9mKGZyYW1lLnRhZykgIT09IC0xKSB7IC8vaWYgdGhpcyBpcyBpdCB1c2UgaXRcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAoc3RvcF9saXN0ICYmIHN0b3BfbGlzdC5pbmRleE9mKGZyYW1lLnRhZykgIT09IC0xKSB7XG4gICAgICBmcmFtZSA9IG51bGw7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZnJhbWUgPSBmcmFtZS5wYXJlbnQ7XG4gIH1cblxuICByZXR1cm4gZnJhbWU7XG59O1xuXG5UYWdTdGFjay5wcm90b3R5cGUudHJ5X3BvcCA9IGZ1bmN0aW9uKHRhZywgc3RvcF9saXN0KSB7IC8vZnVuY3Rpb24gdG8gcmV0cmlldmUgdGhlIG9wZW5pbmcgdGFnIHRvIHRoZSBjb3JyZXNwb25kaW5nIGNsb3NlclxuICB2YXIgZnJhbWUgPSB0aGlzLl9nZXRfZnJhbWUoW3RhZ10sIHN0b3BfbGlzdCk7XG4gIHJldHVybiB0aGlzLl90cnlfcG9wX2ZyYW1lKGZyYW1lKTtcbn07XG5cblRhZ1N0YWNrLnByb3RvdHlwZS5pbmRlbnRfdG9fdGFnID0gZnVuY3Rpb24odGFnX2xpc3QpIHtcbiAgdmFyIGZyYW1lID0gdGhpcy5fZ2V0X2ZyYW1lKHRhZ19saXN0KTtcbiAgaWYgKGZyYW1lKSB7XG4gICAgdGhpcy5fcHJpbnRlci5pbmRlbnRfbGV2ZWwgPSBmcmFtZS5pbmRlbnRfbGV2ZWw7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIEJlYXV0aWZpZXIoc291cmNlX3RleHQsIG9wdGlvbnMsIGpzX2JlYXV0aWZ5LCBjc3NfYmVhdXRpZnkpIHtcbiAgLy9XcmFwcGVyIGZ1bmN0aW9uIHRvIGludm9rZSBhbGwgdGhlIG5lY2Vzc2FyeSBjb25zdHJ1Y3RvcnMgYW5kIGRlYWwgd2l0aCB0aGUgb3V0cHV0LlxuICB0aGlzLl9zb3VyY2VfdGV4dCA9IHNvdXJjZV90ZXh0IHx8ICcnO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5fanNfYmVhdXRpZnkgPSBqc19iZWF1dGlmeTtcbiAgdGhpcy5fY3NzX2JlYXV0aWZ5ID0gY3NzX2JlYXV0aWZ5O1xuICB0aGlzLl90YWdfc3RhY2sgPSBudWxsO1xuXG4gIC8vIEFsbG93IHRoZSBzZXR0aW5nIG9mIGxhbmd1YWdlL2ZpbGUtdHlwZSBzcGVjaWZpYyBvcHRpb25zXG4gIC8vIHdpdGggaW5oZXJpdGFuY2Ugb2Ygb3ZlcmFsbCBzZXR0aW5nc1xuICB2YXIgb3B0aW9uSHRtbCA9IG5ldyBPcHRpb25zKG9wdGlvbnMsICdodG1sJyk7XG5cbiAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbkh0bWw7XG5cbiAgdGhpcy5faXNfd3JhcF9hdHRyaWJ1dGVzX2ZvcmNlID0gdGhpcy5fb3B0aW9ucy53cmFwX2F0dHJpYnV0ZXMuc3Vic3RyKDAsICdmb3JjZScubGVuZ3RoKSA9PT0gJ2ZvcmNlJztcbiAgdGhpcy5faXNfd3JhcF9hdHRyaWJ1dGVzX2ZvcmNlX2V4cGFuZF9tdWx0aWxpbmUgPSAodGhpcy5fb3B0aW9ucy53cmFwX2F0dHJpYnV0ZXMgPT09ICdmb3JjZS1leHBhbmQtbXVsdGlsaW5lJyk7XG4gIHRoaXMuX2lzX3dyYXBfYXR0cmlidXRlc19mb3JjZV9hbGlnbmVkID0gKHRoaXMuX29wdGlvbnMud3JhcF9hdHRyaWJ1dGVzID09PSAnZm9yY2UtYWxpZ25lZCcpO1xuICB0aGlzLl9pc193cmFwX2F0dHJpYnV0ZXNfYWxpZ25lZF9tdWx0aXBsZSA9ICh0aGlzLl9vcHRpb25zLndyYXBfYXR0cmlidXRlcyA9PT0gJ2FsaWduZWQtbXVsdGlwbGUnKTtcbiAgdGhpcy5faXNfd3JhcF9hdHRyaWJ1dGVzX3ByZXNlcnZlID0gdGhpcy5fb3B0aW9ucy53cmFwX2F0dHJpYnV0ZXMuc3Vic3RyKDAsICdwcmVzZXJ2ZScubGVuZ3RoKSA9PT0gJ3ByZXNlcnZlJztcbiAgdGhpcy5faXNfd3JhcF9hdHRyaWJ1dGVzX3ByZXNlcnZlX2FsaWduZWQgPSAodGhpcy5fb3B0aW9ucy53cmFwX2F0dHJpYnV0ZXMgPT09ICdwcmVzZXJ2ZS1hbGlnbmVkJyk7XG59XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmJlYXV0aWZ5ID0gZnVuY3Rpb24oKSB7XG5cbiAgLy8gaWYgZGlzYWJsZWQsIHJldHVybiB0aGUgaW5wdXQgdW5jaGFuZ2VkLlxuICBpZiAodGhpcy5fb3B0aW9ucy5kaXNhYmxlZCkge1xuICAgIHJldHVybiB0aGlzLl9zb3VyY2VfdGV4dDtcbiAgfVxuXG4gIHZhciBzb3VyY2VfdGV4dCA9IHRoaXMuX3NvdXJjZV90ZXh0O1xuICB2YXIgZW9sID0gdGhpcy5fb3B0aW9ucy5lb2w7XG4gIGlmICh0aGlzLl9vcHRpb25zLmVvbCA9PT0gJ2F1dG8nKSB7XG4gICAgZW9sID0gJ1xcbic7XG4gICAgaWYgKHNvdXJjZV90ZXh0ICYmIGxpbmVCcmVhay50ZXN0KHNvdXJjZV90ZXh0KSkge1xuICAgICAgZW9sID0gc291cmNlX3RleHQubWF0Y2gobGluZUJyZWFrKVswXTtcbiAgICB9XG4gIH1cblxuICAvLyBIQUNLOiBuZXdsaW5lIHBhcnNpbmcgaW5jb25zaXN0ZW50LiBUaGlzIGJydXRlIGZvcmNlIG5vcm1hbGl6ZXMgdGhlIGlucHV0LlxuICBzb3VyY2VfdGV4dCA9IHNvdXJjZV90ZXh0LnJlcGxhY2UoYWxsTGluZUJyZWFrcywgJ1xcbicpO1xuXG4gIHZhciBiYXNlSW5kZW50U3RyaW5nID0gc291cmNlX3RleHQubWF0Y2goL15bXFx0IF0qLylbMF07XG5cbiAgdmFyIGxhc3RfdG9rZW4gPSB7XG4gICAgdGV4dDogJycsXG4gICAgdHlwZTogJydcbiAgfTtcblxuICB2YXIgbGFzdF90YWdfdG9rZW4gPSBuZXcgVGFnT3BlblBhcnNlclRva2VuKCk7XG5cbiAgdmFyIHByaW50ZXIgPSBuZXcgUHJpbnRlcih0aGlzLl9vcHRpb25zLCBiYXNlSW5kZW50U3RyaW5nKTtcbiAgdmFyIHRva2VucyA9IG5ldyBUb2tlbml6ZXIoc291cmNlX3RleHQsIHRoaXMuX29wdGlvbnMpLnRva2VuaXplKCk7XG5cbiAgdGhpcy5fdGFnX3N0YWNrID0gbmV3IFRhZ1N0YWNrKHByaW50ZXIpO1xuXG4gIHZhciBwYXJzZXJfdG9rZW4gPSBudWxsO1xuICB2YXIgcmF3X3Rva2VuID0gdG9rZW5zLm5leHQoKTtcbiAgd2hpbGUgKHJhd190b2tlbi50eXBlICE9PSBUT0tFTi5FT0YpIHtcblxuICAgIGlmIChyYXdfdG9rZW4udHlwZSA9PT0gVE9LRU4uVEFHX09QRU4gfHwgcmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLkNPTU1FTlQpIHtcbiAgICAgIHBhcnNlcl90b2tlbiA9IHRoaXMuX2hhbmRsZV90YWdfb3BlbihwcmludGVyLCByYXdfdG9rZW4sIGxhc3RfdGFnX3Rva2VuLCBsYXN0X3Rva2VuLCB0b2tlbnMpO1xuICAgICAgbGFzdF90YWdfdG9rZW4gPSBwYXJzZXJfdG9rZW47XG4gICAgfSBlbHNlIGlmICgocmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLkFUVFJJQlVURSB8fCByYXdfdG9rZW4udHlwZSA9PT0gVE9LRU4uRVFVQUxTIHx8IHJhd190b2tlbi50eXBlID09PSBUT0tFTi5WQUxVRSkgfHxcbiAgICAgIChyYXdfdG9rZW4udHlwZSA9PT0gVE9LRU4uVEVYVCAmJiAhbGFzdF90YWdfdG9rZW4udGFnX2NvbXBsZXRlKSkge1xuICAgICAgcGFyc2VyX3Rva2VuID0gdGhpcy5faGFuZGxlX2luc2lkZV90YWcocHJpbnRlciwgcmF3X3Rva2VuLCBsYXN0X3RhZ190b2tlbiwgbGFzdF90b2tlbik7XG4gICAgfSBlbHNlIGlmIChyYXdfdG9rZW4udHlwZSA9PT0gVE9LRU4uVEFHX0NMT1NFKSB7XG4gICAgICBwYXJzZXJfdG9rZW4gPSB0aGlzLl9oYW5kbGVfdGFnX2Nsb3NlKHByaW50ZXIsIHJhd190b2tlbiwgbGFzdF90YWdfdG9rZW4pO1xuICAgIH0gZWxzZSBpZiAocmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLlRFWFQpIHtcbiAgICAgIHBhcnNlcl90b2tlbiA9IHRoaXMuX2hhbmRsZV90ZXh0KHByaW50ZXIsIHJhd190b2tlbiwgbGFzdF90YWdfdG9rZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4sIGJ1dCBpZiBpdCBkb2VzLiBQcmludCB0aGUgcmF3IHRva2VuXG4gICAgICBwcmludGVyLmFkZF9yYXdfdG9rZW4ocmF3X3Rva2VuKTtcbiAgICB9XG5cbiAgICBsYXN0X3Rva2VuID0gcGFyc2VyX3Rva2VuO1xuXG4gICAgcmF3X3Rva2VuID0gdG9rZW5zLm5leHQoKTtcbiAgfVxuICB2YXIgc3dlZXRfY29kZSA9IHByaW50ZXIuX291dHB1dC5nZXRfY29kZShlb2wpO1xuXG4gIHJldHVybiBzd2VldF9jb2RlO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuX2hhbmRsZV90YWdfY2xvc2UgPSBmdW5jdGlvbihwcmludGVyLCByYXdfdG9rZW4sIGxhc3RfdGFnX3Rva2VuKSB7XG4gIHZhciBwYXJzZXJfdG9rZW4gPSB7XG4gICAgdGV4dDogcmF3X3Rva2VuLnRleHQsXG4gICAgdHlwZTogcmF3X3Rva2VuLnR5cGVcbiAgfTtcbiAgcHJpbnRlci5hbGlnbm1lbnRfc2l6ZSA9IDA7XG4gIGxhc3RfdGFnX3Rva2VuLnRhZ19jb21wbGV0ZSA9IHRydWU7XG5cbiAgcHJpbnRlci5zZXRfc3BhY2VfYmVmb3JlX3Rva2VuKHJhd190b2tlbi5uZXdsaW5lcyB8fCByYXdfdG9rZW4ud2hpdGVzcGFjZV9iZWZvcmUgIT09ICcnLCB0cnVlKTtcbiAgaWYgKGxhc3RfdGFnX3Rva2VuLmlzX3VuZm9ybWF0dGVkKSB7XG4gICAgcHJpbnRlci5hZGRfcmF3X3Rva2VuKHJhd190b2tlbik7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGxhc3RfdGFnX3Rva2VuLnRhZ19zdGFydF9jaGFyID09PSAnPCcpIHtcbiAgICAgIHByaW50ZXIuc2V0X3NwYWNlX2JlZm9yZV90b2tlbihyYXdfdG9rZW4udGV4dFswXSA9PT0gJy8nLCB0cnVlKTsgLy8gc3BhY2UgYmVmb3JlIC8+LCBubyBzcGFjZSBiZWZvcmUgPlxuICAgICAgaWYgKHRoaXMuX2lzX3dyYXBfYXR0cmlidXRlc19mb3JjZV9leHBhbmRfbXVsdGlsaW5lICYmIGxhc3RfdGFnX3Rva2VuLmhhc193cmFwcGVkX2F0dHJzKSB7XG4gICAgICAgIHByaW50ZXIucHJpbnRfbmV3bGluZShmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHByaW50ZXIucHJpbnRfdG9rZW4ocmF3X3Rva2VuKTtcblxuICB9XG5cbiAgaWYgKGxhc3RfdGFnX3Rva2VuLmluZGVudF9jb250ZW50ICYmXG4gICAgIShsYXN0X3RhZ190b2tlbi5pc191bmZvcm1hdHRlZCB8fCBsYXN0X3RhZ190b2tlbi5pc19jb250ZW50X3VuZm9ybWF0dGVkKSkge1xuICAgIHByaW50ZXIuaW5kZW50KCk7XG5cbiAgICAvLyBvbmx5IGluZGVudCBvbmNlIHBlciBvcGVuZWQgdGFnXG4gICAgbGFzdF90YWdfdG9rZW4uaW5kZW50X2NvbnRlbnQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICghbGFzdF90YWdfdG9rZW4uaXNfaW5saW5lX2VsZW1lbnQgJiZcbiAgICAhKGxhc3RfdGFnX3Rva2VuLmlzX3VuZm9ybWF0dGVkIHx8IGxhc3RfdGFnX3Rva2VuLmlzX2NvbnRlbnRfdW5mb3JtYXR0ZWQpKSB7XG4gICAgcHJpbnRlci5zZXRfd3JhcF9wb2ludCgpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlcl90b2tlbjtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLl9oYW5kbGVfaW5zaWRlX3RhZyA9IGZ1bmN0aW9uKHByaW50ZXIsIHJhd190b2tlbiwgbGFzdF90YWdfdG9rZW4sIGxhc3RfdG9rZW4pIHtcbiAgdmFyIHdyYXBwZWQgPSBsYXN0X3RhZ190b2tlbi5oYXNfd3JhcHBlZF9hdHRycztcbiAgdmFyIHBhcnNlcl90b2tlbiA9IHtcbiAgICB0ZXh0OiByYXdfdG9rZW4udGV4dCxcbiAgICB0eXBlOiByYXdfdG9rZW4udHlwZVxuICB9O1xuXG4gIHByaW50ZXIuc2V0X3NwYWNlX2JlZm9yZV90b2tlbihyYXdfdG9rZW4ubmV3bGluZXMgfHwgcmF3X3Rva2VuLndoaXRlc3BhY2VfYmVmb3JlICE9PSAnJywgdHJ1ZSk7XG4gIGlmIChsYXN0X3RhZ190b2tlbi5pc191bmZvcm1hdHRlZCkge1xuICAgIHByaW50ZXIuYWRkX3Jhd190b2tlbihyYXdfdG9rZW4pO1xuICB9IGVsc2UgaWYgKGxhc3RfdGFnX3Rva2VuLnRhZ19zdGFydF9jaGFyID09PSAneycgJiYgcmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLlRFWFQpIHtcbiAgICAvLyBGb3IgdGhlIGluc2lkZXMgb2YgaGFuZGxlYmFycyBhbGxvdyBuZXdsaW5lcyBvciBhIHNpbmdsZSBzcGFjZSBiZXR3ZWVuIG9wZW4gYW5kIGNvbnRlbnRzXG4gICAgaWYgKHByaW50ZXIucHJpbnRfcHJlc2VydmVkX25ld2xpbmVzKHJhd190b2tlbikpIHtcbiAgICAgIHJhd190b2tlbi5uZXdsaW5lcyA9IDA7XG4gICAgICBwcmludGVyLmFkZF9yYXdfdG9rZW4ocmF3X3Rva2VuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJpbnRlci5wcmludF90b2tlbihyYXdfdG9rZW4pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAocmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLkFUVFJJQlVURSkge1xuICAgICAgcHJpbnRlci5zZXRfc3BhY2VfYmVmb3JlX3Rva2VuKHRydWUpO1xuICAgIH0gZWxzZSBpZiAocmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVRVUFMUykgeyAvL25vIHNwYWNlIGJlZm9yZSA9XG4gICAgICBwcmludGVyLnNldF9zcGFjZV9iZWZvcmVfdG9rZW4oZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAocmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLlZBTFVFICYmIHJhd190b2tlbi5wcmV2aW91cy50eXBlID09PSBUT0tFTi5FUVVBTFMpIHsgLy9ubyBzcGFjZSBiZWZvcmUgdmFsdWVcbiAgICAgIHByaW50ZXIuc2V0X3NwYWNlX2JlZm9yZV90b2tlbihmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKHJhd190b2tlbi50eXBlID09PSBUT0tFTi5BVFRSSUJVVEUgJiYgbGFzdF90YWdfdG9rZW4udGFnX3N0YXJ0X2NoYXIgPT09ICc8Jykge1xuICAgICAgaWYgKHRoaXMuX2lzX3dyYXBfYXR0cmlidXRlc19wcmVzZXJ2ZSB8fCB0aGlzLl9pc193cmFwX2F0dHJpYnV0ZXNfcHJlc2VydmVfYWxpZ25lZCkge1xuICAgICAgICBwcmludGVyLnRyYXZlcnNlX3doaXRlc3BhY2UocmF3X3Rva2VuKTtcbiAgICAgICAgd3JhcHBlZCA9IHdyYXBwZWQgfHwgcmF3X3Rva2VuLm5ld2xpbmVzICE9PSAwO1xuICAgICAgfVxuXG4gICAgICAvLyBXcmFwIGZvciAnZm9yY2UnIG9wdGlvbnMsIGFuZCBpZiB0aGUgbnVtYmVyIG9mIGF0dHJpYnV0ZXMgaXMgYXQgbGVhc3QgdGhhdCBzcGVjaWZpZWQgaW4gJ3dyYXBfYXR0cmlidXRlc19taW5fYXR0cnMnOlxuICAgICAgLy8gMS4gYWx3YXlzIHdyYXAgdGhlIHNlY29uZCBhbmQgYmV5b25kIGF0dHJpYnV0ZXNcbiAgICAgIC8vIDIuIHdyYXAgdGhlIGZpcnN0IGF0dHJpYnV0ZSBvbmx5IGlmICdmb3JjZS1leHBhbmQtbXVsdGlsaW5lJyBpcyBzcGVjaWZpZWRcbiAgICAgIGlmICh0aGlzLl9pc193cmFwX2F0dHJpYnV0ZXNfZm9yY2UgJiZcbiAgICAgICAgbGFzdF90YWdfdG9rZW4uYXR0cl9jb3VudCA+PSB0aGlzLl9vcHRpb25zLndyYXBfYXR0cmlidXRlc19taW5fYXR0cnMgJiZcbiAgICAgICAgKGxhc3RfdG9rZW4udHlwZSAhPT0gVE9LRU4uVEFHX09QRU4gfHwgLy8gaWUuIHNlY29uZCBhdHRyaWJ1dGUgYW5kIGJleW9uZFxuICAgICAgICAgIHRoaXMuX2lzX3dyYXBfYXR0cmlidXRlc19mb3JjZV9leHBhbmRfbXVsdGlsaW5lKSkge1xuICAgICAgICBwcmludGVyLnByaW50X25ld2xpbmUoZmFsc2UpO1xuICAgICAgICB3cmFwcGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJpbnRlci5wcmludF90b2tlbihyYXdfdG9rZW4pO1xuICAgIHdyYXBwZWQgPSB3cmFwcGVkIHx8IHByaW50ZXIucHJldmlvdXNfdG9rZW5fd3JhcHBlZCgpO1xuICAgIGxhc3RfdGFnX3Rva2VuLmhhc193cmFwcGVkX2F0dHJzID0gd3JhcHBlZDtcbiAgfVxuICByZXR1cm4gcGFyc2VyX3Rva2VuO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuX2hhbmRsZV90ZXh0ID0gZnVuY3Rpb24ocHJpbnRlciwgcmF3X3Rva2VuLCBsYXN0X3RhZ190b2tlbikge1xuICB2YXIgcGFyc2VyX3Rva2VuID0ge1xuICAgIHRleHQ6IHJhd190b2tlbi50ZXh0LFxuICAgIHR5cGU6ICdUS19DT05URU5UJ1xuICB9O1xuICBpZiAobGFzdF90YWdfdG9rZW4uY3VzdG9tX2JlYXV0aWZpZXJfbmFtZSkgeyAvL2NoZWNrIGlmIHdlIG5lZWQgdG8gZm9ybWF0IGphdmFzY3JpcHRcbiAgICB0aGlzLl9wcmludF9jdXN0b21fYmVhdGlmaWVyX3RleHQocHJpbnRlciwgcmF3X3Rva2VuLCBsYXN0X3RhZ190b2tlbik7XG4gIH0gZWxzZSBpZiAobGFzdF90YWdfdG9rZW4uaXNfdW5mb3JtYXR0ZWQgfHwgbGFzdF90YWdfdG9rZW4uaXNfY29udGVudF91bmZvcm1hdHRlZCkge1xuICAgIHByaW50ZXIuYWRkX3Jhd190b2tlbihyYXdfdG9rZW4pO1xuICB9IGVsc2Uge1xuICAgIHByaW50ZXIudHJhdmVyc2Vfd2hpdGVzcGFjZShyYXdfdG9rZW4pO1xuICAgIHByaW50ZXIucHJpbnRfdG9rZW4ocmF3X3Rva2VuKTtcbiAgfVxuICByZXR1cm4gcGFyc2VyX3Rva2VuO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuX3ByaW50X2N1c3RvbV9iZWF0aWZpZXJfdGV4dCA9IGZ1bmN0aW9uKHByaW50ZXIsIHJhd190b2tlbiwgbGFzdF90YWdfdG9rZW4pIHtcbiAgdmFyIGxvY2FsID0gdGhpcztcbiAgaWYgKHJhd190b2tlbi50ZXh0ICE9PSAnJykge1xuXG4gICAgdmFyIHRleHQgPSByYXdfdG9rZW4udGV4dCxcbiAgICAgIF9iZWF1dGlmaWVyLFxuICAgICAgc2NyaXB0X2luZGVudF9sZXZlbCA9IDEsXG4gICAgICBwcmUgPSAnJyxcbiAgICAgIHBvc3QgPSAnJztcbiAgICBpZiAobGFzdF90YWdfdG9rZW4uY3VzdG9tX2JlYXV0aWZpZXJfbmFtZSA9PT0gJ2phdmFzY3JpcHQnICYmIHR5cGVvZiB0aGlzLl9qc19iZWF1dGlmeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgX2JlYXV0aWZpZXIgPSB0aGlzLl9qc19iZWF1dGlmeTtcbiAgICB9IGVsc2UgaWYgKGxhc3RfdGFnX3Rva2VuLmN1c3RvbV9iZWF1dGlmaWVyX25hbWUgPT09ICdjc3MnICYmIHR5cGVvZiB0aGlzLl9jc3NfYmVhdXRpZnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIF9iZWF1dGlmaWVyID0gdGhpcy5fY3NzX2JlYXV0aWZ5O1xuICAgIH0gZWxzZSBpZiAobGFzdF90YWdfdG9rZW4uY3VzdG9tX2JlYXV0aWZpZXJfbmFtZSA9PT0gJ2h0bWwnKSB7XG4gICAgICBfYmVhdXRpZmllciA9IGZ1bmN0aW9uKGh0bWxfc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBiZWF1dGlmaWVyID0gbmV3IEJlYXV0aWZpZXIoaHRtbF9zb3VyY2UsIG9wdGlvbnMsIGxvY2FsLl9qc19iZWF1dGlmeSwgbG9jYWwuX2Nzc19iZWF1dGlmeSk7XG4gICAgICAgIHJldHVybiBiZWF1dGlmaWVyLmJlYXV0aWZ5KCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vcHRpb25zLmluZGVudF9zY3JpcHRzID09PSBcImtlZXBcIikge1xuICAgICAgc2NyaXB0X2luZGVudF9sZXZlbCA9IDA7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vcHRpb25zLmluZGVudF9zY3JpcHRzID09PSBcInNlcGFyYXRlXCIpIHtcbiAgICAgIHNjcmlwdF9pbmRlbnRfbGV2ZWwgPSAtcHJpbnRlci5pbmRlbnRfbGV2ZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZGVudGF0aW9uID0gcHJpbnRlci5nZXRfZnVsbF9pbmRlbnQoc2NyaXB0X2luZGVudF9sZXZlbCk7XG5cbiAgICAvLyBpZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgZW1wdHkgbGluZSBhdCB0aGUgZW5kIG9mIHRoaXMgdGV4dCwgc3RyaXAgaXRcbiAgICAvLyB3ZSdsbCBiZSBhZGRpbmcgb25lIGJhY2sgYWZ0ZXIgdGhlIHRleHQgYnV0IGJlZm9yZSB0aGUgY29udGFpbmluZyB0YWcuXG4gICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxuWyBcXHRdKiQvLCAnJyk7XG5cbiAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgY29udGVudCBpcyB3cmFwcGVkIGluIGEgY29tbWVudCBvciBjZGF0YS5cbiAgICBpZiAobGFzdF90YWdfdG9rZW4uY3VzdG9tX2JlYXV0aWZpZXJfbmFtZSAhPT0gJ2h0bWwnICYmXG4gICAgICB0ZXh0WzBdID09PSAnPCcgJiYgdGV4dC5tYXRjaCgvXig8IS0tfDwhXFxbQ0RBVEFcXFspLykpIHtcbiAgICAgIHZhciBtYXRjaGVkID0gL14oPCEtLVteXFxuXSp8PCFcXFtDREFUQVxcWykoXFxuPykoWyBcXHRcXG5dKikoW1xcc1xcU10qKSgtLT58XV0+KSQvLmV4ZWModGV4dCk7XG5cbiAgICAgIC8vIGlmIHdlIHN0YXJ0IHRvIHdyYXAgYnV0IGRvbid0IGZpbmlzaCwgcHJpbnQgcmF3XG4gICAgICBpZiAoIW1hdGNoZWQpIHtcbiAgICAgICAgcHJpbnRlci5hZGRfcmF3X3Rva2VuKHJhd190b2tlbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcHJlID0gaW5kZW50YXRpb24gKyBtYXRjaGVkWzFdICsgJ1xcbic7XG4gICAgICB0ZXh0ID0gbWF0Y2hlZFs0XTtcbiAgICAgIGlmIChtYXRjaGVkWzVdKSB7XG4gICAgICAgIHBvc3QgPSBpbmRlbnRhdGlvbiArIG1hdGNoZWRbNV07XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBlbXB0eSBsaW5lIGF0IHRoZSBlbmQgb2YgdGhpcyB0ZXh0LCBzdHJpcCBpdFxuICAgICAgLy8gd2UnbGwgYmUgYWRkaW5nIG9uZSBiYWNrIGFmdGVyIHRoZSB0ZXh0IGJ1dCBiZWZvcmUgdGhlIGNvbnRhaW5pbmcgdGFnLlxuICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxuWyBcXHRdKiQvLCAnJyk7XG5cbiAgICAgIGlmIChtYXRjaGVkWzJdIHx8IG1hdGNoZWRbM10uaW5kZXhPZignXFxuJykgIT09IC0xKSB7XG4gICAgICAgIC8vIGlmIHRoZSBmaXJzdCBsaW5lIG9mIHRoZSBub24tY29tbWVudCB0ZXh0IGhhcyBzcGFjZXNcbiAgICAgICAgLy8gdXNlIHRoYXQgYXMgdGhlIGJhc2lzIGZvciBpbmRlbnRpbmcgaW4gbnVsbCBjYXNlLlxuICAgICAgICBtYXRjaGVkID0gbWF0Y2hlZFszXS5tYXRjaCgvWyBcXHRdKyQvKTtcbiAgICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICByYXdfdG9rZW4ud2hpdGVzcGFjZV9iZWZvcmUgPSBtYXRjaGVkWzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRleHQpIHtcbiAgICAgIGlmIChfYmVhdXRpZmllcikge1xuXG4gICAgICAgIC8vIGNhbGwgdGhlIEJlYXV0aWZpZXIgaWYgYXZhbGlhYmxlXG4gICAgICAgIHZhciBDaGlsZF9vcHRpb25zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5lb2wgPSAnXFxuJztcbiAgICAgICAgfTtcbiAgICAgICAgQ2hpbGRfb3B0aW9ucy5wcm90b3R5cGUgPSB0aGlzLl9vcHRpb25zLnJhd19vcHRpb25zO1xuICAgICAgICB2YXIgY2hpbGRfb3B0aW9ucyA9IG5ldyBDaGlsZF9vcHRpb25zKCk7XG4gICAgICAgIHRleHQgPSBfYmVhdXRpZmllcihpbmRlbnRhdGlvbiArIHRleHQsIGNoaWxkX29wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc2ltcGx5IGluZGVudCB0aGUgc3RyaW5nIG90aGVyd2lzZVxuICAgICAgICB2YXIgd2hpdGUgPSByYXdfdG9rZW4ud2hpdGVzcGFjZV9iZWZvcmU7XG4gICAgICAgIGlmICh3aGl0ZSkge1xuICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxuKCcgKyB3aGl0ZSArICcpPycsICdnJyksICdcXG4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRleHQgPSBpbmRlbnRhdGlvbiArIHRleHQucmVwbGFjZSgvXFxuL2csICdcXG4nICsgaW5kZW50YXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmUpIHtcbiAgICAgIGlmICghdGV4dCkge1xuICAgICAgICB0ZXh0ID0gcHJlICsgcG9zdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBwcmUgKyB0ZXh0ICsgJ1xcbicgKyBwb3N0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHByaW50ZXIucHJpbnRfbmV3bGluZShmYWxzZSk7XG4gICAgaWYgKHRleHQpIHtcbiAgICAgIHJhd190b2tlbi50ZXh0ID0gdGV4dDtcbiAgICAgIHJhd190b2tlbi53aGl0ZXNwYWNlX2JlZm9yZSA9ICcnO1xuICAgICAgcmF3X3Rva2VuLm5ld2xpbmVzID0gMDtcbiAgICAgIHByaW50ZXIuYWRkX3Jhd190b2tlbihyYXdfdG9rZW4pO1xuICAgICAgcHJpbnRlci5wcmludF9uZXdsaW5lKHRydWUpO1xuICAgIH1cbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuX2hhbmRsZV90YWdfb3BlbiA9IGZ1bmN0aW9uKHByaW50ZXIsIHJhd190b2tlbiwgbGFzdF90YWdfdG9rZW4sIGxhc3RfdG9rZW4sIHRva2Vucykge1xuICB2YXIgcGFyc2VyX3Rva2VuID0gdGhpcy5fZ2V0X3RhZ19vcGVuX3Rva2VuKHJhd190b2tlbik7XG5cbiAgaWYgKChsYXN0X3RhZ190b2tlbi5pc191bmZvcm1hdHRlZCB8fCBsYXN0X3RhZ190b2tlbi5pc19jb250ZW50X3VuZm9ybWF0dGVkKSAmJlxuICAgICFsYXN0X3RhZ190b2tlbi5pc19lbXB0eV9lbGVtZW50ICYmXG4gICAgcmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLlRBR19PUEVOICYmICFwYXJzZXJfdG9rZW4uaXNfc3RhcnRfdGFnKSB7XG4gICAgLy8gRW5kIGVsZW1lbnQgdGFncyBmb3IgdW5mb3JtYXR0ZWQgb3IgY29udGVudF91bmZvcm1hdHRlZCBlbGVtZW50c1xuICAgIC8vIGFyZSBwcmludGVkIHJhdyB0byBrZWVwIGFueSBuZXdsaW5lcyBpbnNpZGUgdGhlbSBleGFjdGx5IHRoZSBzYW1lLlxuICAgIHByaW50ZXIuYWRkX3Jhd190b2tlbihyYXdfdG9rZW4pO1xuICAgIHBhcnNlcl90b2tlbi5zdGFydF90YWdfdG9rZW4gPSB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcChwYXJzZXJfdG9rZW4udGFnX25hbWUpO1xuICB9IGVsc2Uge1xuICAgIHByaW50ZXIudHJhdmVyc2Vfd2hpdGVzcGFjZShyYXdfdG9rZW4pO1xuICAgIHRoaXMuX3NldF90YWdfcG9zaXRpb24ocHJpbnRlciwgcmF3X3Rva2VuLCBwYXJzZXJfdG9rZW4sIGxhc3RfdGFnX3Rva2VuLCBsYXN0X3Rva2VuKTtcbiAgICBpZiAoIXBhcnNlcl90b2tlbi5pc19pbmxpbmVfZWxlbWVudCkge1xuICAgICAgcHJpbnRlci5zZXRfd3JhcF9wb2ludCgpO1xuICAgIH1cbiAgICBwcmludGVyLnByaW50X3Rva2VuKHJhd190b2tlbik7XG4gIH1cblxuICAvLyBjb3VudCB0aGUgbnVtYmVyIG9mIGF0dHJpYnV0ZXNcbiAgaWYgKHBhcnNlcl90b2tlbi5pc19zdGFydF90YWcgJiYgdGhpcy5faXNfd3JhcF9hdHRyaWJ1dGVzX2ZvcmNlKSB7XG4gICAgdmFyIHBlZWtfaW5kZXggPSAwO1xuICAgIHZhciBwZWVrX3Rva2VuO1xuICAgIGRvIHtcbiAgICAgIHBlZWtfdG9rZW4gPSB0b2tlbnMucGVlayhwZWVrX2luZGV4KTtcbiAgICAgIGlmIChwZWVrX3Rva2VuLnR5cGUgPT09IFRPS0VOLkFUVFJJQlVURSkge1xuICAgICAgICBwYXJzZXJfdG9rZW4uYXR0cl9jb3VudCArPSAxO1xuICAgICAgfVxuICAgICAgcGVla19pbmRleCArPSAxO1xuICAgIH0gd2hpbGUgKHBlZWtfdG9rZW4udHlwZSAhPT0gVE9LRU4uRU9GICYmIHBlZWtfdG9rZW4udHlwZSAhPT0gVE9LRU4uVEFHX0NMT1NFKTtcbiAgfVxuXG4gIC8vaW5kZW50IGF0dHJpYnV0ZXMgYW4gYXV0bywgZm9yY2VkLCBhbGlnbmVkIG9yIGZvcmNlZC1hbGlnbiBsaW5lLXdyYXBcbiAgaWYgKHRoaXMuX2lzX3dyYXBfYXR0cmlidXRlc19mb3JjZV9hbGlnbmVkIHx8IHRoaXMuX2lzX3dyYXBfYXR0cmlidXRlc19hbGlnbmVkX211bHRpcGxlIHx8IHRoaXMuX2lzX3dyYXBfYXR0cmlidXRlc19wcmVzZXJ2ZV9hbGlnbmVkKSB7XG4gICAgcGFyc2VyX3Rva2VuLmFsaWdubWVudF9zaXplID0gcmF3X3Rva2VuLnRleHQubGVuZ3RoICsgMTtcbiAgfVxuXG4gIGlmICghcGFyc2VyX3Rva2VuLnRhZ19jb21wbGV0ZSAmJiAhcGFyc2VyX3Rva2VuLmlzX3VuZm9ybWF0dGVkKSB7XG4gICAgcHJpbnRlci5hbGlnbm1lbnRfc2l6ZSA9IHBhcnNlcl90b2tlbi5hbGlnbm1lbnRfc2l6ZTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZXJfdG9rZW47XG59O1xuXG52YXIgVGFnT3BlblBhcnNlclRva2VuID0gZnVuY3Rpb24ocGFyZW50LCByYXdfdG9rZW4pIHtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQgfHwgbnVsbDtcbiAgdGhpcy50ZXh0ID0gJyc7XG4gIHRoaXMudHlwZSA9ICdUS19UQUdfT1BFTic7XG4gIHRoaXMudGFnX25hbWUgPSAnJztcbiAgdGhpcy5pc19pbmxpbmVfZWxlbWVudCA9IGZhbHNlO1xuICB0aGlzLmlzX3VuZm9ybWF0dGVkID0gZmFsc2U7XG4gIHRoaXMuaXNfY29udGVudF91bmZvcm1hdHRlZCA9IGZhbHNlO1xuICB0aGlzLmlzX2VtcHR5X2VsZW1lbnQgPSBmYWxzZTtcbiAgdGhpcy5pc19zdGFydF90YWcgPSBmYWxzZTtcbiAgdGhpcy5pc19lbmRfdGFnID0gZmFsc2U7XG4gIHRoaXMuaW5kZW50X2NvbnRlbnQgPSBmYWxzZTtcbiAgdGhpcy5tdWx0aWxpbmVfY29udGVudCA9IGZhbHNlO1xuICB0aGlzLmN1c3RvbV9iZWF1dGlmaWVyX25hbWUgPSBudWxsO1xuICB0aGlzLnN0YXJ0X3RhZ190b2tlbiA9IG51bGw7XG4gIHRoaXMuYXR0cl9jb3VudCA9IDA7XG4gIHRoaXMuaGFzX3dyYXBwZWRfYXR0cnMgPSBmYWxzZTtcbiAgdGhpcy5hbGlnbm1lbnRfc2l6ZSA9IDA7XG4gIHRoaXMudGFnX2NvbXBsZXRlID0gZmFsc2U7XG4gIHRoaXMudGFnX3N0YXJ0X2NoYXIgPSAnJztcbiAgdGhpcy50YWdfY2hlY2sgPSAnJztcblxuICBpZiAoIXJhd190b2tlbikge1xuICAgIHRoaXMudGFnX2NvbXBsZXRlID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFnX2NoZWNrX21hdGNoO1xuXG4gICAgdGhpcy50YWdfc3RhcnRfY2hhciA9IHJhd190b2tlbi50ZXh0WzBdO1xuICAgIHRoaXMudGV4dCA9IHJhd190b2tlbi50ZXh0O1xuXG4gICAgaWYgKHRoaXMudGFnX3N0YXJ0X2NoYXIgPT09ICc8Jykge1xuICAgICAgdGFnX2NoZWNrX21hdGNoID0gcmF3X3Rva2VuLnRleHQubWF0Y2goL148KFteXFxzPl0qKS8pO1xuICAgICAgdGhpcy50YWdfY2hlY2sgPSB0YWdfY2hlY2tfbWF0Y2ggPyB0YWdfY2hlY2tfbWF0Y2hbMV0gOiAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgdGFnX2NoZWNrX21hdGNoID0gcmF3X3Rva2VuLnRleHQubWF0Y2goL157e34/KD86W1xcXl18I1xcKj8pPyhbXlxcc31dKykvKTtcbiAgICAgIHRoaXMudGFnX2NoZWNrID0gdGFnX2NoZWNrX21hdGNoID8gdGFnX2NoZWNrX21hdGNoWzFdIDogJyc7XG5cbiAgICAgIC8vIGhhbmRsZSBcInt7Iz4gbXlQYXJ0aWFsfX1cIiBvciBcInt7fiM+IG15UGFydGlhbH19XCJcbiAgICAgIGlmICgocmF3X3Rva2VuLnRleHQuc3RhcnRzV2l0aCgne3sjPicpIHx8IHJhd190b2tlbi50ZXh0LnN0YXJ0c1dpdGgoJ3t7fiM+JykpICYmIHRoaXMudGFnX2NoZWNrWzBdID09PSAnPicpIHtcbiAgICAgICAgaWYgKHRoaXMudGFnX2NoZWNrID09PSAnPicgJiYgcmF3X3Rva2VuLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnRhZ19jaGVjayA9IHJhd190b2tlbi5uZXh0LnRleHQuc3BsaXQoJyAnKVswXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnRhZ19jaGVjayA9IHJhd190b2tlbi50ZXh0LnNwbGl0KCc+JylbMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnRhZ19jaGVjayA9IHRoaXMudGFnX2NoZWNrLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAocmF3X3Rva2VuLnR5cGUgPT09IFRPS0VOLkNPTU1FTlQpIHtcbiAgICAgIHRoaXMudGFnX2NvbXBsZXRlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmlzX3N0YXJ0X3RhZyA9IHRoaXMudGFnX2NoZWNrLmNoYXJBdCgwKSAhPT0gJy8nO1xuICAgIHRoaXMudGFnX25hbWUgPSAhdGhpcy5pc19zdGFydF90YWcgPyB0aGlzLnRhZ19jaGVjay5zdWJzdHIoMSkgOiB0aGlzLnRhZ19jaGVjaztcbiAgICB0aGlzLmlzX2VuZF90YWcgPSAhdGhpcy5pc19zdGFydF90YWcgfHxcbiAgICAgIChyYXdfdG9rZW4uY2xvc2VkICYmIHJhd190b2tlbi5jbG9zZWQudGV4dCA9PT0gJy8+Jyk7XG5cbiAgICAvLyBpZiB3aGl0ZXNwYWNlIGhhbmRsZXIgfiBpbmNsdWRlZCAoaS5lLiB7e34jaWYgdHJ1ZX19KSwgaGFuZGxlYmFycyB0YWdzIHN0YXJ0IGF0IHBvcyAzIG5vdCBwb3MgMlxuICAgIHZhciBoYW5kbGViYXJfc3RhcnRzID0gMjtcbiAgICBpZiAodGhpcy50YWdfc3RhcnRfY2hhciA9PT0gJ3snICYmIHRoaXMudGV4dC5sZW5ndGggPj0gMykge1xuICAgICAgaWYgKHRoaXMudGV4dC5jaGFyQXQoMikgPT09ICd+Jykge1xuICAgICAgICBoYW5kbGViYXJfc3RhcnRzID0gMztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBoYW5kbGViYXJzIHRhZ3MgdGhhdCBkb24ndCBzdGFydCB3aXRoICMgb3IgXiBhcmUgc2luZ2xlX3RhZ3MsIGFuZCBzbyBhbHNvIHN0YXJ0IGFuZCBlbmQuXG4gICAgdGhpcy5pc19lbmRfdGFnID0gdGhpcy5pc19lbmRfdGFnIHx8XG4gICAgICAodGhpcy50YWdfc3RhcnRfY2hhciA9PT0gJ3snICYmICh0aGlzLnRleHQubGVuZ3RoIDwgMyB8fCAoL1teI1xcXl0vLnRlc3QodGhpcy50ZXh0LmNoYXJBdChoYW5kbGViYXJfc3RhcnRzKSkpKSk7XG4gIH1cbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLl9nZXRfdGFnX29wZW5fdG9rZW4gPSBmdW5jdGlvbihyYXdfdG9rZW4pIHsgLy9mdW5jdGlvbiB0byBnZXQgYSBmdWxsIHRhZyBhbmQgcGFyc2UgaXRzIHR5cGVcbiAgdmFyIHBhcnNlcl90b2tlbiA9IG5ldyBUYWdPcGVuUGFyc2VyVG9rZW4odGhpcy5fdGFnX3N0YWNrLmdldF9wYXJzZXJfdG9rZW4oKSwgcmF3X3Rva2VuKTtcblxuICBwYXJzZXJfdG9rZW4uYWxpZ25tZW50X3NpemUgPSB0aGlzLl9vcHRpb25zLndyYXBfYXR0cmlidXRlc19pbmRlbnRfc2l6ZTtcblxuICBwYXJzZXJfdG9rZW4uaXNfZW5kX3RhZyA9IHBhcnNlcl90b2tlbi5pc19lbmRfdGFnIHx8XG4gICAgaW5fYXJyYXkocGFyc2VyX3Rva2VuLnRhZ19jaGVjaywgdGhpcy5fb3B0aW9ucy52b2lkX2VsZW1lbnRzKTtcblxuICBwYXJzZXJfdG9rZW4uaXNfZW1wdHlfZWxlbWVudCA9IHBhcnNlcl90b2tlbi50YWdfY29tcGxldGUgfHxcbiAgICAocGFyc2VyX3Rva2VuLmlzX3N0YXJ0X3RhZyAmJiBwYXJzZXJfdG9rZW4uaXNfZW5kX3RhZyk7XG5cbiAgcGFyc2VyX3Rva2VuLmlzX3VuZm9ybWF0dGVkID0gIXBhcnNlcl90b2tlbi50YWdfY29tcGxldGUgJiYgaW5fYXJyYXkocGFyc2VyX3Rva2VuLnRhZ19jaGVjaywgdGhpcy5fb3B0aW9ucy51bmZvcm1hdHRlZCk7XG4gIHBhcnNlcl90b2tlbi5pc19jb250ZW50X3VuZm9ybWF0dGVkID0gIXBhcnNlcl90b2tlbi5pc19lbXB0eV9lbGVtZW50ICYmIGluX2FycmF5KHBhcnNlcl90b2tlbi50YWdfY2hlY2ssIHRoaXMuX29wdGlvbnMuY29udGVudF91bmZvcm1hdHRlZCk7XG4gIHBhcnNlcl90b2tlbi5pc19pbmxpbmVfZWxlbWVudCA9IGluX2FycmF5KHBhcnNlcl90b2tlbi50YWdfbmFtZSwgdGhpcy5fb3B0aW9ucy5pbmxpbmUpIHx8ICh0aGlzLl9vcHRpb25zLmlubGluZV9jdXN0b21fZWxlbWVudHMgJiYgcGFyc2VyX3Rva2VuLnRhZ19uYW1lLmluY2x1ZGVzKFwiLVwiKSkgfHwgcGFyc2VyX3Rva2VuLnRhZ19zdGFydF9jaGFyID09PSAneyc7XG5cbiAgcmV0dXJuIHBhcnNlcl90b2tlbjtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLl9zZXRfdGFnX3Bvc2l0aW9uID0gZnVuY3Rpb24ocHJpbnRlciwgcmF3X3Rva2VuLCBwYXJzZXJfdG9rZW4sIGxhc3RfdGFnX3Rva2VuLCBsYXN0X3Rva2VuKSB7XG5cbiAgaWYgKCFwYXJzZXJfdG9rZW4uaXNfZW1wdHlfZWxlbWVudCkge1xuICAgIGlmIChwYXJzZXJfdG9rZW4uaXNfZW5kX3RhZykgeyAvL3RoaXMgdGFnIGlzIGEgZG91YmxlIHRhZyBzbyBjaGVjayBmb3IgdGFnLWVuZGluZ1xuICAgICAgcGFyc2VyX3Rva2VuLnN0YXJ0X3RhZ190b2tlbiA9IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKHBhcnNlcl90b2tlbi50YWdfbmFtZSk7IC8vcmVtb3ZlIGl0IGFuZCBhbGwgYW5jZXN0b3JzXG4gICAgfSBlbHNlIHsgLy8gaXQncyBhIHN0YXJ0LXRhZ1xuICAgICAgLy8gY2hlY2sgaWYgdGhpcyB0YWcgaXMgc3RhcnRpbmcgYW4gZWxlbWVudCB0aGF0IGhhcyBvcHRpb25hbCBlbmQgZWxlbWVudFxuICAgICAgLy8gYW5kIGRvIGFuIGVuZGluZyBuZWVkZWRcbiAgICAgIGlmICh0aGlzLl9kb19vcHRpb25hbF9lbmRfZWxlbWVudChwYXJzZXJfdG9rZW4pKSB7XG4gICAgICAgIGlmICghcGFyc2VyX3Rva2VuLmlzX2lubGluZV9lbGVtZW50KSB7XG4gICAgICAgICAgcHJpbnRlci5wcmludF9uZXdsaW5lKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl90YWdfc3RhY2sucmVjb3JkX3RhZyhwYXJzZXJfdG9rZW4pOyAvL3B1c2ggaXQgb24gdGhlIHRhZyBzdGFja1xuXG4gICAgICBpZiAoKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ3NjcmlwdCcgfHwgcGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAnc3R5bGUnKSAmJlxuICAgICAgICAhKHBhcnNlcl90b2tlbi5pc191bmZvcm1hdHRlZCB8fCBwYXJzZXJfdG9rZW4uaXNfY29udGVudF91bmZvcm1hdHRlZCkpIHtcbiAgICAgICAgcGFyc2VyX3Rva2VuLmN1c3RvbV9iZWF1dGlmaWVyX25hbWUgPSBnZXRfY3VzdG9tX2JlYXV0aWZpZXJfbmFtZShwYXJzZXJfdG9rZW4udGFnX2NoZWNrLCByYXdfdG9rZW4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpbl9hcnJheShwYXJzZXJfdG9rZW4udGFnX2NoZWNrLCB0aGlzLl9vcHRpb25zLmV4dHJhX2xpbmVycykpIHsgLy9jaGVjayBpZiB0aGlzIGRvdWJsZSBuZWVkcyBhbiBleHRyYSBsaW5lXG4gICAgcHJpbnRlci5wcmludF9uZXdsaW5lKGZhbHNlKTtcbiAgICBpZiAoIXByaW50ZXIuX291dHB1dC5qdXN0X2FkZGVkX2JsYW5rbGluZSgpKSB7XG4gICAgICBwcmludGVyLnByaW50X25ld2xpbmUodHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHBhcnNlcl90b2tlbi5pc19lbXB0eV9lbGVtZW50KSB7IC8vaWYgdGhpcyB0YWcgbmFtZSBpcyBhIHNpbmdsZSB0YWcgdHlwZSAoZWl0aGVyIGluIHRoZSBsaXN0IG9yIGhhcyBhIGNsb3NpbmcgLylcblxuICAgIC8vIGlmIHlvdSBoaXQgYW4gZWxzZSBjYXNlLCByZXNldCB0aGUgaW5kZW50IGxldmVsIGlmIHlvdSBhcmUgaW5zaWRlIGFuOlxuICAgIC8vICdpZicsICd1bmxlc3MnLCBvciAnZWFjaCcgYmxvY2suXG4gICAgaWYgKHBhcnNlcl90b2tlbi50YWdfc3RhcnRfY2hhciA9PT0gJ3snICYmIHBhcnNlcl90b2tlbi50YWdfY2hlY2sgPT09ICdlbHNlJykge1xuICAgICAgdGhpcy5fdGFnX3N0YWNrLmluZGVudF90b190YWcoWydpZicsICd1bmxlc3MnLCAnZWFjaCddKTtcbiAgICAgIHBhcnNlcl90b2tlbi5pbmRlbnRfY29udGVudCA9IHRydWU7XG4gICAgICAvLyBEb24ndCBhZGQgYSBuZXdsaW5lIGlmIG9wZW5pbmcge3sjaWZ9fSB0YWcgaXMgb24gdGhlIGN1cnJlbnQgbGluZVxuICAgICAgdmFyIGZvdW5kSWZPbkN1cnJlbnRMaW5lID0gcHJpbnRlci5jdXJyZW50X2xpbmVfaGFzX21hdGNoKC97eyNpZi8pO1xuICAgICAgaWYgKCFmb3VuZElmT25DdXJyZW50TGluZSkge1xuICAgICAgICBwcmludGVyLnByaW50X25ld2xpbmUoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERvbid0IGFkZCBhIG5ld2xpbmUgYmVmb3JlIGVsZW1lbnRzIHRoYXQgc2hvdWxkIHJlbWFpbiB3aGVyZSB0aGV5IGFyZS5cbiAgICBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAnIS0tJyAmJiBsYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlRBR19DTE9TRSAmJlxuICAgICAgbGFzdF90YWdfdG9rZW4uaXNfZW5kX3RhZyAmJiBwYXJzZXJfdG9rZW4udGV4dC5pbmRleE9mKCdcXG4nKSA9PT0gLTEpIHtcbiAgICAgIC8vRG8gbm90aGluZy4gTGVhdmUgY29tbWVudHMgb24gc2FtZSBsaW5lLlxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIShwYXJzZXJfdG9rZW4uaXNfaW5saW5lX2VsZW1lbnQgfHwgcGFyc2VyX3Rva2VuLmlzX3VuZm9ybWF0dGVkKSkge1xuICAgICAgICBwcmludGVyLnByaW50X25ld2xpbmUoZmFsc2UpO1xuICAgICAgfVxuICAgICAgdGhpcy5fY2FsY2x1YXRlX3BhcmVudF9tdWx0aWxpbmUocHJpbnRlciwgcGFyc2VyX3Rva2VuKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocGFyc2VyX3Rva2VuLmlzX2VuZF90YWcpIHsgLy90aGlzIHRhZyBpcyBhIGRvdWJsZSB0YWcgc28gY2hlY2sgZm9yIHRhZy1lbmRpbmdcbiAgICB2YXIgZG9fZW5kX2V4cGFuZCA9IGZhbHNlO1xuXG4gICAgLy8gZGVjaWRpbmcgd2hldGhlciBhIGJsb2NrIGlzIG11bHRpbGluZSBzaG91bGQgbm90IGJlIHRoaXMgaGFyZFxuICAgIGRvX2VuZF9leHBhbmQgPSBwYXJzZXJfdG9rZW4uc3RhcnRfdGFnX3Rva2VuICYmIHBhcnNlcl90b2tlbi5zdGFydF90YWdfdG9rZW4ubXVsdGlsaW5lX2NvbnRlbnQ7XG4gICAgZG9fZW5kX2V4cGFuZCA9IGRvX2VuZF9leHBhbmQgfHwgKCFwYXJzZXJfdG9rZW4uaXNfaW5saW5lX2VsZW1lbnQgJiZcbiAgICAgICEobGFzdF90YWdfdG9rZW4uaXNfaW5saW5lX2VsZW1lbnQgfHwgbGFzdF90YWdfdG9rZW4uaXNfdW5mb3JtYXR0ZWQpICYmXG4gICAgICAhKGxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uVEFHX0NMT1NFICYmIHBhcnNlcl90b2tlbi5zdGFydF90YWdfdG9rZW4gPT09IGxhc3RfdGFnX3Rva2VuKSAmJlxuICAgICAgbGFzdF90b2tlbi50eXBlICE9PSAnVEtfQ09OVEVOVCdcbiAgICApO1xuXG4gICAgaWYgKHBhcnNlcl90b2tlbi5pc19jb250ZW50X3VuZm9ybWF0dGVkIHx8IHBhcnNlcl90b2tlbi5pc191bmZvcm1hdHRlZCkge1xuICAgICAgZG9fZW5kX2V4cGFuZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChkb19lbmRfZXhwYW5kKSB7XG4gICAgICBwcmludGVyLnByaW50X25ld2xpbmUoZmFsc2UpO1xuICAgIH1cbiAgfSBlbHNlIHsgLy8gaXQncyBhIHN0YXJ0LXRhZ1xuICAgIHBhcnNlcl90b2tlbi5pbmRlbnRfY29udGVudCA9ICFwYXJzZXJfdG9rZW4uY3VzdG9tX2JlYXV0aWZpZXJfbmFtZTtcblxuICAgIGlmIChwYXJzZXJfdG9rZW4udGFnX3N0YXJ0X2NoYXIgPT09ICc8Jykge1xuICAgICAgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ2h0bWwnKSB7XG4gICAgICAgIHBhcnNlcl90b2tlbi5pbmRlbnRfY29udGVudCA9IHRoaXMuX29wdGlvbnMuaW5kZW50X2lubmVyX2h0bWw7XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ2hlYWQnKSB7XG4gICAgICAgIHBhcnNlcl90b2tlbi5pbmRlbnRfY29udGVudCA9IHRoaXMuX29wdGlvbnMuaW5kZW50X2hlYWRfaW5uZXJfaHRtbDtcbiAgICAgIH0gZWxzZSBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAnYm9keScpIHtcbiAgICAgICAgcGFyc2VyX3Rva2VuLmluZGVudF9jb250ZW50ID0gdGhpcy5fb3B0aW9ucy5pbmRlbnRfYm9keV9pbm5lcl9odG1sO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghKHBhcnNlcl90b2tlbi5pc19pbmxpbmVfZWxlbWVudCB8fCBwYXJzZXJfdG9rZW4uaXNfdW5mb3JtYXR0ZWQpICYmXG4gICAgICAobGFzdF90b2tlbi50eXBlICE9PSAnVEtfQ09OVEVOVCcgfHwgcGFyc2VyX3Rva2VuLmlzX2NvbnRlbnRfdW5mb3JtYXR0ZWQpKSB7XG4gICAgICBwcmludGVyLnByaW50X25ld2xpbmUoZmFsc2UpO1xuICAgIH1cblxuICAgIHRoaXMuX2NhbGNsdWF0ZV9wYXJlbnRfbXVsdGlsaW5lKHByaW50ZXIsIHBhcnNlcl90b2tlbik7XG4gIH1cbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLl9jYWxjbHVhdGVfcGFyZW50X211bHRpbGluZSA9IGZ1bmN0aW9uKHByaW50ZXIsIHBhcnNlcl90b2tlbikge1xuICBpZiAocGFyc2VyX3Rva2VuLnBhcmVudCAmJiBwcmludGVyLl9vdXRwdXQuanVzdF9hZGRlZF9uZXdsaW5lKCkgJiZcbiAgICAhKChwYXJzZXJfdG9rZW4uaXNfaW5saW5lX2VsZW1lbnQgfHwgcGFyc2VyX3Rva2VuLmlzX3VuZm9ybWF0dGVkKSAmJiBwYXJzZXJfdG9rZW4ucGFyZW50LmlzX2lubGluZV9lbGVtZW50KSkge1xuICAgIHBhcnNlcl90b2tlbi5wYXJlbnQubXVsdGlsaW5lX2NvbnRlbnQgPSB0cnVlO1xuICB9XG59O1xuXG4vL1RvIGJlIHVzZWQgZm9yIDxwPiB0YWcgc3BlY2lhbCBjYXNlOlxudmFyIHBfY2xvc2VycyA9IFsnYWRkcmVzcycsICdhcnRpY2xlJywgJ2FzaWRlJywgJ2Jsb2NrcXVvdGUnLCAnZGV0YWlscycsICdkaXYnLCAnZGwnLCAnZmllbGRzZXQnLCAnZmlnY2FwdGlvbicsICdmaWd1cmUnLCAnZm9vdGVyJywgJ2Zvcm0nLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZGVyJywgJ2hyJywgJ21haW4nLCAnbWVudScsICduYXYnLCAnb2wnLCAncCcsICdwcmUnLCAnc2VjdGlvbicsICd0YWJsZScsICd1bCddO1xudmFyIHBfcGFyZW50X2V4Y2x1ZGVzID0gWydhJywgJ2F1ZGlvJywgJ2RlbCcsICdpbnMnLCAnbWFwJywgJ25vc2NyaXB0JywgJ3ZpZGVvJ107XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLl9kb19vcHRpb25hbF9lbmRfZWxlbWVudCA9IGZ1bmN0aW9uKHBhcnNlcl90b2tlbikge1xuICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgLy8gTk9URTogY2FzZXMgb2YgXCJpZiB0aGVyZSBpcyBubyBtb3JlIGNvbnRlbnQgaW4gdGhlIHBhcmVudCBlbGVtZW50XCJcbiAgLy8gYXJlIGhhbmRsZWQgYXV0b21hdGljYWxseSBieSB0aGUgYmVhdXRpZmllci5cbiAgLy8gSXQgYXNzdW1lcyBwYXJlbnQgb3IgYW5jZXN0b3IgY2xvc2UgdGFnIGNsb3NlcyBhbGwgY2hpbGRyZW4uXG4gIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNvcHRpb25hbC10YWdzXG4gIGlmIChwYXJzZXJfdG9rZW4uaXNfZW1wdHlfZWxlbWVudCB8fCAhcGFyc2VyX3Rva2VuLmlzX3N0YXJ0X3RhZyB8fCAhcGFyc2VyX3Rva2VuLnBhcmVudCkge1xuICAgIHJldHVybjtcblxuICB9XG5cbiAgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ2JvZHknKSB7XG4gICAgLy8gQSBoZWFkIGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIGhlYWQgZWxlbWVudCBpcyBub3QgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYSBzcGFjZSBjaGFyYWN0ZXIgb3IgYSBjb21tZW50LlxuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgnaGVhZCcpO1xuXG4gICAgLy99IGVsc2UgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ2JvZHknKSB7XG4gICAgLy8gRE9ORTogQSBib2R5IGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIGJvZHkgZWxlbWVudCBpcyBub3QgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYSBjb21tZW50LlxuXG4gIH0gZWxzZSBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAnbGknKSB7XG4gICAgLy8gQW4gbGkgZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgbGkgZWxlbWVudCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhbm90aGVyIGxpIGVsZW1lbnQgb3IgaWYgdGhlcmUgaXMgbm8gbW9yZSBjb250ZW50IGluIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ2xpJywgWydvbCcsICd1bCcsICdtZW51J10pO1xuXG4gIH0gZWxzZSBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAnZGQnIHx8IHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ2R0Jykge1xuICAgIC8vIEEgZGQgZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgZGQgZWxlbWVudCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhbm90aGVyIGRkIGVsZW1lbnQgb3IgYSBkdCBlbGVtZW50LCBvciBpZiB0aGVyZSBpcyBubyBtb3JlIGNvbnRlbnQgaW4gdGhlIHBhcmVudCBlbGVtZW50LlxuICAgIC8vIEEgZHQgZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgZHQgZWxlbWVudCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhbm90aGVyIGR0IGVsZW1lbnQgb3IgYSBkZCBlbGVtZW50LlxuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgnZHQnLCBbJ2RsJ10pO1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgnZGQnLCBbJ2RsJ10pO1xuXG5cbiAgfSBlbHNlIGlmIChwYXJzZXJfdG9rZW4ucGFyZW50LnRhZ19uYW1lID09PSAncCcgJiYgcF9jbG9zZXJzLmluZGV4T2YocGFyc2VyX3Rva2VuLnRhZ19uYW1lKSAhPT0gLTEpIHtcbiAgICAvLyBJTVBPUlRBTlQ6IHRoaXMgZWxzZS1pZiB3b3JrcyBiZWNhdXNlIHBfY2xvc2VycyBoYXMgbm8gb3ZlcmxhcCB3aXRoIGFueSBvdGhlciBlbGVtZW50IHdlIGxvb2sgZm9yIGluIHRoaXMgbWV0aG9kXG4gICAgLy8gY2hlY2sgZm9yIHRoZSBwYXJlbnQgZWxlbWVudCBpcyBhbiBIVE1MIGVsZW1lbnQgdGhhdCBpcyBub3QgYW4gPGE+LCA8YXVkaW8+LCA8ZGVsPiwgPGlucz4sIDxtYXA+LCA8bm9zY3JpcHQ+LCBvciA8dmlkZW8+IGVsZW1lbnQsICBvciBhbiBhdXRvbm9tb3VzIGN1c3RvbSBlbGVtZW50LlxuICAgIC8vIFRvIGRvIHRoaXMgcmlnaHQsIHRoaXMgbmVlZHMgdG8gYmUgY29kZWQgYXMgYW4gaW5jbHVzaW9uIG9mIHRoZSBpbnZlcnNlIG9mIHRoZSBleGNsdXNpb24gYWJvdmUuXG4gICAgLy8gQnV0IHRvIHN0YXJ0IHdpdGggKGlmIHdlIGlnbm9yZSBcImF1dG9ub21vdXMgY3VzdG9tIGVsZW1lbnRzXCIpIHRoZSBleGNsdXNpb24gd291bGQgYmUgZmluZS5cbiAgICB2YXIgcF9wYXJlbnQgPSBwYXJzZXJfdG9rZW4ucGFyZW50LnBhcmVudDtcbiAgICBpZiAoIXBfcGFyZW50IHx8IHBfcGFyZW50X2V4Y2x1ZGVzLmluZGV4T2YocF9wYXJlbnQudGFnX25hbWUpID09PSAtMSkge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCdwJyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ3JwJyB8fCBwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICdydCcpIHtcbiAgICAvLyBBbiBydCBlbGVtZW504oCZcyBlbmQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSBydCBlbGVtZW50IGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGFuIHJ0IG9yIHJwIGVsZW1lbnQsIG9yIGlmIHRoZXJlIGlzIG5vIG1vcmUgY29udGVudCBpbiB0aGUgcGFyZW50IGVsZW1lbnQuXG4gICAgLy8gQW4gcnAgZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgcnAgZWxlbWVudCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhbiBydCBvciBycCBlbGVtZW50LCBvciBpZiB0aGVyZSBpcyBubyBtb3JlIGNvbnRlbnQgaW4gdGhlIHBhcmVudCBlbGVtZW50LlxuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgncnQnLCBbJ3J1YnknLCAncnRjJ10pO1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgncnAnLCBbJ3J1YnknLCAncnRjJ10pO1xuXG4gIH0gZWxzZSBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAnb3B0Z3JvdXAnKSB7XG4gICAgLy8gQW4gb3B0Z3JvdXAgZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgb3B0Z3JvdXAgZWxlbWVudCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhbm90aGVyIG9wdGdyb3VwIGVsZW1lbnQsIG9yIGlmIHRoZXJlIGlzIG5vIG1vcmUgY29udGVudCBpbiB0aGUgcGFyZW50IGVsZW1lbnQuXG4gICAgLy8gQW4gb3B0aW9uIGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIG9wdGlvbiBlbGVtZW50IGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGFub3RoZXIgb3B0aW9uIGVsZW1lbnQsIG9yIGlmIGl0IGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGFuIG9wdGdyb3VwIGVsZW1lbnQsIG9yIGlmIHRoZXJlIGlzIG5vIG1vcmUgY29udGVudCBpbiB0aGUgcGFyZW50IGVsZW1lbnQuXG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCdvcHRncm91cCcsIFsnc2VsZWN0J10pO1xuICAgIC8vcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCdvcHRpb24nLCBbJ3NlbGVjdCddKTtcblxuICB9IGVsc2UgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ29wdGlvbicpIHtcbiAgICAvLyBBbiBvcHRpb24gZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgb3B0aW9uIGVsZW1lbnQgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYW5vdGhlciBvcHRpb24gZWxlbWVudCwgb3IgaWYgaXQgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYW4gb3B0Z3JvdXAgZWxlbWVudCwgb3IgaWYgdGhlcmUgaXMgbm8gbW9yZSBjb250ZW50IGluIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5fdGFnX3N0YWNrLnRyeV9wb3AoJ29wdGlvbicsIFsnc2VsZWN0JywgJ2RhdGFsaXN0JywgJ29wdGdyb3VwJ10pO1xuXG4gIH0gZWxzZSBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAnY29sZ3JvdXAnKSB7XG4gICAgLy8gRE9ORTogQSBjb2xncm91cCBlbGVtZW504oCZcyBlbmQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSBjb2xncm91cCBlbGVtZW50IGlzIG5vdCBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhIHNwYWNlIGNoYXJhY3RlciBvciBhIGNvbW1lbnQuXG4gICAgLy8gQSBjYXB0aW9uIGVsZW1lbnQncyBlbmQgdGFnIG1heSBiZSBvbW1pdHRlZCBpZiBhIGNvbGdyb3VwLCB0aGVhZCwgdGZvb3QsIHRib2R5LCBvciB0ciBlbGVtZW50IGlzIHN0YXJ0ZWQuXG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCdjYXB0aW9uJywgWyd0YWJsZSddKTtcblxuICB9IGVsc2UgaWYgKHBhcnNlcl90b2tlbi50YWdfbmFtZSA9PT0gJ3RoZWFkJykge1xuICAgIC8vIEEgY29sZ3JvdXAgZWxlbWVudCdzIGVuZCB0YWcgbWF5IGJlIG9tbWl0dGVkIGlmIGEgdGhlYWQsIHRmb290LCB0Ym9keSwgb3IgdHIgZWxlbWVudCBpcyBzdGFydGVkLlxuICAgIC8vIEEgY2FwdGlvbiBlbGVtZW50J3MgZW5kIHRhZyBtYXkgYmUgb21taXR0ZWQgaWYgYSBjb2xncm91cCwgdGhlYWQsIHRmb290LCB0Ym9keSwgb3IgdHIgZWxlbWVudCBpcyBzdGFydGVkLlxuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgnY2FwdGlvbicsIFsndGFibGUnXSk7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCdjb2xncm91cCcsIFsndGFibGUnXSk7XG5cbiAgICAvL30gZWxzZSBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAnY2FwdGlvbicpIHtcbiAgICAvLyBET05FOiBBIGNhcHRpb24gZWxlbWVudOKAmXMgZW5kIHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgY2FwdGlvbiBlbGVtZW50IGlzIG5vdCBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhIHNwYWNlIGNoYXJhY3RlciBvciBhIGNvbW1lbnQuXG5cbiAgfSBlbHNlIGlmIChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICd0Ym9keScgfHwgcGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAndGZvb3QnKSB7XG4gICAgLy8gQSB0aGVhZCBlbGVtZW504oCZcyBlbmQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSB0aGVhZCBlbGVtZW50IGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGEgdGJvZHkgb3IgdGZvb3QgZWxlbWVudC5cbiAgICAvLyBBIHRib2R5IGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIHRib2R5IGVsZW1lbnQgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYSB0Ym9keSBvciB0Zm9vdCBlbGVtZW50LCBvciBpZiB0aGVyZSBpcyBubyBtb3JlIGNvbnRlbnQgaW4gdGhlIHBhcmVudCBlbGVtZW50LlxuICAgIC8vIEEgY29sZ3JvdXAgZWxlbWVudCdzIGVuZCB0YWcgbWF5IGJlIG9tbWl0dGVkIGlmIGEgdGhlYWQsIHRmb290LCB0Ym9keSwgb3IgdHIgZWxlbWVudCBpcyBzdGFydGVkLlxuICAgIC8vIEEgY2FwdGlvbiBlbGVtZW50J3MgZW5kIHRhZyBtYXkgYmUgb21taXR0ZWQgaWYgYSBjb2xncm91cCwgdGhlYWQsIHRmb290LCB0Ym9keSwgb3IgdHIgZWxlbWVudCBpcyBzdGFydGVkLlxuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgnY2FwdGlvbicsIFsndGFibGUnXSk7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCdjb2xncm91cCcsIFsndGFibGUnXSk7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCd0aGVhZCcsIFsndGFibGUnXSk7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCd0Ym9keScsIFsndGFibGUnXSk7XG5cbiAgICAvL30gZWxzZSBpZiAocGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAndGZvb3QnKSB7XG4gICAgLy8gRE9ORTogQSB0Zm9vdCBlbGVtZW504oCZcyBlbmQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZXJlIGlzIG5vIG1vcmUgY29udGVudCBpbiB0aGUgcGFyZW50IGVsZW1lbnQuXG5cbiAgfSBlbHNlIGlmIChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICd0cicpIHtcbiAgICAvLyBBIHRyIGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIHRyIGVsZW1lbnQgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYW5vdGhlciB0ciBlbGVtZW50LCBvciBpZiB0aGVyZSBpcyBubyBtb3JlIGNvbnRlbnQgaW4gdGhlIHBhcmVudCBlbGVtZW50LlxuICAgIC8vIEEgY29sZ3JvdXAgZWxlbWVudCdzIGVuZCB0YWcgbWF5IGJlIG9tbWl0dGVkIGlmIGEgdGhlYWQsIHRmb290LCB0Ym9keSwgb3IgdHIgZWxlbWVudCBpcyBzdGFydGVkLlxuICAgIC8vIEEgY2FwdGlvbiBlbGVtZW50J3MgZW5kIHRhZyBtYXkgYmUgb21taXR0ZWQgaWYgYSBjb2xncm91cCwgdGhlYWQsIHRmb290LCB0Ym9keSwgb3IgdHIgZWxlbWVudCBpcyBzdGFydGVkLlxuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgnY2FwdGlvbicsIFsndGFibGUnXSk7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCdjb2xncm91cCcsIFsndGFibGUnXSk7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuX3RhZ19zdGFjay50cnlfcG9wKCd0cicsIFsndGFibGUnLCAndGhlYWQnLCAndGJvZHknLCAndGZvb3QnXSk7XG5cbiAgfSBlbHNlIGlmIChwYXJzZXJfdG9rZW4udGFnX25hbWUgPT09ICd0aCcgfHwgcGFyc2VyX3Rva2VuLnRhZ19uYW1lID09PSAndGQnKSB7XG4gICAgLy8gQSB0ZCBlbGVtZW504oCZcyBlbmQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSB0ZCBlbGVtZW50IGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGEgdGQgb3IgdGggZWxlbWVudCwgb3IgaWYgdGhlcmUgaXMgbm8gbW9yZSBjb250ZW50IGluIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgICAvLyBBIHRoIGVsZW1lbnTigJlzIGVuZCB0YWcgbWF5IGJlIG9taXR0ZWQgaWYgdGhlIHRoIGVsZW1lbnQgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYSB0ZCBvciB0aCBlbGVtZW50LCBvciBpZiB0aGVyZSBpcyBubyBtb3JlIGNvbnRlbnQgaW4gdGhlIHBhcmVudCBlbGVtZW50LlxuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgndGQnLCBbJ3RhYmxlJywgJ3RoZWFkJywgJ3Rib2R5JywgJ3Rmb290JywgJ3RyJ10pO1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLl90YWdfc3RhY2sudHJ5X3BvcCgndGgnLCBbJ3RhYmxlJywgJ3RoZWFkJywgJ3Rib2R5JywgJ3Rmb290JywgJ3RyJ10pO1xuICB9XG5cbiAgLy8gU3RhcnQgZWxlbWVudCBvbWlzc2lvbiBub3QgaGFuZGxlZCBjdXJyZW50bHlcbiAgLy8gQSBoZWFkIGVsZW1lbnTigJlzIHN0YXJ0IHRhZyBtYXkgYmUgb21pdHRlZCBpZiB0aGUgZWxlbWVudCBpcyBlbXB0eSwgb3IgaWYgdGhlIGZpcnN0IHRoaW5nIGluc2lkZSB0aGUgaGVhZCBlbGVtZW50IGlzIGFuIGVsZW1lbnQuXG4gIC8vIEEgdGJvZHkgZWxlbWVudOKAmXMgc3RhcnQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSBmaXJzdCB0aGluZyBpbnNpZGUgdGhlIHRib2R5IGVsZW1lbnQgaXMgYSB0ciBlbGVtZW50LCBhbmQgaWYgdGhlIGVsZW1lbnQgaXMgbm90IGltbWVkaWF0ZWx5IHByZWNlZGVkIGJ5IGEgdGJvZHksIHRoZWFkLCBvciB0Zm9vdCBlbGVtZW50IHdob3NlIGVuZCB0YWcgaGFzIGJlZW4gb21pdHRlZC4gKEl0IGNhbuKAmXQgYmUgb21pdHRlZCBpZiB0aGUgZWxlbWVudCBpcyBlbXB0eS4pXG4gIC8vIEEgY29sZ3JvdXAgZWxlbWVudOKAmXMgc3RhcnQgdGFnIG1heSBiZSBvbWl0dGVkIGlmIHRoZSBmaXJzdCB0aGluZyBpbnNpZGUgdGhlIGNvbGdyb3VwIGVsZW1lbnQgaXMgYSBjb2wgZWxlbWVudCwgYW5kIGlmIHRoZSBlbGVtZW50IGlzIG5vdCBpbW1lZGlhdGVseSBwcmVjZWRlZCBieSBhbm90aGVyIGNvbGdyb3VwIGVsZW1lbnQgd2hvc2UgZW5kIHRhZyBoYXMgYmVlbiBvbWl0dGVkLiAoSXQgY2Fu4oCZdCBiZSBvbWl0dGVkIGlmIHRoZSBlbGVtZW50IGlzIGVtcHR5LilcblxuICAvLyBGaXggdXAgdGhlIHBhcmVudCBvZiB0aGUgcGFyc2VyIHRva2VuXG4gIHBhcnNlcl90b2tlbi5wYXJlbnQgPSB0aGlzLl90YWdfc3RhY2suZ2V0X3BhcnNlcl90b2tlbigpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5CZWF1dGlmaWVyID0gQmVhdXRpZmllcjtcblxuXG4vKioqLyB9KSxcbi8qIDIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG52YXIgQmFzZU9wdGlvbnMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXyg2KS5PcHRpb25zKTtcblxuZnVuY3Rpb24gT3B0aW9ucyhvcHRpb25zKSB7XG4gIEJhc2VPcHRpb25zLmNhbGwodGhpcywgb3B0aW9ucywgJ2h0bWwnKTtcbiAgaWYgKHRoaXMudGVtcGxhdGluZy5sZW5ndGggPT09IDEgJiYgdGhpcy50ZW1wbGF0aW5nWzBdID09PSAnYXV0bycpIHtcbiAgICB0aGlzLnRlbXBsYXRpbmcgPSBbJ2RqYW5nbycsICdlcmInLCAnaGFuZGxlYmFycycsICdwaHAnXTtcbiAgfVxuXG4gIHRoaXMuaW5kZW50X2lubmVyX2h0bWwgPSB0aGlzLl9nZXRfYm9vbGVhbignaW5kZW50X2lubmVyX2h0bWwnKTtcbiAgdGhpcy5pbmRlbnRfYm9keV9pbm5lcl9odG1sID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ2luZGVudF9ib2R5X2lubmVyX2h0bWwnLCB0cnVlKTtcbiAgdGhpcy5pbmRlbnRfaGVhZF9pbm5lcl9odG1sID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ2luZGVudF9oZWFkX2lubmVyX2h0bWwnLCB0cnVlKTtcblxuICB0aGlzLmluZGVudF9oYW5kbGViYXJzID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ2luZGVudF9oYW5kbGViYXJzJywgdHJ1ZSk7XG4gIHRoaXMud3JhcF9hdHRyaWJ1dGVzID0gdGhpcy5fZ2V0X3NlbGVjdGlvbignd3JhcF9hdHRyaWJ1dGVzJyxcbiAgICBbJ2F1dG8nLCAnZm9yY2UnLCAnZm9yY2UtYWxpZ25lZCcsICdmb3JjZS1leHBhbmQtbXVsdGlsaW5lJywgJ2FsaWduZWQtbXVsdGlwbGUnLCAncHJlc2VydmUnLCAncHJlc2VydmUtYWxpZ25lZCddKTtcbiAgdGhpcy53cmFwX2F0dHJpYnV0ZXNfbWluX2F0dHJzID0gdGhpcy5fZ2V0X251bWJlcignd3JhcF9hdHRyaWJ1dGVzX21pbl9hdHRycycsIDIpO1xuICB0aGlzLndyYXBfYXR0cmlidXRlc19pbmRlbnRfc2l6ZSA9IHRoaXMuX2dldF9udW1iZXIoJ3dyYXBfYXR0cmlidXRlc19pbmRlbnRfc2l6ZScsIHRoaXMuaW5kZW50X3NpemUpO1xuICB0aGlzLmV4dHJhX2xpbmVycyA9IHRoaXMuX2dldF9hcnJheSgnZXh0cmFfbGluZXJzJywgWydoZWFkJywgJ2JvZHknLCAnL2h0bWwnXSk7XG5cbiAgLy8gQmxvY2sgdnMgaW5saW5lIGVsZW1lbnRzXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQmxvY2stbGV2ZWxfZWxlbWVudHNcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9JbmxpbmVfZWxlbWVudHNcbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2RvbS5odG1sI3BocmFzaW5nLWNvbnRlbnRcbiAgdGhpcy5pbmxpbmUgPSB0aGlzLl9nZXRfYXJyYXkoJ2lubGluZScsIFtcbiAgICAnYScsICdhYmJyJywgJ2FyZWEnLCAnYXVkaW8nLCAnYicsICdiZGknLCAnYmRvJywgJ2JyJywgJ2J1dHRvbicsICdjYW52YXMnLCAnY2l0ZScsXG4gICAgJ2NvZGUnLCAnZGF0YScsICdkYXRhbGlzdCcsICdkZWwnLCAnZGZuJywgJ2VtJywgJ2VtYmVkJywgJ2knLCAnaWZyYW1lJywgJ2ltZycsXG4gICAgJ2lucHV0JywgJ2lucycsICdrYmQnLCAna2V5Z2VuJywgJ2xhYmVsJywgJ21hcCcsICdtYXJrJywgJ21hdGgnLCAnbWV0ZXInLCAnbm9zY3JpcHQnLFxuICAgICdvYmplY3QnLCAnb3V0cHV0JywgJ3Byb2dyZXNzJywgJ3EnLCAncnVieScsICdzJywgJ3NhbXAnLCAvKiAnc2NyaXB0JywgKi8gJ3NlbGVjdCcsICdzbWFsbCcsXG4gICAgJ3NwYW4nLCAnc3Ryb25nJywgJ3N1YicsICdzdXAnLCAnc3ZnJywgJ3RlbXBsYXRlJywgJ3RleHRhcmVhJywgJ3RpbWUnLCAndScsICd2YXInLFxuICAgICd2aWRlbycsICd3YnInLCAndGV4dCcsXG4gICAgLy8gb2Jzb2xldGUgaW5saW5lIHRhZ3NcbiAgICAnYWNyb255bScsICdiaWcnLCAnc3RyaWtlJywgJ3R0J1xuICBdKTtcbiAgdGhpcy5pbmxpbmVfY3VzdG9tX2VsZW1lbnRzID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ2lubGluZV9jdXN0b21fZWxlbWVudHMnLCB0cnVlKTtcbiAgdGhpcy52b2lkX2VsZW1lbnRzID0gdGhpcy5fZ2V0X2FycmF5KCd2b2lkX2VsZW1lbnRzJywgW1xuICAgIC8vIEhUTE0gdm9pZCBlbGVtZW50cyAtIGFrYSBzZWxmLWNsb3NpbmcgdGFncyAtIGFrYSBzaW5nbGV0b25zXG4gICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL2h0bWwvd2cvZHJhZnRzL2h0bWwvbWFzdGVyL3N5bnRheC5odG1sI3ZvaWQtZWxlbWVudHNcbiAgICAnYXJlYScsICdiYXNlJywgJ2JyJywgJ2NvbCcsICdlbWJlZCcsICdocicsICdpbWcnLCAnaW5wdXQnLCAna2V5Z2VuJyxcbiAgICAnbGluaycsICdtZW51aXRlbScsICdtZXRhJywgJ3BhcmFtJywgJ3NvdXJjZScsICd0cmFjaycsICd3YnInLFxuICAgIC8vIE5PVEU6IE9wdGlvbmFsIHRhZ3MgYXJlIHRvbyBjb21wbGV4IGZvciBhIHNpbXBsZSBsaXN0XG4gICAgLy8gdGhleSBhcmUgaGFyZCBjb2RlZCBpbiBfZG9fb3B0aW9uYWxfZW5kX2VsZW1lbnRcblxuICAgIC8vIERvY3R5cGUgYW5kIHhtbCBlbGVtZW50c1xuICAgICchZG9jdHlwZScsICc/eG1sJyxcblxuICAgIC8vIG9ic29sZXRlIHRhZ3NcbiAgICAvLyBiYXNlZm9udDogaHR0cHM6Ly93d3cuY29tcHV0ZXJob3BlLmNvbS9qYXJnb24vaC9odG1sLWJhc2Vmb250LXRhZy5odG1cbiAgICAvLyBpc25kZXg6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pc2luZGV4XG4gICAgJ2Jhc2Vmb250JywgJ2lzaW5kZXgnXG4gIF0pO1xuICB0aGlzLnVuZm9ybWF0dGVkID0gdGhpcy5fZ2V0X2FycmF5KCd1bmZvcm1hdHRlZCcsIFtdKTtcbiAgdGhpcy5jb250ZW50X3VuZm9ybWF0dGVkID0gdGhpcy5fZ2V0X2FycmF5KCdjb250ZW50X3VuZm9ybWF0dGVkJywgW1xuICAgICdwcmUnLCAndGV4dGFyZWEnXG4gIF0pO1xuICB0aGlzLnVuZm9ybWF0dGVkX2NvbnRlbnRfZGVsaW1pdGVyID0gdGhpcy5fZ2V0X2NoYXJhY3RlcnMoJ3VuZm9ybWF0dGVkX2NvbnRlbnRfZGVsaW1pdGVyJyk7XG4gIHRoaXMuaW5kZW50X3NjcmlwdHMgPSB0aGlzLl9nZXRfc2VsZWN0aW9uKCdpbmRlbnRfc2NyaXB0cycsIFsnbm9ybWFsJywgJ2tlZXAnLCAnc2VwYXJhdGUnXSk7XG5cbn1cbk9wdGlvbnMucHJvdG90eXBlID0gbmV3IEJhc2VPcHRpb25zKCk7XG5cblxuXG5tb2R1bGUuZXhwb3J0cy5PcHRpb25zID0gT3B0aW9ucztcblxuXG4vKioqLyB9KSxcbi8qIDIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG52YXIgQmFzZVRva2VuaXplciA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDkpLlRva2VuaXplcik7XG52YXIgQkFTRVRPS0VOID0gKF9fd2VicGFja19yZXF1aXJlX18oOSkuVE9LRU4pO1xudmFyIERpcmVjdGl2ZXMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxMykuRGlyZWN0aXZlcyk7XG52YXIgVGVtcGxhdGFibGVQYXR0ZXJuID0gKF9fd2VicGFja19yZXF1aXJlX18oMTQpLlRlbXBsYXRhYmxlUGF0dGVybik7XG52YXIgUGF0dGVybiA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKS5QYXR0ZXJuKTtcblxudmFyIFRPS0VOID0ge1xuICBUQUdfT1BFTjogJ1RLX1RBR19PUEVOJyxcbiAgVEFHX0NMT1NFOiAnVEtfVEFHX0NMT1NFJyxcbiAgQVRUUklCVVRFOiAnVEtfQVRUUklCVVRFJyxcbiAgRVFVQUxTOiAnVEtfRVFVQUxTJyxcbiAgVkFMVUU6ICdUS19WQUxVRScsXG4gIENPTU1FTlQ6ICdUS19DT01NRU5UJyxcbiAgVEVYVDogJ1RLX1RFWFQnLFxuICBVTktOT1dOOiAnVEtfVU5LTk9XTicsXG4gIFNUQVJUOiBCQVNFVE9LRU4uU1RBUlQsXG4gIFJBVzogQkFTRVRPS0VOLlJBVyxcbiAgRU9GOiBCQVNFVE9LRU4uRU9GXG59O1xuXG52YXIgZGlyZWN0aXZlc19jb3JlID0gbmV3IERpcmVjdGl2ZXMoLzxcXCEtLS8sIC8tLT4vKTtcblxudmFyIFRva2VuaXplciA9IGZ1bmN0aW9uKGlucHV0X3N0cmluZywgb3B0aW9ucykge1xuICBCYXNlVG9rZW5pemVyLmNhbGwodGhpcywgaW5wdXRfc3RyaW5nLCBvcHRpb25zKTtcbiAgdGhpcy5fY3VycmVudF90YWdfbmFtZSA9ICcnO1xuXG4gIC8vIFdvcmRzIGVuZCBhdCB3aGl0ZXNwYWNlIG9yIHdoZW4gYSB0YWcgc3RhcnRzXG4gIC8vIGlmIHdlIGFyZSBpbmRlbnRpbmcgaGFuZGxlYmFycywgdGhleSBhcmUgY29uc2lkZXJlZCB0YWdzXG4gIHZhciB0ZW1wbGF0YWJsZV9yZWFkZXIgPSBuZXcgVGVtcGxhdGFibGVQYXR0ZXJuKHRoaXMuX2lucHV0KS5yZWFkX29wdGlvbnModGhpcy5fb3B0aW9ucyk7XG4gIHZhciBwYXR0ZXJuX3JlYWRlciA9IG5ldyBQYXR0ZXJuKHRoaXMuX2lucHV0KTtcblxuICB0aGlzLl9fcGF0dGVybnMgPSB7XG4gICAgd29yZDogdGVtcGxhdGFibGVfcmVhZGVyLnVudGlsKC9bXFxuXFxyXFx0IDxdLyksXG4gICAgc2luZ2xlX3F1b3RlOiB0ZW1wbGF0YWJsZV9yZWFkZXIudW50aWxfYWZ0ZXIoLycvKSxcbiAgICBkb3VibGVfcXVvdGU6IHRlbXBsYXRhYmxlX3JlYWRlci51bnRpbF9hZnRlcigvXCIvKSxcbiAgICBhdHRyaWJ1dGU6IHRlbXBsYXRhYmxlX3JlYWRlci51bnRpbCgvW1xcblxcclxcdCA9Pl18XFwvPi8pLFxuICAgIGVsZW1lbnRfbmFtZTogdGVtcGxhdGFibGVfcmVhZGVyLnVudGlsKC9bXFxuXFxyXFx0ID5cXC9dLyksXG5cbiAgICBoYW5kbGViYXJzX2NvbW1lbnQ6IHBhdHRlcm5fcmVhZGVyLnN0YXJ0aW5nX3dpdGgoL3t7IS0tLykudW50aWxfYWZ0ZXIoLy0tfX0vKSxcbiAgICBoYW5kbGViYXJzOiBwYXR0ZXJuX3JlYWRlci5zdGFydGluZ193aXRoKC97ey8pLnVudGlsX2FmdGVyKC99fS8pLFxuICAgIGhhbmRsZWJhcnNfb3BlbjogcGF0dGVybl9yZWFkZXIudW50aWwoL1tcXG5cXHJcXHQgfV0vKSxcbiAgICBoYW5kbGViYXJzX3Jhd19jbG9zZTogcGF0dGVybl9yZWFkZXIudW50aWwoL319LyksXG4gICAgY29tbWVudDogcGF0dGVybl9yZWFkZXIuc3RhcnRpbmdfd2l0aCgvPCEtLS8pLnVudGlsX2FmdGVyKC8tLT4vKSxcbiAgICBjZGF0YTogcGF0dGVybl9yZWFkZXIuc3RhcnRpbmdfd2l0aCgvPCFcXFtDREFUQVxcWy8pLnVudGlsX2FmdGVyKC9dXT4vKSxcbiAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db25kaXRpb25hbF9jb21tZW50XG4gICAgY29uZGl0aW9uYWxfY29tbWVudDogcGF0dGVybl9yZWFkZXIuc3RhcnRpbmdfd2l0aCgvPCFcXFsvKS51bnRpbF9hZnRlcigvXT4vKSxcbiAgICBwcm9jZXNzaW5nOiBwYXR0ZXJuX3JlYWRlci5zdGFydGluZ193aXRoKC88XFw/LykudW50aWxfYWZ0ZXIoL1xcPz4vKVxuICB9O1xuXG4gIGlmICh0aGlzLl9vcHRpb25zLmluZGVudF9oYW5kbGViYXJzKSB7XG4gICAgdGhpcy5fX3BhdHRlcm5zLndvcmQgPSB0aGlzLl9fcGF0dGVybnMud29yZC5leGNsdWRlKCdoYW5kbGViYXJzJyk7XG4gIH1cblxuICB0aGlzLl91bmZvcm1hdHRlZF9jb250ZW50X2RlbGltaXRlciA9IG51bGw7XG5cbiAgaWYgKHRoaXMuX29wdGlvbnMudW5mb3JtYXR0ZWRfY29udGVudF9kZWxpbWl0ZXIpIHtcbiAgICB2YXIgbGl0ZXJhbF9yZWdleHAgPSB0aGlzLl9pbnB1dC5nZXRfbGl0ZXJhbF9yZWdleHAodGhpcy5fb3B0aW9ucy51bmZvcm1hdHRlZF9jb250ZW50X2RlbGltaXRlcik7XG4gICAgdGhpcy5fX3BhdHRlcm5zLnVuZm9ybWF0dGVkX2NvbnRlbnRfZGVsaW1pdGVyID1cbiAgICAgIHBhdHRlcm5fcmVhZGVyLm1hdGNoaW5nKGxpdGVyYWxfcmVnZXhwKVxuICAgICAgLnVudGlsX2FmdGVyKGxpdGVyYWxfcmVnZXhwKTtcbiAgfVxufTtcblRva2VuaXplci5wcm90b3R5cGUgPSBuZXcgQmFzZVRva2VuaXplcigpO1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9pc19jb21tZW50ID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikgeyAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHJldHVybiBmYWxzZTsgLy9jdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLkNPTU1FTlQgfHwgY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5VTktOT1dOO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5faXNfb3BlbmluZyA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgcmV0dXJuIGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uVEFHX09QRU47XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9pc19jbG9zaW5nID0gZnVuY3Rpb24oY3VycmVudF90b2tlbiwgb3Blbl90b2tlbikge1xuICByZXR1cm4gY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5UQUdfQ0xPU0UgJiZcbiAgICAob3Blbl90b2tlbiAmJiAoXG4gICAgICAoKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJz4nIHx8IGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJy8+JykgJiYgb3Blbl90b2tlbi50ZXh0WzBdID09PSAnPCcpIHx8XG4gICAgICAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnfX0nICYmIG9wZW5fdG9rZW4udGV4dFswXSA9PT0gJ3snICYmIG9wZW5fdG9rZW4udGV4dFsxXSA9PT0gJ3snKSkpO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY3VycmVudF90YWdfbmFtZSA9ICcnO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fZ2V0X25leHRfdG9rZW4gPSBmdW5jdGlvbihwcmV2aW91c190b2tlbiwgb3Blbl90b2tlbikgeyAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHZhciB0b2tlbiA9IG51bGw7XG4gIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG4gIHZhciBjID0gdGhpcy5faW5wdXQucGVlaygpO1xuXG4gIGlmIChjID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5FT0YsICcnKTtcbiAgfVxuXG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9vcGVuX2hhbmRsZWJhcnMoYywgb3Blbl90b2tlbik7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9hdHRyaWJ1dGUoYywgcHJldmlvdXNfdG9rZW4sIG9wZW5fdG9rZW4pO1xuICB0b2tlbiA9IHRva2VuIHx8IHRoaXMuX3JlYWRfY2xvc2UoYywgb3Blbl90b2tlbik7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9yYXdfY29udGVudChjLCBwcmV2aW91c190b2tlbiwgb3Blbl90b2tlbik7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9jb250ZW50X3dvcmQoYyk7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9jb21tZW50X29yX2NkYXRhKGMpO1xuICB0b2tlbiA9IHRva2VuIHx8IHRoaXMuX3JlYWRfcHJvY2Vzc2luZyhjKTtcbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9yZWFkX29wZW4oYywgb3Blbl90b2tlbik7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlVOS05PV04sIHRoaXMuX2lucHV0Lm5leHQoKSk7XG5cbiAgcmV0dXJuIHRva2VuO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZF9jb21tZW50X29yX2NkYXRhID0gZnVuY3Rpb24oYykgeyAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHZhciB0b2tlbiA9IG51bGw7XG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gbnVsbDtcbiAgdmFyIGRpcmVjdGl2ZXMgPSBudWxsO1xuXG4gIGlmIChjID09PSAnPCcpIHtcbiAgICB2YXIgcGVlazEgPSB0aGlzLl9pbnB1dC5wZWVrKDEpO1xuICAgIC8vIFdlIHRyZWF0IGFsbCBjb21tZW50cyBhcyBsaXRlcmFscywgZXZlbiBtb3JlIHRoYW4gcHJlZm9ybWF0dGVkIHRhZ3NcbiAgICAvLyB3ZSBvbmx5IGxvb2sgZm9yIHRoZSBhcHByb3ByaWF0ZSBjbG9zaW5nIG1hcmtlclxuICAgIGlmIChwZWVrMSA9PT0gJyEnKSB7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5fX3BhdHRlcm5zLmNvbW1lbnQucmVhZCgpO1xuXG4gICAgICAvLyBvbmx5IHByb2Nlc3MgZGlyZWN0aXZlIG9uIGh0bWwgY29tbWVudHNcbiAgICAgIGlmIChyZXN1bHRpbmdfc3RyaW5nKSB7XG4gICAgICAgIGRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzX2NvcmUuZ2V0X2RpcmVjdGl2ZXMocmVzdWx0aW5nX3N0cmluZyk7XG4gICAgICAgIGlmIChkaXJlY3RpdmVzICYmIGRpcmVjdGl2ZXMuaWdub3JlID09PSAnc3RhcnQnKSB7XG4gICAgICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSBkaXJlY3RpdmVzX2NvcmUucmVhZElnbm9yZWQodGhpcy5faW5wdXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5fX3BhdHRlcm5zLmNkYXRhLnJlYWQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVzdWx0aW5nX3N0cmluZykge1xuICAgICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uQ09NTUVOVCwgcmVzdWx0aW5nX3N0cmluZyk7XG4gICAgICB0b2tlbi5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG9rZW47XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX3Byb2Nlc3NpbmcgPSBmdW5jdGlvbihjKSB7IC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgdmFyIHRva2VuID0gbnVsbDtcbiAgdmFyIHJlc3VsdGluZ19zdHJpbmcgPSBudWxsO1xuICB2YXIgZGlyZWN0aXZlcyA9IG51bGw7XG5cbiAgaWYgKGMgPT09ICc8Jykge1xuICAgIHZhciBwZWVrMSA9IHRoaXMuX2lucHV0LnBlZWsoMSk7XG4gICAgaWYgKHBlZWsxID09PSAnIScgfHwgcGVlazEgPT09ICc/Jykge1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX19wYXR0ZXJucy5jb25kaXRpb25hbF9jb21tZW50LnJlYWQoKTtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8IHRoaXMuX19wYXR0ZXJucy5wcm9jZXNzaW5nLnJlYWQoKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0aW5nX3N0cmluZykge1xuICAgICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uQ09NTUVOVCwgcmVzdWx0aW5nX3N0cmluZyk7XG4gICAgICB0b2tlbi5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG9rZW47XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX29wZW4gPSBmdW5jdGlvbihjLCBvcGVuX3Rva2VuKSB7XG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gbnVsbDtcbiAgdmFyIHRva2VuID0gbnVsbDtcbiAgaWYgKCFvcGVuX3Rva2VuKSB7XG4gICAgaWYgKGMgPT09ICc8Jykge1xuXG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgaWYgKHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gJy8nKSB7XG4gICAgICAgIHJlc3VsdGluZ19zdHJpbmcgKz0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgfVxuICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSB0aGlzLl9fcGF0dGVybnMuZWxlbWVudF9uYW1lLnJlYWQoKTtcbiAgICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlRBR19PUEVOLCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRva2VuO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZF9vcGVuX2hhbmRsZWJhcnMgPSBmdW5jdGlvbihjLCBvcGVuX3Rva2VuKSB7XG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gbnVsbDtcbiAgdmFyIHRva2VuID0gbnVsbDtcbiAgaWYgKCFvcGVuX3Rva2VuKSB7XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuaW5kZW50X2hhbmRsZWJhcnMgJiYgYyA9PT0gJ3snICYmIHRoaXMuX2lucHV0LnBlZWsoMSkgPT09ICd7Jykge1xuICAgICAgaWYgKHRoaXMuX2lucHV0LnBlZWsoMikgPT09ICchJykge1xuICAgICAgICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5fX3BhdHRlcm5zLmhhbmRsZWJhcnNfY29tbWVudC5yZWFkKCk7XG4gICAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8IHRoaXMuX19wYXR0ZXJucy5oYW5kbGViYXJzLnJlYWQoKTtcbiAgICAgICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uQ09NTUVOVCwgcmVzdWx0aW5nX3N0cmluZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5fX3BhdHRlcm5zLmhhbmRsZWJhcnNfb3Blbi5yZWFkKCk7XG4gICAgICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlRBR19PUEVOLCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRva2VuO1xufTtcblxuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX2Nsb3NlID0gZnVuY3Rpb24oYywgb3Blbl90b2tlbikge1xuICB2YXIgcmVzdWx0aW5nX3N0cmluZyA9IG51bGw7XG4gIHZhciB0b2tlbiA9IG51bGw7XG4gIGlmIChvcGVuX3Rva2VuKSB7XG4gICAgaWYgKG9wZW5fdG9rZW4udGV4dFswXSA9PT0gJzwnICYmIChjID09PSAnPicgfHwgKGMgPT09ICcvJyAmJiB0aGlzLl9pbnB1dC5wZWVrKDEpID09PSAnPicpKSkge1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICAgIGlmIChjID09PSAnLycpIHsgLy8gIGZvciBjbG9zZSB0YWcgXCIvPlwiXG4gICAgICAgIHJlc3VsdGluZ19zdHJpbmcgKz0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgfVxuICAgICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uVEFHX0NMT1NFLCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICB9IGVsc2UgaWYgKG9wZW5fdG9rZW4udGV4dFswXSA9PT0gJ3snICYmIGMgPT09ICd9JyAmJiB0aGlzLl9pbnB1dC5wZWVrKDEpID09PSAnfScpIHtcbiAgICAgIHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICAgIHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlRBR19DTE9TRSwgJ319Jyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRva2VuO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZF9hdHRyaWJ1dGUgPSBmdW5jdGlvbihjLCBwcmV2aW91c190b2tlbiwgb3Blbl90b2tlbikge1xuICB2YXIgdG9rZW4gPSBudWxsO1xuICB2YXIgcmVzdWx0aW5nX3N0cmluZyA9ICcnO1xuICBpZiAob3Blbl90b2tlbiAmJiBvcGVuX3Rva2VuLnRleHRbMF0gPT09ICc8Jykge1xuXG4gICAgaWYgKGMgPT09ICc9Jykge1xuICAgICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uRVFVQUxTLCB0aGlzLl9pbnB1dC5uZXh0KCkpO1xuICAgIH0gZWxzZSBpZiAoYyA9PT0gJ1wiJyB8fCBjID09PSBcIidcIikge1xuICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICBpZiAoYyA9PT0gJ1wiJykge1xuICAgICAgICBjb250ZW50ICs9IHRoaXMuX19wYXR0ZXJucy5kb3VibGVfcXVvdGUucmVhZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGVudCArPSB0aGlzLl9fcGF0dGVybnMuc2luZ2xlX3F1b3RlLnJlYWQoKTtcbiAgICAgIH1cbiAgICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlZBTFVFLCBjb250ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX19wYXR0ZXJucy5hdHRyaWJ1dGUucmVhZCgpO1xuXG4gICAgICBpZiAocmVzdWx0aW5nX3N0cmluZykge1xuICAgICAgICBpZiAocHJldmlvdXNfdG9rZW4udHlwZSA9PT0gVE9LRU4uRVFVQUxTKSB7XG4gICAgICAgICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uVkFMVUUsIHJlc3VsdGluZ19zdHJpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLkFUVFJJQlVURSwgcmVzdWx0aW5nX3N0cmluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRva2VuO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5faXNfY29udGVudF91bmZvcm1hdHRlZCA9IGZ1bmN0aW9uKHRhZ19uYW1lKSB7XG4gIC8vIHZvaWRfZWxlbWVudHMgaGF2ZSBubyBjb250ZW50IGFuZCBzbyBjYW5ub3QgaGF2ZSB1bmZvcm1hdHRlZCBjb250ZW50XG4gIC8vIHNjcmlwdCBhbmQgc3R5bGUgdGFncyBzaG91bGQgYWx3YXlzIGJlIHJlYWQgYXMgdW5mb3JtYXR0ZWQgY29udGVudFxuICAvLyBmaW5hbGx5IGNvbnRlbnRfdW5mb3JtYXR0ZWQgYW5kIHVuZm9ybWF0dGVkIGVsZW1lbnQgY29udGVudHMgYXJlIHVuZm9ybWF0dGVkXG4gIHJldHVybiB0aGlzLl9vcHRpb25zLnZvaWRfZWxlbWVudHMuaW5kZXhPZih0YWdfbmFtZSkgPT09IC0xICYmXG4gICAgKHRoaXMuX29wdGlvbnMuY29udGVudF91bmZvcm1hdHRlZC5pbmRleE9mKHRhZ19uYW1lKSAhPT0gLTEgfHxcbiAgICAgIHRoaXMuX29wdGlvbnMudW5mb3JtYXR0ZWQuaW5kZXhPZih0YWdfbmFtZSkgIT09IC0xKTtcbn07XG5cblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZF9yYXdfY29udGVudCA9IGZ1bmN0aW9uKGMsIHByZXZpb3VzX3Rva2VuLCBvcGVuX3Rva2VuKSB7IC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgdmFyIHJlc3VsdGluZ19zdHJpbmcgPSAnJztcbiAgaWYgKG9wZW5fdG9rZW4gJiYgb3Blbl90b2tlbi50ZXh0WzBdID09PSAneycpIHtcbiAgICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5fX3BhdHRlcm5zLmhhbmRsZWJhcnNfcmF3X2Nsb3NlLnJlYWQoKTtcbiAgfSBlbHNlIGlmIChwcmV2aW91c190b2tlbi50eXBlID09PSBUT0tFTi5UQUdfQ0xPU0UgJiZcbiAgICBwcmV2aW91c190b2tlbi5vcGVuZWQudGV4dFswXSA9PT0gJzwnICYmIHByZXZpb3VzX3Rva2VuLnRleHRbMF0gIT09ICcvJykge1xuICAgIC8vIF5eIGVtcHR5IHRhZyBoYXMgbm8gY29udGVudCBcbiAgICB2YXIgdGFnX25hbWUgPSBwcmV2aW91c190b2tlbi5vcGVuZWQudGV4dC5zdWJzdHIoMSkudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAodGFnX25hbWUgPT09ICdzY3JpcHQnIHx8IHRhZ19uYW1lID09PSAnc3R5bGUnKSB7XG4gICAgICAvLyBTY3JpcHQgYW5kIHN0eWxlIHRhZ3MgYXJlIGFsbG93ZWQgdG8gaGF2ZSBjb21tZW50cyB3cmFwcGluZyB0aGVpciBjb250ZW50XG4gICAgICAvLyBvciBqdXN0IGhhdmUgcmVndWxhciBjb250ZW50LlxuICAgICAgdmFyIHRva2VuID0gdGhpcy5fcmVhZF9jb21tZW50X29yX2NkYXRhKGMpO1xuICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgIHRva2VuLnR5cGUgPSBUT0tFTi5URVhUO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5faW5wdXQucmVhZFVudGlsKG5ldyBSZWdFeHAoJzwvJyArIHRhZ19uYW1lICsgJ1tcXFxcblxcXFxyXFxcXHQgXSo/PicsICdpZycpKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2lzX2NvbnRlbnRfdW5mb3JtYXR0ZWQodGFnX25hbWUpKSB7XG5cbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9pbnB1dC5yZWFkVW50aWwobmV3IFJlZ0V4cCgnPC8nICsgdGFnX25hbWUgKyAnW1xcXFxuXFxcXHJcXFxcdCBdKj8+JywgJ2lnJykpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyZXN1bHRpbmdfc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5URVhULCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZF9jb250ZW50X3dvcmQgPSBmdW5jdGlvbihjKSB7XG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gJyc7XG4gIGlmICh0aGlzLl9vcHRpb25zLnVuZm9ybWF0dGVkX2NvbnRlbnRfZGVsaW1pdGVyKSB7XG4gICAgaWYgKGMgPT09IHRoaXMuX29wdGlvbnMudW5mb3JtYXR0ZWRfY29udGVudF9kZWxpbWl0ZXJbMF0pIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMudW5mb3JtYXR0ZWRfY29udGVudF9kZWxpbWl0ZXIucmVhZCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghcmVzdWx0aW5nX3N0cmluZykge1xuICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMud29yZC5yZWFkKCk7XG4gIH1cbiAgaWYgKHJlc3VsdGluZ19zdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlRFWFQsIHJlc3VsdGluZ19zdHJpbmcpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Ub2tlbml6ZXIgPSBUb2tlbml6ZXI7XG5tb2R1bGUuZXhwb3J0cy5UT0tFTiA9IFRPS0VOO1xuXG5cbi8qKiovIH0pXG4vKioqKioqLyBcdF0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0Ly8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcbi8qKioqKiovIFx0bGVnYWN5X2JlYXV0aWZ5X2h0bWwgPSBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIH0pKClcbjtcbnZhciBzdHlsZV9odG1sID0gbGVnYWN5X2JlYXV0aWZ5X2h0bWw7XG4vKiBGb290ZXIgKi9cbmlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEFkZCBzdXBwb3J0IGZvciBBTUQgKCBodHRwczovL2dpdGh1Yi5jb20vYW1kanMvYW1kanMtYXBpL3dpa2kvQU1EI2RlZmluZWFtZC1wcm9wZXJ0eS0gKVxuICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiLi9iZWF1dGlmeVwiLCBcIi4vYmVhdXRpZnktY3NzXCJdLCBmdW5jdGlvbihyZXF1aXJlYW1kKSB7XG4gICAgICAgIHZhciBqc19iZWF1dGlmeSA9IHJlcXVpcmVhbWQoXCIuL2JlYXV0aWZ5XCIpO1xuICAgICAgICB2YXIgY3NzX2JlYXV0aWZ5ID0gcmVxdWlyZWFtZChcIi4vYmVhdXRpZnktY3NzXCIpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBodG1sX2JlYXV0aWZ5OiBmdW5jdGlvbihodG1sX3NvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHlsZV9odG1sKGh0bWxfc291cmNlLCBvcHRpb25zLCBqc19iZWF1dGlmeS5qc19iZWF1dGlmeSwgY3NzX2JlYXV0aWZ5LmNzc19iZWF1dGlmeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG59IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gQWRkIHN1cHBvcnQgZm9yIENvbW1vbkpTLiBKdXN0IHB1dCB0aGlzIGZpbGUgc29tZXdoZXJlIG9uIHlvdXIgcmVxdWlyZS5wYXRoc1xuICAgIC8vIGFuZCB5b3Ugd2lsbCBiZSBhYmxlIHRvIGB2YXIgaHRtbF9iZWF1dGlmeSA9IHJlcXVpcmUoXCJiZWF1dGlmeVwiKS5odG1sX2JlYXV0aWZ5YC5cbiAgICB2YXIganNfYmVhdXRpZnkgPSByZXF1aXJlKCcuL2JlYXV0aWZ5LmpzJyk7XG4gICAgdmFyIGNzc19iZWF1dGlmeSA9IHJlcXVpcmUoJy4vYmVhdXRpZnktY3NzLmpzJyk7XG5cbiAgICBleHBvcnRzLmh0bWxfYmVhdXRpZnkgPSBmdW5jdGlvbihodG1sX3NvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gc3R5bGVfaHRtbChodG1sX3NvdXJjZSwgb3B0aW9ucywganNfYmVhdXRpZnkuanNfYmVhdXRpZnksIGNzc19iZWF1dGlmeS5jc3NfYmVhdXRpZnkpO1xuICAgIH07XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBJZiB3ZSdyZSBydW5uaW5nIGEgd2ViIHBhZ2UgYW5kIGRvbid0IGhhdmUgZWl0aGVyIG9mIHRoZSBhYm92ZSwgYWRkIG91ciBvbmUgZ2xvYmFsXG4gICAgd2luZG93Lmh0bWxfYmVhdXRpZnkgPSBmdW5jdGlvbihodG1sX3NvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gc3R5bGVfaHRtbChodG1sX3NvdXJjZSwgb3B0aW9ucywgd2luZG93LmpzX2JlYXV0aWZ5LCB3aW5kb3cuY3NzX2JlYXV0aWZ5KTtcbiAgICB9O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gSWYgd2UgZG9uJ3QgZXZlbiBoYXZlIHdpbmRvdywgdHJ5IGdsb2JhbC5cbiAgICBnbG9iYWwuaHRtbF9iZWF1dGlmeSA9IGZ1bmN0aW9uKGh0bWxfc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBzdHlsZV9odG1sKGh0bWxfc291cmNlLCBvcHRpb25zLCBnbG9iYWwuanNfYmVhdXRpZnksIGdsb2JhbC5jc3NfYmVhdXRpZnkpO1xuICAgIH07XG59XG5cbn0oKSk7XG4iXSwibmFtZXMiOlsibGVnYWN5X2JlYXV0aWZ5X2h0bWwiLCJfX3dlYnBhY2tfbW9kdWxlc19fIiwibW9kdWxlIiwiT3V0cHV0TGluZSIsInBhcmVudCIsIl9fcGFyZW50IiwiX19jaGFyYWN0ZXJfY291bnQiLCJfX2luZGVudF9jb3VudCIsIl9fYWxpZ25tZW50X2NvdW50IiwiX193cmFwX3BvaW50X2luZGV4IiwiX193cmFwX3BvaW50X2NoYXJhY3Rlcl9jb3VudCIsIl9fd3JhcF9wb2ludF9pbmRlbnRfY291bnQiLCJfX3dyYXBfcG9pbnRfYWxpZ25tZW50X2NvdW50IiwiX19pdGVtcyIsInByb3RvdHlwZSIsImNsb25lX2VtcHR5IiwibGluZSIsInNldF9pbmRlbnQiLCJpdGVtIiwiaW5kZXgiLCJsZW5ndGgiLCJoYXNfbWF0Y2giLCJwYXR0ZXJuIiwibGFzdENoZWNrZWRPdXRwdXQiLCJtYXRjaCIsImluZGVudCIsImFsaWdubWVudCIsImlzX2VtcHR5IiwiZ2V0X2luZGVudF9zaXplIiwiX3NldF93cmFwX3BvaW50Iiwid3JhcF9saW5lX2xlbmd0aCIsIm5leHRfbGluZSIsIl9zaG91bGRfd3JhcCIsIl9hbGxvd193cmFwIiwiYWRkX25ld19saW5lIiwibmV4dCIsImN1cnJlbnRfbGluZSIsInNsaWNlIiwic3BsaWNlIiwibGFzdCIsInB1c2giLCJsYXN0X25ld2xpbmVfaW5kZXgiLCJsYXN0SW5kZXhPZiIsInBvcCIsIl9yZW1vdmVfaW5kZW50IiwiaW5kZW50X3NpemUiLCJfcmVtb3ZlX3dyYXBfaW5kZW50IiwidHJpbSIsInRvU3RyaW5nIiwicmVzdWx0IiwiaW5kZW50X2VtcHR5X2xpbmVzIiwiZ2V0X2luZGVudF9zdHJpbmciLCJqb2luIiwiSW5kZW50U3RyaW5nQ2FjaGUiLCJvcHRpb25zIiwiYmFzZUluZGVudFN0cmluZyIsIl9fY2FjaGUiLCJfX2luZGVudF9zaXplIiwiX19pbmRlbnRfc3RyaW5nIiwiaW5kZW50X2NoYXIiLCJpbmRlbnRfd2l0aF90YWJzIiwiQXJyYXkiLCJpbmRlbnRfbGV2ZWwiLCJfX2Jhc2Vfc3RyaW5nIiwiX19iYXNlX3N0cmluZ19sZW5ndGgiLCJjb2x1bW4iLCJfX2Vuc3VyZV9jYWNoZSIsIl9fYWRkX2NvbHVtbiIsIk1hdGgiLCJmbG9vciIsIk91dHB1dCIsIl9faW5kZW50X2NhY2hlIiwicmF3IiwiX2VuZF93aXRoX25ld2xpbmUiLCJlbmRfd2l0aF9uZXdsaW5lIiwiX19saW5lcyIsInByZXZpb3VzX2xpbmUiLCJzcGFjZV9iZWZvcmVfdG9rZW4iLCJub25fYnJlYWtpbmdfc3BhY2UiLCJwcmV2aW91c190b2tlbl93cmFwcGVkIiwiX19hZGRfb3V0cHV0bGluZSIsImdldF9saW5lX251bWJlciIsImZvcmNlX25ld2xpbmUiLCJqdXN0X2FkZGVkX25ld2xpbmUiLCJnZXRfY29kZSIsImVvbCIsImxhc3RfaXRlbSIsInJlcGxhY2UiLCJzd2VldF9jb2RlIiwic2V0X3dyYXBfcG9pbnQiLCJhZGRfcmF3X3Rva2VuIiwidG9rZW4iLCJ4IiwibmV3bGluZXMiLCJ3aGl0ZXNwYWNlX2JlZm9yZSIsInRleHQiLCJhZGRfdG9rZW4iLCJwcmludGFibGVfdG9rZW4iLCJfX2FkZF9zcGFjZV9iZWZvcmVfdG9rZW4iLCJyZW1vdmVfaW5kZW50Iiwib3V0cHV0X2xlbmd0aCIsImVhdF9uZXdsaW5lcyIsInVuZGVmaW5lZCIsImp1c3RfYWRkZWRfYmxhbmtsaW5lIiwiZW5zdXJlX2VtcHR5X2xpbmVfYWJvdmUiLCJzdGFydHNfd2l0aCIsImVuZHNfd2l0aCIsInBvdGVudGlhbEVtcHR5TGluZSIsImluZGV4T2YiLCJleHBvcnRzIiwiVG9rZW4iLCJ0eXBlIiwiY29tbWVudHNfYmVmb3JlIiwicHJldmlvdXMiLCJvcGVuZWQiLCJjbG9zZWQiLCJkaXJlY3RpdmVzIiwiT3B0aW9ucyIsIm1lcmdlX2NoaWxkX2ZpZWxkIiwicmF3X29wdGlvbnMiLCJfbWVyZ2VPcHRzIiwiZGlzYWJsZWQiLCJfZ2V0X2Jvb2xlYW4iLCJfZ2V0X2NoYXJhY3RlcnMiLCJfZ2V0X251bWJlciIsInByZXNlcnZlX25ld2xpbmVzIiwibWF4X3ByZXNlcnZlX25ld2xpbmVzIiwidGVtcGxhdGluZyIsIl9nZXRfc2VsZWN0aW9uX2xpc3QiLCJfZ2V0X2FycmF5IiwibmFtZSIsImRlZmF1bHRfdmFsdWUiLCJvcHRpb25fdmFsdWUiLCJjb25jYXQiLCJzcGxpdCIsInBhcnNlSW50IiwiaXNOYU4iLCJfZ2V0X3NlbGVjdGlvbiIsInNlbGVjdGlvbl9saXN0IiwiRXJyb3IiLCJfaXNfdmFsaWRfc2VsZWN0aW9uIiwic29tZSIsImFsbE9wdGlvbnMiLCJjaGlsZEZpZWxkTmFtZSIsImZpbmFsT3B0cyIsIl9ub3JtYWxpemVPcHRzIiwiY29udmVydGVkT3B0cyIsImtleSIsIm5ld0tleSIsIm5vcm1hbGl6ZU9wdHMiLCJtZXJnZU9wdHMiLCJyZWdleHBfaGFzX3N0aWNreSIsIlJlZ0V4cCIsImhhc093blByb3BlcnR5IiwiSW5wdXRTY2FubmVyIiwiaW5wdXRfc3RyaW5nIiwiX19pbnB1dCIsIl9faW5wdXRfbGVuZ3RoIiwiX19wb3NpdGlvbiIsInJlc3RhcnQiLCJiYWNrIiwiaGFzTmV4dCIsInZhbCIsImNoYXJBdCIsInBlZWsiLCJfX21hdGNoIiwibGFzdEluZGV4IiwicGF0dGVybl9tYXRjaCIsImV4ZWMiLCJzdGlja3kiLCJ0ZXN0IiwidGVzdENoYXIiLCJyZWFkIiwic3RhcnRpbmdfcGF0dGVybiIsInVudGlsX3BhdHRlcm4iLCJ1bnRpbF9hZnRlciIsInJlYWRVbnRpbCIsIm1hdGNoX2luZGV4Iiwic3Vic3RyaW5nIiwicmVhZFVudGlsQWZ0ZXIiLCJnZXRfcmVnZXhwIiwibWF0Y2hfZnJvbSIsImZsYWdzIiwic291cmNlIiwiZ2V0X2xpdGVyYWxfcmVnZXhwIiwibGl0ZXJhbF9zdHJpbmciLCJwZWVrVW50aWxBZnRlciIsInN0YXJ0IiwibG9va0JhY2siLCJ0ZXN0VmFsIiwidG9Mb3dlckNhc2UiLCJfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwiVG9rZW5TdHJlYW0iLCJXaGl0ZXNwYWNlUGF0dGVybiIsIlRPS0VOIiwiU1RBUlQiLCJSQVciLCJFT0YiLCJUb2tlbml6ZXIiLCJfaW5wdXQiLCJfb3B0aW9ucyIsIl9fdG9rZW5zIiwiX3BhdHRlcm5zIiwid2hpdGVzcGFjZSIsInRva2VuaXplIiwiX3Jlc2V0IiwiY3VycmVudCIsIm9wZW5fdG9rZW4iLCJvcGVuX3N0YWNrIiwiY29tbWVudHMiLCJfZ2V0X25leHRfdG9rZW4iLCJfaXNfY29tbWVudCIsImFkZCIsImlzRW1wdHkiLCJfaXNfb3BlbmluZyIsIl9pc19jbG9zaW5nIiwiX2lzX2ZpcnN0X3Rva2VuIiwicHJldmlvdXNfdG9rZW4iLCJfcmVhZFdoaXRlc3BhY2UiLCJyZXN1bHRpbmdfc3RyaW5nIiwiX2NyZWF0ZV90b2tlbiIsImN1cnJlbnRfdG9rZW4iLCJuZXdsaW5lX2NvdW50Iiwid2hpdGVzcGFjZV9iZWZvcmVfdG9rZW4iLCJwYXJlbnRfdG9rZW4iLCJfX3Rva2Vuc19sZW5ndGgiLCJfX3BhcmVudF90b2tlbiIsIlBhdHRlcm4iLCJpbnB1dF9zY2FubmVyIiwiY2FsbCIsIl9saW5lX3JlZ2V4cCIsIl9fc2V0X3doaXRlc3BhY2VfcGF0dGVybnMiLCJ3aGl0ZXNwYWNlX2NoYXJzIiwibmV3bGluZV9jaGFycyIsIl9tYXRjaF9wYXR0ZXJuIiwiX25ld2xpbmVfcmVnZXhwIiwibWF0Y2hlcyIsIl9fc3BsaXQiLCJtYXRjaGluZyIsIl9jcmVhdGUiLCJfdXBkYXRlIiwicmVnZXhwIiwic3RhcnRfaW5kZXgiLCJuZXh0X21hdGNoIiwiX3N0YXJ0aW5nX3BhdHRlcm4iLCJfdW50aWxfcGF0dGVybiIsIl91bnRpbF9hZnRlciIsInJlYWRfbWF0Y2giLCJ1bnRpbCIsInN0YXJ0aW5nX3dpdGgiLCJEaXJlY3RpdmVzIiwic3RhcnRfYmxvY2tfcGF0dGVybiIsImVuZF9ibG9ja19wYXR0ZXJuIiwiX19kaXJlY3RpdmVzX2Jsb2NrX3BhdHRlcm4iLCJfX2RpcmVjdGl2ZV9wYXR0ZXJuIiwiX19kaXJlY3RpdmVzX2VuZF9pZ25vcmVfcGF0dGVybiIsImdldF9kaXJlY3RpdmVzIiwiZGlyZWN0aXZlX21hdGNoIiwicmVhZElnbm9yZWQiLCJpbnB1dCIsInRlbXBsYXRlX25hbWVzIiwiZGphbmdvIiwiZXJiIiwiaGFuZGxlYmFycyIsInBocCIsInNtYXJ0eSIsIlRlbXBsYXRhYmxlUGF0dGVybiIsIl9fdGVtcGxhdGVfcGF0dGVybiIsIl9kaXNhYmxlZCIsIk9iamVjdCIsImFzc2lnbiIsIl9leGNsdWRlZCIsIl9fcGF0dGVybnMiLCJoYW5kbGViYXJzX2NvbW1lbnQiLCJoYW5kbGViYXJzX3VuZXNjYXBlZCIsImRqYW5nb192YWx1ZSIsImRqYW5nb19jb21tZW50Iiwic21hcnR5X2NvbW1lbnQiLCJzbWFydHlfbGl0ZXJhbCIsIl9fc2V0X3RlbXBsYXRlZF9wYXR0ZXJuIiwiZGlzYWJsZSIsImxhbmd1YWdlIiwicmVhZF9vcHRpb25zIiwiZXhjbHVkZSIsIl9yZWFkX3RlbXBsYXRlIiwiaXRlbXMiLCJjIiwicGVlazEiLCJCZWF1dGlmaWVyIiwic3R5bGVfaHRtbCIsImh0bWxfc291cmNlIiwianNfYmVhdXRpZnkiLCJjc3NfYmVhdXRpZnkiLCJiZWF1dGlmaWVyIiwiYmVhdXRpZnkiLCJkZWZhdWx0T3B0aW9ucyIsImxpbmVCcmVhayIsImFsbExpbmVCcmVha3MiLCJQcmludGVyIiwiYmFzZV9pbmRlbnRfc3RyaW5nIiwiYWxpZ25tZW50X3NpemUiLCJfb3V0cHV0IiwiY3VycmVudF9saW5lX2hhc19tYXRjaCIsInNldF9zcGFjZV9iZWZvcmVfdG9rZW4iLCJ2YWx1ZSIsIm5vbl9icmVha2luZyIsInByaW50X3ByZXNlcnZlZF9uZXdsaW5lcyIsInJhd190b2tlbiIsIlRFWFQiLCJuIiwicHJpbnRfbmV3bGluZSIsInRyYXZlcnNlX3doaXRlc3BhY2UiLCJmb3JjZSIsInByaW50X3Rva2VuIiwiZ2V0X2Z1bGxfaW5kZW50IiwibGV2ZWwiLCJnZXRfdHlwZV9hdHRyaWJ1dGUiLCJzdGFydF90b2tlbiIsIkFUVFJJQlVURSIsIkVRVUFMUyIsIlZBTFVFIiwiZ2V0X2N1c3RvbV9iZWF1dGlmaWVyX25hbWUiLCJ0YWdfY2hlY2siLCJ0eXBlQXR0cmlidXRlIiwic2VhcmNoIiwiaW5fYXJyYXkiLCJ3aGF0IiwiYXJyIiwiVGFnRnJhbWUiLCJwYXJzZXJfdG9rZW4iLCJ0YWciLCJ0YWdfbmFtZSIsIlRhZ1N0YWNrIiwicHJpbnRlciIsIl9wcmludGVyIiwiX2N1cnJlbnRfZnJhbWUiLCJnZXRfcGFyc2VyX3Rva2VuIiwicmVjb3JkX3RhZyIsIm5ld19mcmFtZSIsIl90cnlfcG9wX2ZyYW1lIiwiZnJhbWUiLCJfZ2V0X2ZyYW1lIiwidGFnX2xpc3QiLCJzdG9wX2xpc3QiLCJ0cnlfcG9wIiwiaW5kZW50X3RvX3RhZyIsInNvdXJjZV90ZXh0IiwiX3NvdXJjZV90ZXh0IiwiX2pzX2JlYXV0aWZ5IiwiX2Nzc19iZWF1dGlmeSIsIl90YWdfc3RhY2siLCJvcHRpb25IdG1sIiwiX2lzX3dyYXBfYXR0cmlidXRlc19mb3JjZSIsIndyYXBfYXR0cmlidXRlcyIsInN1YnN0ciIsIl9pc193cmFwX2F0dHJpYnV0ZXNfZm9yY2VfZXhwYW5kX211bHRpbGluZSIsIl9pc193cmFwX2F0dHJpYnV0ZXNfZm9yY2VfYWxpZ25lZCIsIl9pc193cmFwX2F0dHJpYnV0ZXNfYWxpZ25lZF9tdWx0aXBsZSIsIl9pc193cmFwX2F0dHJpYnV0ZXNfcHJlc2VydmUiLCJfaXNfd3JhcF9hdHRyaWJ1dGVzX3ByZXNlcnZlX2FsaWduZWQiLCJsYXN0X3Rva2VuIiwibGFzdF90YWdfdG9rZW4iLCJUYWdPcGVuUGFyc2VyVG9rZW4iLCJ0b2tlbnMiLCJUQUdfT1BFTiIsIkNPTU1FTlQiLCJfaGFuZGxlX3RhZ19vcGVuIiwidGFnX2NvbXBsZXRlIiwiX2hhbmRsZV9pbnNpZGVfdGFnIiwiVEFHX0NMT1NFIiwiX2hhbmRsZV90YWdfY2xvc2UiLCJfaGFuZGxlX3RleHQiLCJpc191bmZvcm1hdHRlZCIsInRhZ19zdGFydF9jaGFyIiwiaGFzX3dyYXBwZWRfYXR0cnMiLCJpbmRlbnRfY29udGVudCIsImlzX2NvbnRlbnRfdW5mb3JtYXR0ZWQiLCJpc19pbmxpbmVfZWxlbWVudCIsIndyYXBwZWQiLCJhdHRyX2NvdW50Iiwid3JhcF9hdHRyaWJ1dGVzX21pbl9hdHRycyIsImN1c3RvbV9iZWF1dGlmaWVyX25hbWUiLCJfcHJpbnRfY3VzdG9tX2JlYXRpZmllcl90ZXh0IiwibG9jYWwiLCJfYmVhdXRpZmllciIsInNjcmlwdF9pbmRlbnRfbGV2ZWwiLCJwcmUiLCJwb3N0IiwiaW5kZW50X3NjcmlwdHMiLCJpbmRlbnRhdGlvbiIsIm1hdGNoZWQiLCJDaGlsZF9vcHRpb25zIiwiY2hpbGRfb3B0aW9ucyIsIndoaXRlIiwiX2dldF90YWdfb3Blbl90b2tlbiIsImlzX2VtcHR5X2VsZW1lbnQiLCJpc19zdGFydF90YWciLCJzdGFydF90YWdfdG9rZW4iLCJfc2V0X3RhZ19wb3NpdGlvbiIsInBlZWtfaW5kZXgiLCJwZWVrX3Rva2VuIiwiaXNfZW5kX3RhZyIsIm11bHRpbGluZV9jb250ZW50IiwidGFnX2NoZWNrX21hdGNoIiwic3RhcnRzV2l0aCIsImhhbmRsZWJhcl9zdGFydHMiLCJ3cmFwX2F0dHJpYnV0ZXNfaW5kZW50X3NpemUiLCJ2b2lkX2VsZW1lbnRzIiwidW5mb3JtYXR0ZWQiLCJjb250ZW50X3VuZm9ybWF0dGVkIiwiaW5saW5lIiwiaW5saW5lX2N1c3RvbV9lbGVtZW50cyIsImluY2x1ZGVzIiwiX2RvX29wdGlvbmFsX2VuZF9lbGVtZW50IiwiZXh0cmFfbGluZXJzIiwiZm91bmRJZk9uQ3VycmVudExpbmUiLCJfY2FsY2x1YXRlX3BhcmVudF9tdWx0aWxpbmUiLCJkb19lbmRfZXhwYW5kIiwiaW5kZW50X2lubmVyX2h0bWwiLCJpbmRlbnRfaGVhZF9pbm5lcl9odG1sIiwiaW5kZW50X2JvZHlfaW5uZXJfaHRtbCIsInBfY2xvc2VycyIsInBfcGFyZW50X2V4Y2x1ZGVzIiwicF9wYXJlbnQiLCJCYXNlT3B0aW9ucyIsImluZGVudF9oYW5kbGViYXJzIiwidW5mb3JtYXR0ZWRfY29udGVudF9kZWxpbWl0ZXIiLCJCYXNlVG9rZW5pemVyIiwiQkFTRVRPS0VOIiwiVU5LTk9XTiIsImRpcmVjdGl2ZXNfY29yZSIsIl9jdXJyZW50X3RhZ19uYW1lIiwidGVtcGxhdGFibGVfcmVhZGVyIiwicGF0dGVybl9yZWFkZXIiLCJ3b3JkIiwic2luZ2xlX3F1b3RlIiwiZG91YmxlX3F1b3RlIiwiYXR0cmlidXRlIiwiZWxlbWVudF9uYW1lIiwiaGFuZGxlYmFyc19vcGVuIiwiaGFuZGxlYmFyc19yYXdfY2xvc2UiLCJjb21tZW50IiwiY2RhdGEiLCJjb25kaXRpb25hbF9jb21tZW50IiwicHJvY2Vzc2luZyIsIl91bmZvcm1hdHRlZF9jb250ZW50X2RlbGltaXRlciIsImxpdGVyYWxfcmVnZXhwIiwiX3JlYWRfb3Blbl9oYW5kbGViYXJzIiwiX3JlYWRfYXR0cmlidXRlIiwiX3JlYWRfY2xvc2UiLCJfcmVhZF9yYXdfY29udGVudCIsIl9yZWFkX2NvbnRlbnRfd29yZCIsIl9yZWFkX2NvbW1lbnRfb3JfY2RhdGEiLCJfcmVhZF9wcm9jZXNzaW5nIiwiX3JlYWRfb3BlbiIsImlnbm9yZSIsImNvbnRlbnQiLCJfaXNfY29udGVudF91bmZvcm1hdHRlZCIsIl9fd2VicGFja19tb2R1bGVfY2FjaGVfXyIsIm1vZHVsZUlkIiwiY2FjaGVkTW9kdWxlIiwiX193ZWJwYWNrX2V4cG9ydHNfXyIsImRlZmluZSIsImFtZCIsInJlcXVpcmVhbWQiLCJodG1sX2JlYXV0aWZ5IiwicmVxdWlyZSIsIndpbmRvdyIsImdsb2JhbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/js-beautify/js/lib/beautify-html.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/js-beautify/js/lib/beautify.js":
/*!*****************************************************!*\
  !*** ./node_modules/js-beautify/js/lib/beautify.js ***!
  \*****************************************************/
/***/ ((module, exports) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* AUTO-GENERATED. DO NOT MODIFY. */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n JS Beautifier\n---------------\n\n\n  Written by Einar Lielmanis, <einar@beautifier.io>\n      https://beautifier.io/\n\n  Originally converted to javascript by Vital, <vital76@gmail.com>\n  \"End braces on own line\" added by Chris J. Shull, <chrisjshull@gmail.com>\n  Parsing improvements for brace-less statements by Liam Newman <bitwiseman@beautifier.io>\n\n\n  Usage:\n    js_beautify(js_source_text);\n    js_beautify(js_source_text, options);\n\n  The options are:\n    indent_size (default 4)          - indentation size,\n    indent_char (default space)      - character to indent with,\n    preserve_newlines (default true) - whether existing line breaks should be preserved,\n    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk,\n\n    jslint_happy (default false) - if true, then jslint-stricter mode is enforced.\n\n            jslint_happy        !jslint_happy\n            ---------------------------------\n            function ()         function()\n\n            switch () {         switch() {\n            case 1:               case 1:\n              break;                break;\n            }                   }\n\n    space_after_anon_function (default false) - should the space before an anonymous function's parens be added, \"function()\" vs \"function ()\",\n          NOTE: This option is overridden by jslint_happy (i.e. if jslint_happy is true, space_after_anon_function is true by design)\n\n    brace_style (default \"collapse\") - \"collapse\" | \"expand\" | \"end-expand\" | \"none\" | any of the former + \",preserve-inline\"\n            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.\n            preserve-inline will try to preserve inline blocks of curly braces\n\n    space_before_conditional (default true) - should the space before conditional statement be added, \"if(true)\" vs \"if (true)\",\n\n    unescape_strings (default false) - should printable characters in strings encoded in \\xNN notation be unescaped, \"example\" vs \"\\x65\\x78\\x61\\x6d\\x70\\x6c\\x65\"\n\n    wrap_line_length (default unlimited) - lines should wrap at next opportunity after this number of characters.\n          NOTE: This is not a hard limit. Lines will continue until a point where a newline would\n                be preserved if it were present.\n\n    end_with_newline (default false)  - end output with a newline\n\n\n    e.g\n\n    js_beautify(js_source_text, {\n      'indent_size': 1,\n      'indent_char': '\\t'\n    });\n\n*/ (function() {\n    /* GENERATED_BUILD_OUTPUT */ var legacy_beautify_js;\n    /******/ (function() {\n        /******/ \"use strict\";\n        /******/ var __webpack_modules__ = [\n            /* 0 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_4010__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var Beautifier = __nested_webpack_require_4010__(1).Beautifier, Options = __nested_webpack_require_4010__(5).Options;\n                function js_beautify(js_source_text, options) {\n                    var beautifier = new Beautifier(js_source_text, options);\n                    return beautifier.beautify();\n                }\n                module.exports = js_beautify;\n                module.exports.defaultOptions = function() {\n                    return new Options();\n                };\n            /***/ },\n            /* 1 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_5797__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var Output = __nested_webpack_require_5797__(2).Output;\n                var Token = __nested_webpack_require_5797__(3).Token;\n                var acorn = __nested_webpack_require_5797__(4);\n                var Options = __nested_webpack_require_5797__(5).Options;\n                var Tokenizer = __nested_webpack_require_5797__(7).Tokenizer;\n                var line_starters = __nested_webpack_require_5797__(7).line_starters;\n                var positionable_operators = __nested_webpack_require_5797__(7).positionable_operators;\n                var TOKEN = __nested_webpack_require_5797__(7).TOKEN;\n                function in_array(what, arr) {\n                    return arr.indexOf(what) !== -1;\n                }\n                function ltrim(s) {\n                    return s.replace(/^\\s+/g, \"\");\n                }\n                function generateMapFromStrings(list) {\n                    var result = {};\n                    for(var x = 0; x < list.length; x++){\n                        // make the mapped names underscored instead of dash\n                        result[list[x].replace(/-/g, \"_\")] = list[x];\n                    }\n                    return result;\n                }\n                function reserved_word(token, word) {\n                    return token && token.type === TOKEN.RESERVED && token.text === word;\n                }\n                function reserved_array(token, words) {\n                    return token && token.type === TOKEN.RESERVED && in_array(token.text, words);\n                }\n                // Unsure of what they mean, but they work. Worth cleaning up in future.\n                var special_words = [\n                    \"case\",\n                    \"return\",\n                    \"do\",\n                    \"if\",\n                    \"throw\",\n                    \"else\",\n                    \"await\",\n                    \"break\",\n                    \"continue\",\n                    \"async\"\n                ];\n                var validPositionValues = [\n                    \"before-newline\",\n                    \"after-newline\",\n                    \"preserve-newline\"\n                ];\n                // Generate map from array\n                var OPERATOR_POSITION = generateMapFromStrings(validPositionValues);\n                var OPERATOR_POSITION_BEFORE_OR_PRESERVE = [\n                    OPERATOR_POSITION.before_newline,\n                    OPERATOR_POSITION.preserve_newline\n                ];\n                var MODE = {\n                    BlockStatement: \"BlockStatement\",\n                    Statement: \"Statement\",\n                    ObjectLiteral: \"ObjectLiteral\",\n                    ArrayLiteral: \"ArrayLiteral\",\n                    ForInitializer: \"ForInitializer\",\n                    Conditional: \"Conditional\",\n                    Expression: \"Expression\" //'(EXPRESSION)'\n                };\n                function remove_redundant_indentation(output, frame) {\n                    // This implementation is effective but has some issues:\n                    //     - can cause line wrap to happen too soon due to indent removal\n                    //           after wrap points are calculated\n                    // These issues are minor compared to ugly indentation.\n                    if (frame.multiline_frame || frame.mode === MODE.ForInitializer || frame.mode === MODE.Conditional) {\n                        return;\n                    }\n                    // remove one indent from each line inside this section\n                    output.remove_indent(frame.start_line_index);\n                }\n                // we could use just string.split, but\n                // IE doesn't like returning empty strings\n                function split_linebreaks(s) {\n                    //return s.split(/\\x0d\\x0a|\\x0a/);\n                    s = s.replace(acorn.allLineBreaks, \"\\n\");\n                    var out = [], idx = s.indexOf(\"\\n\");\n                    while(idx !== -1){\n                        out.push(s.substring(0, idx));\n                        s = s.substring(idx + 1);\n                        idx = s.indexOf(\"\\n\");\n                    }\n                    if (s.length) {\n                        out.push(s);\n                    }\n                    return out;\n                }\n                function is_array(mode) {\n                    return mode === MODE.ArrayLiteral;\n                }\n                function is_expression(mode) {\n                    return in_array(mode, [\n                        MODE.Expression,\n                        MODE.ForInitializer,\n                        MODE.Conditional\n                    ]);\n                }\n                function all_lines_start_with(lines, c) {\n                    for(var i = 0; i < lines.length; i++){\n                        var line = lines[i].trim();\n                        if (line.charAt(0) !== c) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                function each_line_matches_indent(lines, indent) {\n                    var i = 0, len = lines.length, line;\n                    for(; i < len; i++){\n                        line = lines[i];\n                        // allow empty lines to pass through\n                        if (line && line.indexOf(indent) !== 0) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                function Beautifier(source_text, options) {\n                    options = options || {};\n                    this._source_text = source_text || \"\";\n                    this._output = null;\n                    this._tokens = null;\n                    this._last_last_text = null;\n                    this._flags = null;\n                    this._previous_flags = null;\n                    this._flag_store = null;\n                    this._options = new Options(options);\n                }\n                Beautifier.prototype.create_flags = function(flags_base, mode) {\n                    var next_indent_level = 0;\n                    if (flags_base) {\n                        next_indent_level = flags_base.indentation_level;\n                        if (!this._output.just_added_newline() && flags_base.line_indent_level > next_indent_level) {\n                            next_indent_level = flags_base.line_indent_level;\n                        }\n                    }\n                    var next_flags = {\n                        mode: mode,\n                        parent: flags_base,\n                        last_token: flags_base ? flags_base.last_token : new Token(TOKEN.START_BLOCK, \"\"),\n                        last_word: flags_base ? flags_base.last_word : \"\",\n                        declaration_statement: false,\n                        declaration_assignment: false,\n                        multiline_frame: false,\n                        inline_frame: false,\n                        if_block: false,\n                        else_block: false,\n                        class_start_block: false,\n                        do_block: false,\n                        do_while: false,\n                        import_block: false,\n                        in_case_statement: false,\n                        in_case: false,\n                        case_body: false,\n                        case_block: false,\n                        indentation_level: next_indent_level,\n                        alignment: 0,\n                        line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,\n                        start_line_index: this._output.get_line_number(),\n                        ternary_depth: 0\n                    };\n                    return next_flags;\n                };\n                Beautifier.prototype._reset = function(source_text) {\n                    var baseIndentString = source_text.match(/^[\\t ]*/)[0];\n                    this._last_last_text = \"\"; // pre-last token text\n                    this._output = new Output(this._options, baseIndentString);\n                    // If testing the ignore directive, start with output disable set to true\n                    this._output.raw = this._options.test_output_raw;\n                    // Stack of parsing/formatting states, including MODE.\n                    // We tokenize, parse, and output in an almost purely a forward-only stream of token input\n                    // and formatted output.  This makes the beautifier less accurate than full parsers\n                    // but also far more tolerant of syntax errors.\n                    //\n                    // For example, the default mode is MODE.BlockStatement. If we see a '{' we push a new frame of type\n                    // MODE.BlockStatement on the the stack, even though it could be object literal.  If we later\n                    // encounter a \":\", we'll switch to to MODE.ObjectLiteral.  If we then see a \";\",\n                    // most full parsers would die, but the beautifier gracefully falls back to\n                    // MODE.BlockStatement and continues on.\n                    this._flag_store = [];\n                    this.set_mode(MODE.BlockStatement);\n                    var tokenizer = new Tokenizer(source_text, this._options);\n                    this._tokens = tokenizer.tokenize();\n                    return source_text;\n                };\n                Beautifier.prototype.beautify = function() {\n                    // if disabled, return the input unchanged.\n                    if (this._options.disabled) {\n                        return this._source_text;\n                    }\n                    var sweet_code;\n                    var source_text = this._reset(this._source_text);\n                    var eol = this._options.eol;\n                    if (this._options.eol === \"auto\") {\n                        eol = \"\\n\";\n                        if (source_text && acorn.lineBreak.test(source_text || \"\")) {\n                            eol = source_text.match(acorn.lineBreak)[0];\n                        }\n                    }\n                    var current_token = this._tokens.next();\n                    while(current_token){\n                        this.handle_token(current_token);\n                        this._last_last_text = this._flags.last_token.text;\n                        this._flags.last_token = current_token;\n                        current_token = this._tokens.next();\n                    }\n                    sweet_code = this._output.get_code(eol);\n                    return sweet_code;\n                };\n                Beautifier.prototype.handle_token = function(current_token, preserve_statement_flags) {\n                    if (current_token.type === TOKEN.START_EXPR) {\n                        this.handle_start_expr(current_token);\n                    } else if (current_token.type === TOKEN.END_EXPR) {\n                        this.handle_end_expr(current_token);\n                    } else if (current_token.type === TOKEN.START_BLOCK) {\n                        this.handle_start_block(current_token);\n                    } else if (current_token.type === TOKEN.END_BLOCK) {\n                        this.handle_end_block(current_token);\n                    } else if (current_token.type === TOKEN.WORD) {\n                        this.handle_word(current_token);\n                    } else if (current_token.type === TOKEN.RESERVED) {\n                        this.handle_word(current_token);\n                    } else if (current_token.type === TOKEN.SEMICOLON) {\n                        this.handle_semicolon(current_token);\n                    } else if (current_token.type === TOKEN.STRING) {\n                        this.handle_string(current_token);\n                    } else if (current_token.type === TOKEN.EQUALS) {\n                        this.handle_equals(current_token);\n                    } else if (current_token.type === TOKEN.OPERATOR) {\n                        this.handle_operator(current_token);\n                    } else if (current_token.type === TOKEN.COMMA) {\n                        this.handle_comma(current_token);\n                    } else if (current_token.type === TOKEN.BLOCK_COMMENT) {\n                        this.handle_block_comment(current_token, preserve_statement_flags);\n                    } else if (current_token.type === TOKEN.COMMENT) {\n                        this.handle_comment(current_token, preserve_statement_flags);\n                    } else if (current_token.type === TOKEN.DOT) {\n                        this.handle_dot(current_token);\n                    } else if (current_token.type === TOKEN.EOF) {\n                        this.handle_eof(current_token);\n                    } else if (current_token.type === TOKEN.UNKNOWN) {\n                        this.handle_unknown(current_token, preserve_statement_flags);\n                    } else {\n                        this.handle_unknown(current_token, preserve_statement_flags);\n                    }\n                };\n                Beautifier.prototype.handle_whitespace_and_comments = function(current_token, preserve_statement_flags) {\n                    var newlines = current_token.newlines;\n                    var keep_whitespace = this._options.keep_array_indentation && is_array(this._flags.mode);\n                    if (current_token.comments_before) {\n                        var comment_token = current_token.comments_before.next();\n                        while(comment_token){\n                            // The cleanest handling of inline comments is to treat them as though they aren't there.\n                            // Just continue formatting and the behavior should be logical.\n                            // Also ignore unknown tokens.  Again, this should result in better behavior.\n                            this.handle_whitespace_and_comments(comment_token, preserve_statement_flags);\n                            this.handle_token(comment_token, preserve_statement_flags);\n                            comment_token = current_token.comments_before.next();\n                        }\n                    }\n                    if (keep_whitespace) {\n                        for(var i = 0; i < newlines; i += 1){\n                            this.print_newline(i > 0, preserve_statement_flags);\n                        }\n                    } else {\n                        if (this._options.max_preserve_newlines && newlines > this._options.max_preserve_newlines) {\n                            newlines = this._options.max_preserve_newlines;\n                        }\n                        if (this._options.preserve_newlines) {\n                            if (newlines > 1) {\n                                this.print_newline(false, preserve_statement_flags);\n                                for(var j = 1; j < newlines; j += 1){\n                                    this.print_newline(true, preserve_statement_flags);\n                                }\n                            }\n                        }\n                    }\n                };\n                var newline_restricted_tokens = [\n                    \"async\",\n                    \"break\",\n                    \"continue\",\n                    \"return\",\n                    \"throw\",\n                    \"yield\"\n                ];\n                Beautifier.prototype.allow_wrap_or_preserved_newline = function(current_token, force_linewrap) {\n                    force_linewrap = force_linewrap === undefined ? false : force_linewrap;\n                    // Never wrap the first token on a line\n                    if (this._output.just_added_newline()) {\n                        return;\n                    }\n                    var shouldPreserveOrForce = this._options.preserve_newlines && current_token.newlines || force_linewrap;\n                    var operatorLogicApplies = in_array(this._flags.last_token.text, positionable_operators) || in_array(current_token.text, positionable_operators);\n                    if (operatorLogicApplies) {\n                        var shouldPrintOperatorNewline = in_array(this._flags.last_token.text, positionable_operators) && in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE) || in_array(current_token.text, positionable_operators);\n                        shouldPreserveOrForce = shouldPreserveOrForce && shouldPrintOperatorNewline;\n                    }\n                    if (shouldPreserveOrForce) {\n                        this.print_newline(false, true);\n                    } else if (this._options.wrap_line_length) {\n                        if (reserved_array(this._flags.last_token, newline_restricted_tokens)) {\n                            // These tokens should never have a newline inserted\n                            // between them and the following expression.\n                            return;\n                        }\n                        this._output.set_wrap_point();\n                    }\n                };\n                Beautifier.prototype.print_newline = function(force_newline, preserve_statement_flags) {\n                    if (!preserve_statement_flags) {\n                        if (this._flags.last_token.text !== \";\" && this._flags.last_token.text !== \",\" && this._flags.last_token.text !== \"=\" && (this._flags.last_token.type !== TOKEN.OPERATOR || this._flags.last_token.text === \"--\" || this._flags.last_token.text === \"++\")) {\n                            var next_token = this._tokens.peek();\n                            while(this._flags.mode === MODE.Statement && !(this._flags.if_block && reserved_word(next_token, \"else\")) && !this._flags.do_block){\n                                this.restore_mode();\n                            }\n                        }\n                    }\n                    if (this._output.add_new_line(force_newline)) {\n                        this._flags.multiline_frame = true;\n                    }\n                };\n                Beautifier.prototype.print_token_line_indentation = function(current_token) {\n                    if (this._output.just_added_newline()) {\n                        if (this._options.keep_array_indentation && current_token.newlines && (current_token.text === \"[\" || is_array(this._flags.mode))) {\n                            this._output.current_line.set_indent(-1);\n                            this._output.current_line.push(current_token.whitespace_before);\n                            this._output.space_before_token = false;\n                        } else if (this._output.set_indent(this._flags.indentation_level, this._flags.alignment)) {\n                            this._flags.line_indent_level = this._flags.indentation_level;\n                        }\n                    }\n                };\n                Beautifier.prototype.print_token = function(current_token) {\n                    if (this._output.raw) {\n                        this._output.add_raw_token(current_token);\n                        return;\n                    }\n                    if (this._options.comma_first && current_token.previous && current_token.previous.type === TOKEN.COMMA && this._output.just_added_newline()) {\n                        if (this._output.previous_line.last() === \",\") {\n                            var popped = this._output.previous_line.pop();\n                            // if the comma was already at the start of the line,\n                            // pull back onto that line and reprint the indentation\n                            if (this._output.previous_line.is_empty()) {\n                                this._output.previous_line.push(popped);\n                                this._output.trim(true);\n                                this._output.current_line.pop();\n                                this._output.trim();\n                            }\n                            // add the comma in front of the next token\n                            this.print_token_line_indentation(current_token);\n                            this._output.add_token(\",\");\n                            this._output.space_before_token = true;\n                        }\n                    }\n                    this.print_token_line_indentation(current_token);\n                    this._output.non_breaking_space = true;\n                    this._output.add_token(current_token.text);\n                    if (this._output.previous_token_wrapped) {\n                        this._flags.multiline_frame = true;\n                    }\n                };\n                Beautifier.prototype.indent = function() {\n                    this._flags.indentation_level += 1;\n                    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);\n                };\n                Beautifier.prototype.deindent = function() {\n                    if (this._flags.indentation_level > 0 && (!this._flags.parent || this._flags.indentation_level > this._flags.parent.indentation_level)) {\n                        this._flags.indentation_level -= 1;\n                        this._output.set_indent(this._flags.indentation_level, this._flags.alignment);\n                    }\n                };\n                Beautifier.prototype.set_mode = function(mode) {\n                    if (this._flags) {\n                        this._flag_store.push(this._flags);\n                        this._previous_flags = this._flags;\n                    } else {\n                        this._previous_flags = this.create_flags(null, mode);\n                    }\n                    this._flags = this.create_flags(this._previous_flags, mode);\n                    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);\n                };\n                Beautifier.prototype.restore_mode = function() {\n                    if (this._flag_store.length > 0) {\n                        this._previous_flags = this._flags;\n                        this._flags = this._flag_store.pop();\n                        if (this._previous_flags.mode === MODE.Statement) {\n                            remove_redundant_indentation(this._output, this._previous_flags);\n                        }\n                        this._output.set_indent(this._flags.indentation_level, this._flags.alignment);\n                    }\n                };\n                Beautifier.prototype.start_of_object_property = function() {\n                    return this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement && (this._flags.last_token.text === \":\" && this._flags.ternary_depth === 0 || reserved_array(this._flags.last_token, [\n                        \"get\",\n                        \"set\"\n                    ]));\n                };\n                Beautifier.prototype.start_of_statement = function(current_token) {\n                    var start = false;\n                    start = start || reserved_array(this._flags.last_token, [\n                        \"var\",\n                        \"let\",\n                        \"const\"\n                    ]) && current_token.type === TOKEN.WORD;\n                    start = start || reserved_word(this._flags.last_token, \"do\");\n                    start = start || !(this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement) && reserved_array(this._flags.last_token, newline_restricted_tokens) && !current_token.newlines;\n                    start = start || reserved_word(this._flags.last_token, \"else\") && !(reserved_word(current_token, \"if\") && !current_token.comments_before);\n                    start = start || this._flags.last_token.type === TOKEN.END_EXPR && (this._previous_flags.mode === MODE.ForInitializer || this._previous_flags.mode === MODE.Conditional);\n                    start = start || this._flags.last_token.type === TOKEN.WORD && this._flags.mode === MODE.BlockStatement && !this._flags.in_case && !(current_token.text === \"--\" || current_token.text === \"++\") && this._last_last_text !== \"function\" && current_token.type !== TOKEN.WORD && current_token.type !== TOKEN.RESERVED;\n                    start = start || this._flags.mode === MODE.ObjectLiteral && (this._flags.last_token.text === \":\" && this._flags.ternary_depth === 0 || reserved_array(this._flags.last_token, [\n                        \"get\",\n                        \"set\"\n                    ]));\n                    if (start) {\n                        this.set_mode(MODE.Statement);\n                        this.indent();\n                        this.handle_whitespace_and_comments(current_token, true);\n                        // Issue #276:\n                        // If starting a new statement with [if, for, while, do], push to a new line.\n                        // if (a) if (b) if(c) d(); else e(); else f();\n                        if (!this.start_of_object_property()) {\n                            this.allow_wrap_or_preserved_newline(current_token, reserved_array(current_token, [\n                                \"do\",\n                                \"for\",\n                                \"if\",\n                                \"while\"\n                            ]));\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n                Beautifier.prototype.handle_start_expr = function(current_token) {\n                    // The conditional starts the statement if appropriate.\n                    if (!this.start_of_statement(current_token)) {\n                        this.handle_whitespace_and_comments(current_token);\n                    }\n                    var next_mode = MODE.Expression;\n                    if (current_token.text === \"[\") {\n                        if (this._flags.last_token.type === TOKEN.WORD || this._flags.last_token.text === \")\") {\n                            // this is array index specifier, break immediately\n                            // a[x], fn()[x]\n                            if (reserved_array(this._flags.last_token, line_starters)) {\n                                this._output.space_before_token = true;\n                            }\n                            this.print_token(current_token);\n                            this.set_mode(next_mode);\n                            this.indent();\n                            if (this._options.space_in_paren) {\n                                this._output.space_before_token = true;\n                            }\n                            return;\n                        }\n                        next_mode = MODE.ArrayLiteral;\n                        if (is_array(this._flags.mode)) {\n                            if (this._flags.last_token.text === \"[\" || this._flags.last_token.text === \",\" && (this._last_last_text === \"]\" || this._last_last_text === \"}\")) {\n                                // ], [ goes to new line\n                                // }, [ goes to new line\n                                if (!this._options.keep_array_indentation) {\n                                    this.print_newline();\n                                }\n                            }\n                        }\n                        if (!in_array(this._flags.last_token.type, [\n                            TOKEN.START_EXPR,\n                            TOKEN.END_EXPR,\n                            TOKEN.WORD,\n                            TOKEN.OPERATOR,\n                            TOKEN.DOT\n                        ])) {\n                            this._output.space_before_token = true;\n                        }\n                    } else {\n                        if (this._flags.last_token.type === TOKEN.RESERVED) {\n                            if (this._flags.last_token.text === \"for\") {\n                                this._output.space_before_token = this._options.space_before_conditional;\n                                next_mode = MODE.ForInitializer;\n                            } else if (in_array(this._flags.last_token.text, [\n                                \"if\",\n                                \"while\",\n                                \"switch\"\n                            ])) {\n                                this._output.space_before_token = this._options.space_before_conditional;\n                                next_mode = MODE.Conditional;\n                            } else if (in_array(this._flags.last_word, [\n                                \"await\",\n                                \"async\"\n                            ])) {\n                                // Should be a space between await and an IIFE, or async and an arrow function\n                                this._output.space_before_token = true;\n                            } else if (this._flags.last_token.text === \"import\" && current_token.whitespace_before === \"\") {\n                                this._output.space_before_token = false;\n                            } else if (in_array(this._flags.last_token.text, line_starters) || this._flags.last_token.text === \"catch\") {\n                                this._output.space_before_token = true;\n                            }\n                        } else if (this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {\n                            // Support of this kind of newline preservation.\n                            // a = (b &&\n                            //     (c || d));\n                            if (!this.start_of_object_property()) {\n                                this.allow_wrap_or_preserved_newline(current_token);\n                            }\n                        } else if (this._flags.last_token.type === TOKEN.WORD) {\n                            this._output.space_before_token = false;\n                            // function name() vs function name ()\n                            // function* name() vs function* name ()\n                            // async name() vs async name ()\n                            // In ES6, you can also define the method properties of an object\n                            // var obj = {a: function() {}}\n                            // It can be abbreviated\n                            // var obj = {a() {}}\n                            // var obj = { a() {}} vs var obj = { a () {}}\n                            // var obj = { * a() {}} vs var obj = { * a () {}}\n                            var peek_back_two = this._tokens.peek(-3);\n                            if (this._options.space_after_named_function && peek_back_two) {\n                                // peek starts at next character so -1 is current token\n                                var peek_back_three = this._tokens.peek(-4);\n                                if (reserved_array(peek_back_two, [\n                                    \"async\",\n                                    \"function\"\n                                ]) || peek_back_two.text === \"*\" && reserved_array(peek_back_three, [\n                                    \"async\",\n                                    \"function\"\n                                ])) {\n                                    this._output.space_before_token = true;\n                                } else if (this._flags.mode === MODE.ObjectLiteral) {\n                                    if (peek_back_two.text === \"{\" || peek_back_two.text === \",\" || peek_back_two.text === \"*\" && (peek_back_three.text === \"{\" || peek_back_three.text === \",\")) {\n                                        this._output.space_before_token = true;\n                                    }\n                                } else if (this._flags.parent && this._flags.parent.class_start_block) {\n                                    this._output.space_before_token = true;\n                                }\n                            }\n                        } else {\n                            // Support preserving wrapped arrow function expressions\n                            // a.b('c',\n                            //     () => d.e\n                            // )\n                            this.allow_wrap_or_preserved_newline(current_token);\n                        }\n                        // function() vs function ()\n                        // yield*() vs yield* ()\n                        // function*() vs function* ()\n                        if (this._flags.last_token.type === TOKEN.RESERVED && (this._flags.last_word === \"function\" || this._flags.last_word === \"typeof\") || this._flags.last_token.text === \"*\" && (in_array(this._last_last_text, [\n                            \"function\",\n                            \"yield\"\n                        ]) || this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, [\n                            \"{\",\n                            \",\"\n                        ]))) {\n                            this._output.space_before_token = this._options.space_after_anon_function;\n                        }\n                    }\n                    if (this._flags.last_token.text === \";\" || this._flags.last_token.type === TOKEN.START_BLOCK) {\n                        this.print_newline();\n                    } else if (this._flags.last_token.type === TOKEN.END_EXPR || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.END_BLOCK || this._flags.last_token.text === \".\" || this._flags.last_token.type === TOKEN.COMMA) {\n                        // do nothing on (( and )( and ][ and ]( and .(\n                        // TODO: Consider whether forcing this is required.  Review failing tests when removed.\n                        this.allow_wrap_or_preserved_newline(current_token, current_token.newlines);\n                    }\n                    this.print_token(current_token);\n                    this.set_mode(next_mode);\n                    if (this._options.space_in_paren) {\n                        this._output.space_before_token = true;\n                    }\n                    // In all cases, if we newline while inside an expression it should be indented.\n                    this.indent();\n                };\n                Beautifier.prototype.handle_end_expr = function(current_token) {\n                    // statements inside expressions are not valid syntax, but...\n                    // statements must all be closed when their container closes\n                    while(this._flags.mode === MODE.Statement){\n                        this.restore_mode();\n                    }\n                    this.handle_whitespace_and_comments(current_token);\n                    if (this._flags.multiline_frame) {\n                        this.allow_wrap_or_preserved_newline(current_token, current_token.text === \"]\" && is_array(this._flags.mode) && !this._options.keep_array_indentation);\n                    }\n                    if (this._options.space_in_paren) {\n                        if (this._flags.last_token.type === TOKEN.START_EXPR && !this._options.space_in_empty_paren) {\n                            // () [] no inner space in empty parens like these, ever, ref #320\n                            this._output.trim();\n                            this._output.space_before_token = false;\n                        } else {\n                            this._output.space_before_token = true;\n                        }\n                    }\n                    this.deindent();\n                    this.print_token(current_token);\n                    this.restore_mode();\n                    remove_redundant_indentation(this._output, this._previous_flags);\n                    // do {} while () // no statement required after\n                    if (this._flags.do_while && this._previous_flags.mode === MODE.Conditional) {\n                        this._previous_flags.mode = MODE.Expression;\n                        this._flags.do_block = false;\n                        this._flags.do_while = false;\n                    }\n                };\n                Beautifier.prototype.handle_start_block = function(current_token) {\n                    this.handle_whitespace_and_comments(current_token);\n                    // Check if this is should be treated as a ObjectLiteral\n                    var next_token = this._tokens.peek();\n                    var second_token = this._tokens.peek(1);\n                    if (this._flags.last_word === \"switch\" && this._flags.last_token.type === TOKEN.END_EXPR) {\n                        this.set_mode(MODE.BlockStatement);\n                        this._flags.in_case_statement = true;\n                    } else if (this._flags.case_body) {\n                        this.set_mode(MODE.BlockStatement);\n                    } else if (second_token && (in_array(second_token.text, [\n                        \":\",\n                        \",\"\n                    ]) && in_array(next_token.type, [\n                        TOKEN.STRING,\n                        TOKEN.WORD,\n                        TOKEN.RESERVED\n                    ]) || in_array(next_token.text, [\n                        \"get\",\n                        \"set\",\n                        \"...\"\n                    ]) && in_array(second_token.type, [\n                        TOKEN.WORD,\n                        TOKEN.RESERVED\n                    ]))) {\n                        // We don't support TypeScript,but we didn't break it for a very long time.\n                        // We'll try to keep not breaking it.\n                        if (in_array(this._last_last_text, [\n                            \"class\",\n                            \"interface\"\n                        ]) && !in_array(second_token.text, [\n                            \":\",\n                            \",\"\n                        ])) {\n                            this.set_mode(MODE.BlockStatement);\n                        } else {\n                            this.set_mode(MODE.ObjectLiteral);\n                        }\n                    } else if (this._flags.last_token.type === TOKEN.OPERATOR && this._flags.last_token.text === \"=>\") {\n                        // arrow function: (param1, paramN) => { statements }\n                        this.set_mode(MODE.BlockStatement);\n                    } else if (in_array(this._flags.last_token.type, [\n                        TOKEN.EQUALS,\n                        TOKEN.START_EXPR,\n                        TOKEN.COMMA,\n                        TOKEN.OPERATOR\n                    ]) || reserved_array(this._flags.last_token, [\n                        \"return\",\n                        \"throw\",\n                        \"import\",\n                        \"default\"\n                    ])) {\n                        // Detecting shorthand function syntax is difficult by scanning forward,\n                        //     so check the surrounding context.\n                        // If the block is being returned, imported, export default, passed as arg,\n                        //     assigned with = or assigned in a nested object, treat as an ObjectLiteral.\n                        this.set_mode(MODE.ObjectLiteral);\n                    } else {\n                        this.set_mode(MODE.BlockStatement);\n                    }\n                    if (this._flags.last_token) {\n                        if (reserved_array(this._flags.last_token.previous, [\n                            \"class\",\n                            \"extends\"\n                        ])) {\n                            this._flags.class_start_block = true;\n                        }\n                    }\n                    var empty_braces = !next_token.comments_before && next_token.text === \"}\";\n                    var empty_anonymous_function = empty_braces && this._flags.last_word === \"function\" && this._flags.last_token.type === TOKEN.END_EXPR;\n                    if (this._options.brace_preserve_inline) {\n                        // search forward for a newline wanted inside this block\n                        var index = 0;\n                        var check_token = null;\n                        this._flags.inline_frame = true;\n                        do {\n                            index += 1;\n                            check_token = this._tokens.peek(index - 1);\n                            if (check_token.newlines) {\n                                this._flags.inline_frame = false;\n                                break;\n                            }\n                        }while (check_token.type !== TOKEN.EOF && !(check_token.type === TOKEN.END_BLOCK && check_token.opened === current_token));\n                    }\n                    if ((this._options.brace_style === \"expand\" || this._options.brace_style === \"none\" && current_token.newlines) && !this._flags.inline_frame) {\n                        if (this._flags.last_token.type !== TOKEN.OPERATOR && (empty_anonymous_function || this._flags.last_token.type === TOKEN.EQUALS || reserved_array(this._flags.last_token, special_words) && this._flags.last_token.text !== \"else\")) {\n                            this._output.space_before_token = true;\n                        } else {\n                            this.print_newline(false, true);\n                        }\n                    } else {\n                        if (is_array(this._previous_flags.mode) && (this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.COMMA)) {\n                            if (this._flags.last_token.type === TOKEN.COMMA || this._options.space_in_paren) {\n                                this._output.space_before_token = true;\n                            }\n                            if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR && this._flags.inline_frame) {\n                                this.allow_wrap_or_preserved_newline(current_token);\n                                this._previous_flags.multiline_frame = this._previous_flags.multiline_frame || this._flags.multiline_frame;\n                                this._flags.multiline_frame = false;\n                            }\n                        }\n                        if (this._flags.last_token.type !== TOKEN.OPERATOR && this._flags.last_token.type !== TOKEN.START_EXPR) {\n                            if (in_array(this._flags.last_token.type, [\n                                TOKEN.START_BLOCK,\n                                TOKEN.SEMICOLON\n                            ]) && !this._flags.inline_frame) {\n                                this.print_newline();\n                            } else {\n                                this._output.space_before_token = true;\n                            }\n                        }\n                    }\n                    this.print_token(current_token);\n                    this.indent();\n                    // Except for specific cases, open braces are followed by a new line.\n                    if (!empty_braces && !(this._options.brace_preserve_inline && this._flags.inline_frame)) {\n                        this.print_newline();\n                    }\n                };\n                Beautifier.prototype.handle_end_block = function(current_token) {\n                    // statements must all be closed when their container closes\n                    this.handle_whitespace_and_comments(current_token);\n                    while(this._flags.mode === MODE.Statement){\n                        this.restore_mode();\n                    }\n                    var empty_braces = this._flags.last_token.type === TOKEN.START_BLOCK;\n                    if (this._flags.inline_frame && !empty_braces) {\n                        this._output.space_before_token = true;\n                    } else if (this._options.brace_style === \"expand\") {\n                        if (!empty_braces) {\n                            this.print_newline();\n                        }\n                    } else {\n                        // skip {}\n                        if (!empty_braces) {\n                            if (is_array(this._flags.mode) && this._options.keep_array_indentation) {\n                                // we REALLY need a newline here, but newliner would skip that\n                                this._options.keep_array_indentation = false;\n                                this.print_newline();\n                                this._options.keep_array_indentation = true;\n                            } else {\n                                this.print_newline();\n                            }\n                        }\n                    }\n                    this.restore_mode();\n                    this.print_token(current_token);\n                };\n                Beautifier.prototype.handle_word = function(current_token) {\n                    if (current_token.type === TOKEN.RESERVED) {\n                        if (in_array(current_token.text, [\n                            \"set\",\n                            \"get\"\n                        ]) && this._flags.mode !== MODE.ObjectLiteral) {\n                            current_token.type = TOKEN.WORD;\n                        } else if (current_token.text === \"import\" && in_array(this._tokens.peek().text, [\n                            \"(\",\n                            \".\"\n                        ])) {\n                            current_token.type = TOKEN.WORD;\n                        } else if (in_array(current_token.text, [\n                            \"as\",\n                            \"from\"\n                        ]) && !this._flags.import_block) {\n                            current_token.type = TOKEN.WORD;\n                        } else if (this._flags.mode === MODE.ObjectLiteral) {\n                            var next_token = this._tokens.peek();\n                            if (next_token.text === \":\") {\n                                current_token.type = TOKEN.WORD;\n                            }\n                        }\n                    }\n                    if (this.start_of_statement(current_token)) {\n                        // The conditional starts the statement if appropriate.\n                        if (reserved_array(this._flags.last_token, [\n                            \"var\",\n                            \"let\",\n                            \"const\"\n                        ]) && current_token.type === TOKEN.WORD) {\n                            this._flags.declaration_statement = true;\n                        }\n                    } else if (current_token.newlines && !is_expression(this._flags.mode) && (this._flags.last_token.type !== TOKEN.OPERATOR || this._flags.last_token.text === \"--\" || this._flags.last_token.text === \"++\") && this._flags.last_token.type !== TOKEN.EQUALS && (this._options.preserve_newlines || !reserved_array(this._flags.last_token, [\n                        \"var\",\n                        \"let\",\n                        \"const\",\n                        \"set\",\n                        \"get\"\n                    ]))) {\n                        this.handle_whitespace_and_comments(current_token);\n                        this.print_newline();\n                    } else {\n                        this.handle_whitespace_and_comments(current_token);\n                    }\n                    if (this._flags.do_block && !this._flags.do_while) {\n                        if (reserved_word(current_token, \"while\")) {\n                            // do {} ## while ()\n                            this._output.space_before_token = true;\n                            this.print_token(current_token);\n                            this._output.space_before_token = true;\n                            this._flags.do_while = true;\n                            return;\n                        } else {\n                            // do {} should always have while as the next word.\n                            // if we don't see the expected while, recover\n                            this.print_newline();\n                            this._flags.do_block = false;\n                        }\n                    }\n                    // if may be followed by else, or not\n                    // Bare/inline ifs are tricky\n                    // Need to unwind the modes correctly: if (a) if (b) c(); else d(); else e();\n                    if (this._flags.if_block) {\n                        if (!this._flags.else_block && reserved_word(current_token, \"else\")) {\n                            this._flags.else_block = true;\n                        } else {\n                            while(this._flags.mode === MODE.Statement){\n                                this.restore_mode();\n                            }\n                            this._flags.if_block = false;\n                            this._flags.else_block = false;\n                        }\n                    }\n                    if (this._flags.in_case_statement && reserved_array(current_token, [\n                        \"case\",\n                        \"default\"\n                    ])) {\n                        this.print_newline();\n                        if (!this._flags.case_block && (this._flags.case_body || this._options.jslint_happy)) {\n                            // switch cases following one another\n                            this.deindent();\n                        }\n                        this._flags.case_body = false;\n                        this.print_token(current_token);\n                        this._flags.in_case = true;\n                        return;\n                    }\n                    if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {\n                        if (!this.start_of_object_property() && !// start of object property is different for numeric values with +/- prefix operators\n                        (in_array(this._flags.last_token.text, [\n                            \"+\",\n                            \"-\"\n                        ]) && this._last_last_text === \":\" && this._flags.parent.mode === MODE.ObjectLiteral)) {\n                            this.allow_wrap_or_preserved_newline(current_token);\n                        }\n                    }\n                    if (reserved_word(current_token, \"function\")) {\n                        if (in_array(this._flags.last_token.text, [\n                            \"}\",\n                            \";\"\n                        ]) || this._output.just_added_newline() && !(in_array(this._flags.last_token.text, [\n                            \"(\",\n                            \"[\",\n                            \"{\",\n                            \":\",\n                            \"=\",\n                            \",\"\n                        ]) || this._flags.last_token.type === TOKEN.OPERATOR)) {\n                            // make sure there is a nice clean space of at least one blank line\n                            // before a new function definition\n                            if (!this._output.just_added_blankline() && !current_token.comments_before) {\n                                this.print_newline();\n                                this.print_newline(true);\n                            }\n                        }\n                        if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD) {\n                            if (reserved_array(this._flags.last_token, [\n                                \"get\",\n                                \"set\",\n                                \"new\",\n                                \"export\"\n                            ]) || reserved_array(this._flags.last_token, newline_restricted_tokens)) {\n                                this._output.space_before_token = true;\n                            } else if (reserved_word(this._flags.last_token, \"default\") && this._last_last_text === \"export\") {\n                                this._output.space_before_token = true;\n                            } else if (this._flags.last_token.text === \"declare\") {\n                                // accomodates Typescript declare function formatting\n                                this._output.space_before_token = true;\n                            } else {\n                                this.print_newline();\n                            }\n                        } else if (this._flags.last_token.type === TOKEN.OPERATOR || this._flags.last_token.text === \"=\") {\n                            // foo = function\n                            this._output.space_before_token = true;\n                        } else if (!this._flags.multiline_frame && (is_expression(this._flags.mode) || is_array(this._flags.mode))) {\n                        // (function\n                        } else {\n                            this.print_newline();\n                        }\n                        this.print_token(current_token);\n                        this._flags.last_word = current_token.text;\n                        return;\n                    }\n                    var prefix = \"NONE\";\n                    if (this._flags.last_token.type === TOKEN.END_BLOCK) {\n                        if (this._previous_flags.inline_frame) {\n                            prefix = \"SPACE\";\n                        } else if (!reserved_array(current_token, [\n                            \"else\",\n                            \"catch\",\n                            \"finally\",\n                            \"from\"\n                        ])) {\n                            prefix = \"NEWLINE\";\n                        } else {\n                            if (this._options.brace_style === \"expand\" || this._options.brace_style === \"end-expand\" || this._options.brace_style === \"none\" && current_token.newlines) {\n                                prefix = \"NEWLINE\";\n                            } else {\n                                prefix = \"SPACE\";\n                                this._output.space_before_token = true;\n                            }\n                        }\n                    } else if (this._flags.last_token.type === TOKEN.SEMICOLON && this._flags.mode === MODE.BlockStatement) {\n                        // TODO: Should this be for STATEMENT as well?\n                        prefix = \"NEWLINE\";\n                    } else if (this._flags.last_token.type === TOKEN.SEMICOLON && is_expression(this._flags.mode)) {\n                        prefix = \"SPACE\";\n                    } else if (this._flags.last_token.type === TOKEN.STRING) {\n                        prefix = \"NEWLINE\";\n                    } else if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD || this._flags.last_token.text === \"*\" && (in_array(this._last_last_text, [\n                        \"function\",\n                        \"yield\"\n                    ]) || this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, [\n                        \"{\",\n                        \",\"\n                    ]))) {\n                        prefix = \"SPACE\";\n                    } else if (this._flags.last_token.type === TOKEN.START_BLOCK) {\n                        if (this._flags.inline_frame) {\n                            prefix = \"SPACE\";\n                        } else {\n                            prefix = \"NEWLINE\";\n                        }\n                    } else if (this._flags.last_token.type === TOKEN.END_EXPR) {\n                        this._output.space_before_token = true;\n                        prefix = \"NEWLINE\";\n                    }\n                    if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== \")\") {\n                        if (this._flags.inline_frame || this._flags.last_token.text === \"else\" || this._flags.last_token.text === \"export\") {\n                            prefix = \"SPACE\";\n                        } else {\n                            prefix = \"NEWLINE\";\n                        }\n                    }\n                    if (reserved_array(current_token, [\n                        \"else\",\n                        \"catch\",\n                        \"finally\"\n                    ])) {\n                        if ((!(this._flags.last_token.type === TOKEN.END_BLOCK && this._previous_flags.mode === MODE.BlockStatement) || this._options.brace_style === \"expand\" || this._options.brace_style === \"end-expand\" || this._options.brace_style === \"none\" && current_token.newlines) && !this._flags.inline_frame) {\n                            this.print_newline();\n                        } else {\n                            this._output.trim(true);\n                            var line = this._output.current_line;\n                            // If we trimmed and there's something other than a close block before us\n                            // put a newline back in.  Handles '} // comment' scenario.\n                            if (line.last() !== \"}\") {\n                                this.print_newline();\n                            }\n                            this._output.space_before_token = true;\n                        }\n                    } else if (prefix === \"NEWLINE\") {\n                        if (reserved_array(this._flags.last_token, special_words)) {\n                            // no newline between 'return nnn'\n                            this._output.space_before_token = true;\n                        } else if (this._flags.last_token.text === \"declare\" && reserved_array(current_token, [\n                            \"var\",\n                            \"let\",\n                            \"const\"\n                        ])) {\n                            // accomodates Typescript declare formatting\n                            this._output.space_before_token = true;\n                        } else if (this._flags.last_token.type !== TOKEN.END_EXPR) {\n                            if ((this._flags.last_token.type !== TOKEN.START_EXPR || !reserved_array(current_token, [\n                                \"var\",\n                                \"let\",\n                                \"const\"\n                            ])) && this._flags.last_token.text !== \":\") {\n                                // no need to force newline on 'var': for (var x = 0...)\n                                if (reserved_word(current_token, \"if\") && reserved_word(current_token.previous, \"else\")) {\n                                    // no newline for } else if {\n                                    this._output.space_before_token = true;\n                                } else {\n                                    this.print_newline();\n                                }\n                            }\n                        } else if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== \")\") {\n                            this.print_newline();\n                        }\n                    } else if (this._flags.multiline_frame && is_array(this._flags.mode) && this._flags.last_token.text === \",\" && this._last_last_text === \"}\") {\n                        this.print_newline(); // }, in lists get a newline treatment\n                    } else if (prefix === \"SPACE\") {\n                        this._output.space_before_token = true;\n                    }\n                    if (current_token.previous && (current_token.previous.type === TOKEN.WORD || current_token.previous.type === TOKEN.RESERVED)) {\n                        this._output.space_before_token = true;\n                    }\n                    this.print_token(current_token);\n                    this._flags.last_word = current_token.text;\n                    if (current_token.type === TOKEN.RESERVED) {\n                        if (current_token.text === \"do\") {\n                            this._flags.do_block = true;\n                        } else if (current_token.text === \"if\") {\n                            this._flags.if_block = true;\n                        } else if (current_token.text === \"import\") {\n                            this._flags.import_block = true;\n                        } else if (this._flags.import_block && reserved_word(current_token, \"from\")) {\n                            this._flags.import_block = false;\n                        }\n                    }\n                };\n                Beautifier.prototype.handle_semicolon = function(current_token) {\n                    if (this.start_of_statement(current_token)) {\n                        // The conditional starts the statement if appropriate.\n                        // Semicolon can be the start (and end) of a statement\n                        this._output.space_before_token = false;\n                    } else {\n                        this.handle_whitespace_and_comments(current_token);\n                    }\n                    var next_token = this._tokens.peek();\n                    while(this._flags.mode === MODE.Statement && !(this._flags.if_block && reserved_word(next_token, \"else\")) && !this._flags.do_block){\n                        this.restore_mode();\n                    }\n                    // hacky but effective for the moment\n                    if (this._flags.import_block) {\n                        this._flags.import_block = false;\n                    }\n                    this.print_token(current_token);\n                };\n                Beautifier.prototype.handle_string = function(current_token) {\n                    if (current_token.text.startsWith(\"`\") && current_token.newlines === 0 && current_token.whitespace_before === \"\" && (current_token.previous.text === \")\" || this._flags.last_token.type === TOKEN.WORD)) {\n                    //Conditional for detectign backtick strings\n                    } else if (this.start_of_statement(current_token)) {\n                        // The conditional starts the statement if appropriate.\n                        // One difference - strings want at least a space before\n                        this._output.space_before_token = true;\n                    } else {\n                        this.handle_whitespace_and_comments(current_token);\n                        if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD || this._flags.inline_frame) {\n                            this._output.space_before_token = true;\n                        } else if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {\n                            if (!this.start_of_object_property()) {\n                                this.allow_wrap_or_preserved_newline(current_token);\n                            }\n                        } else if (current_token.text.startsWith(\"`\") && this._flags.last_token.type === TOKEN.END_EXPR && (current_token.previous.text === \"]\" || current_token.previous.text === \")\") && current_token.newlines === 0) {\n                            this._output.space_before_token = true;\n                        } else {\n                            this.print_newline();\n                        }\n                    }\n                    this.print_token(current_token);\n                };\n                Beautifier.prototype.handle_equals = function(current_token) {\n                    if (this.start_of_statement(current_token)) {\n                    // The conditional starts the statement if appropriate.\n                    } else {\n                        this.handle_whitespace_and_comments(current_token);\n                    }\n                    if (this._flags.declaration_statement) {\n                        // just got an '=' in a var-line, different formatting/line-breaking, etc will now be done\n                        this._flags.declaration_assignment = true;\n                    }\n                    this._output.space_before_token = true;\n                    this.print_token(current_token);\n                    this._output.space_before_token = true;\n                };\n                Beautifier.prototype.handle_comma = function(current_token) {\n                    this.handle_whitespace_and_comments(current_token, true);\n                    this.print_token(current_token);\n                    this._output.space_before_token = true;\n                    if (this._flags.declaration_statement) {\n                        if (is_expression(this._flags.parent.mode)) {\n                            // do not break on comma, for(var a = 1, b = 2)\n                            this._flags.declaration_assignment = false;\n                        }\n                        if (this._flags.declaration_assignment) {\n                            this._flags.declaration_assignment = false;\n                            this.print_newline(false, true);\n                        } else if (this._options.comma_first) {\n                            // for comma-first, we want to allow a newline before the comma\n                            // to turn into a newline after the comma, which we will fixup later\n                            this.allow_wrap_or_preserved_newline(current_token);\n                        }\n                    } else if (this._flags.mode === MODE.ObjectLiteral || this._flags.mode === MODE.Statement && this._flags.parent.mode === MODE.ObjectLiteral) {\n                        if (this._flags.mode === MODE.Statement) {\n                            this.restore_mode();\n                        }\n                        if (!this._flags.inline_frame) {\n                            this.print_newline();\n                        }\n                    } else if (this._options.comma_first) {\n                        // EXPR or DO_BLOCK\n                        // for comma-first, we want to allow a newline before the comma\n                        // to turn into a newline after the comma, which we will fixup later\n                        this.allow_wrap_or_preserved_newline(current_token);\n                    }\n                };\n                Beautifier.prototype.handle_operator = function(current_token) {\n                    var isGeneratorAsterisk = current_token.text === \"*\" && (reserved_array(this._flags.last_token, [\n                        \"function\",\n                        \"yield\"\n                    ]) || in_array(this._flags.last_token.type, [\n                        TOKEN.START_BLOCK,\n                        TOKEN.COMMA,\n                        TOKEN.END_BLOCK,\n                        TOKEN.SEMICOLON\n                    ]));\n                    var isUnary = in_array(current_token.text, [\n                        \"-\",\n                        \"+\"\n                    ]) && (in_array(this._flags.last_token.type, [\n                        TOKEN.START_BLOCK,\n                        TOKEN.START_EXPR,\n                        TOKEN.EQUALS,\n                        TOKEN.OPERATOR\n                    ]) || in_array(this._flags.last_token.text, line_starters) || this._flags.last_token.text === \",\");\n                    if (this.start_of_statement(current_token)) {\n                    // The conditional starts the statement if appropriate.\n                    } else {\n                        var preserve_statement_flags = !isGeneratorAsterisk;\n                        this.handle_whitespace_and_comments(current_token, preserve_statement_flags);\n                    }\n                    // hack for actionscript's import .*;\n                    if (current_token.text === \"*\" && this._flags.last_token.type === TOKEN.DOT) {\n                        this.print_token(current_token);\n                        return;\n                    }\n                    if (current_token.text === \"::\") {\n                        // no spaces around exotic namespacing syntax operator\n                        this.print_token(current_token);\n                        return;\n                    }\n                    if (in_array(current_token.text, [\n                        \"-\",\n                        \"+\"\n                    ]) && this.start_of_object_property()) {\n                        // numeric value with +/- symbol in front as a property\n                        this.print_token(current_token);\n                        return;\n                    }\n                    // Allow line wrapping between operators when operator_position is\n                    //   set to before or preserve\n                    if (this._flags.last_token.type === TOKEN.OPERATOR && in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)) {\n                        this.allow_wrap_or_preserved_newline(current_token);\n                    }\n                    if (current_token.text === \":\" && this._flags.in_case) {\n                        this.print_token(current_token);\n                        this._flags.in_case = false;\n                        this._flags.case_body = true;\n                        if (this._tokens.peek().type !== TOKEN.START_BLOCK) {\n                            this.indent();\n                            this.print_newline();\n                            this._flags.case_block = false;\n                        } else {\n                            this._flags.case_block = true;\n                            this._output.space_before_token = true;\n                        }\n                        return;\n                    }\n                    var space_before = true;\n                    var space_after = true;\n                    var in_ternary = false;\n                    if (current_token.text === \":\") {\n                        if (this._flags.ternary_depth === 0) {\n                            // Colon is invalid javascript outside of ternary and object, but do our best to guess what was meant.\n                            space_before = false;\n                        } else {\n                            this._flags.ternary_depth -= 1;\n                            in_ternary = true;\n                        }\n                    } else if (current_token.text === \"?\") {\n                        this._flags.ternary_depth += 1;\n                    }\n                    // let's handle the operator_position option prior to any conflicting logic\n                    if (!isUnary && !isGeneratorAsterisk && this._options.preserve_newlines && in_array(current_token.text, positionable_operators)) {\n                        var isColon = current_token.text === \":\";\n                        var isTernaryColon = isColon && in_ternary;\n                        var isOtherColon = isColon && !in_ternary;\n                        switch(this._options.operator_position){\n                            case OPERATOR_POSITION.before_newline:\n                                // if the current token is : and it's not a ternary statement then we set space_before to false\n                                this._output.space_before_token = !isOtherColon;\n                                this.print_token(current_token);\n                                if (!isColon || isTernaryColon) {\n                                    this.allow_wrap_or_preserved_newline(current_token);\n                                }\n                                this._output.space_before_token = true;\n                                return;\n                            case OPERATOR_POSITION.after_newline:\n                                // if the current token is anything but colon, or (via deduction) it's a colon and in a ternary statement,\n                                //   then print a newline.\n                                this._output.space_before_token = true;\n                                if (!isColon || isTernaryColon) {\n                                    if (this._tokens.peek().newlines) {\n                                        this.print_newline(false, true);\n                                    } else {\n                                        this.allow_wrap_or_preserved_newline(current_token);\n                                    }\n                                } else {\n                                    this._output.space_before_token = false;\n                                }\n                                this.print_token(current_token);\n                                this._output.space_before_token = true;\n                                return;\n                            case OPERATOR_POSITION.preserve_newline:\n                                if (!isOtherColon) {\n                                    this.allow_wrap_or_preserved_newline(current_token);\n                                }\n                                // if we just added a newline, or the current token is : and it's not a ternary statement,\n                                //   then we set space_before to false\n                                space_before = !(this._output.just_added_newline() || isOtherColon);\n                                this._output.space_before_token = space_before;\n                                this.print_token(current_token);\n                                this._output.space_before_token = true;\n                                return;\n                        }\n                    }\n                    if (isGeneratorAsterisk) {\n                        this.allow_wrap_or_preserved_newline(current_token);\n                        space_before = false;\n                        var next_token = this._tokens.peek();\n                        space_after = next_token && in_array(next_token.type, [\n                            TOKEN.WORD,\n                            TOKEN.RESERVED\n                        ]);\n                    } else if (current_token.text === \"...\") {\n                        this.allow_wrap_or_preserved_newline(current_token);\n                        space_before = this._flags.last_token.type === TOKEN.START_BLOCK;\n                        space_after = false;\n                    } else if (in_array(current_token.text, [\n                        \"--\",\n                        \"++\",\n                        \"!\",\n                        \"~\"\n                    ]) || isUnary) {\n                        // unary operators (and binary +/- pretending to be unary) special cases\n                        if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR) {\n                            this.allow_wrap_or_preserved_newline(current_token);\n                        }\n                        space_before = false;\n                        space_after = false;\n                        // http://www.ecma-international.org/ecma-262/5.1/#sec-7.9.1\n                        // if there is a newline between -- or ++ and anything else we should preserve it.\n                        if (current_token.newlines && (current_token.text === \"--\" || current_token.text === \"++\" || current_token.text === \"~\")) {\n                            var new_line_needed = reserved_array(this._flags.last_token, special_words) && current_token.newlines;\n                            if (new_line_needed && (this._previous_flags.if_block || this._previous_flags.else_block)) {\n                                this.restore_mode();\n                            }\n                            this.print_newline(new_line_needed, true);\n                        }\n                        if (this._flags.last_token.text === \";\" && is_expression(this._flags.mode)) {\n                            // for (;; ++i)\n                            //        ^^^\n                            space_before = true;\n                        }\n                        if (this._flags.last_token.type === TOKEN.RESERVED) {\n                            space_before = true;\n                        } else if (this._flags.last_token.type === TOKEN.END_EXPR) {\n                            space_before = !(this._flags.last_token.text === \"]\" && (current_token.text === \"--\" || current_token.text === \"++\"));\n                        } else if (this._flags.last_token.type === TOKEN.OPERATOR) {\n                            // a++ + ++b;\n                            // a - -b\n                            space_before = in_array(current_token.text, [\n                                \"--\",\n                                \"-\",\n                                \"++\",\n                                \"+\"\n                            ]) && in_array(this._flags.last_token.text, [\n                                \"--\",\n                                \"-\",\n                                \"++\",\n                                \"+\"\n                            ]);\n                            // + and - are not unary when preceeded by -- or ++ operator\n                            // a-- + b\n                            // a * +b\n                            // a - -b\n                            if (in_array(current_token.text, [\n                                \"+\",\n                                \"-\"\n                            ]) && in_array(this._flags.last_token.text, [\n                                \"--\",\n                                \"++\"\n                            ])) {\n                                space_after = true;\n                            }\n                        }\n                        if ((this._flags.mode === MODE.BlockStatement && !this._flags.inline_frame || this._flags.mode === MODE.Statement) && (this._flags.last_token.text === \"{\" || this._flags.last_token.text === \";\")) {\n                            // { foo; --i }\n                            // foo(); --bar;\n                            this.print_newline();\n                        }\n                    }\n                    this._output.space_before_token = this._output.space_before_token || space_before;\n                    this.print_token(current_token);\n                    this._output.space_before_token = space_after;\n                };\n                Beautifier.prototype.handle_block_comment = function(current_token, preserve_statement_flags) {\n                    if (this._output.raw) {\n                        this._output.add_raw_token(current_token);\n                        if (current_token.directives && current_token.directives.preserve === \"end\") {\n                            // If we're testing the raw output behavior, do not allow a directive to turn it off.\n                            this._output.raw = this._options.test_output_raw;\n                        }\n                        return;\n                    }\n                    if (current_token.directives) {\n                        this.print_newline(false, preserve_statement_flags);\n                        this.print_token(current_token);\n                        if (current_token.directives.preserve === \"start\") {\n                            this._output.raw = true;\n                        }\n                        this.print_newline(false, true);\n                        return;\n                    }\n                    // inline block\n                    if (!acorn.newline.test(current_token.text) && !current_token.newlines) {\n                        this._output.space_before_token = true;\n                        this.print_token(current_token);\n                        this._output.space_before_token = true;\n                        return;\n                    } else {\n                        this.print_block_commment(current_token, preserve_statement_flags);\n                    }\n                };\n                Beautifier.prototype.print_block_commment = function(current_token, preserve_statement_flags) {\n                    var lines = split_linebreaks(current_token.text);\n                    var j; // iterator for this case\n                    var javadoc = false;\n                    var starless = false;\n                    var lastIndent = current_token.whitespace_before;\n                    var lastIndentLength = lastIndent.length;\n                    // block comment starts with a new line\n                    this.print_newline(false, preserve_statement_flags);\n                    // first line always indented\n                    this.print_token_line_indentation(current_token);\n                    this._output.add_token(lines[0]);\n                    this.print_newline(false, preserve_statement_flags);\n                    if (lines.length > 1) {\n                        lines = lines.slice(1);\n                        javadoc = all_lines_start_with(lines, \"*\");\n                        starless = each_line_matches_indent(lines, lastIndent);\n                        if (javadoc) {\n                            this._flags.alignment = 1;\n                        }\n                        for(j = 0; j < lines.length; j++){\n                            if (javadoc) {\n                                // javadoc: reformat and re-indent\n                                this.print_token_line_indentation(current_token);\n                                this._output.add_token(ltrim(lines[j]));\n                            } else if (starless && lines[j]) {\n                                // starless: re-indent non-empty content, avoiding trim\n                                this.print_token_line_indentation(current_token);\n                                this._output.add_token(lines[j].substring(lastIndentLength));\n                            } else {\n                                // normal comments output raw\n                                this._output.current_line.set_indent(-1);\n                                this._output.add_token(lines[j]);\n                            }\n                            // for comments on their own line or  more than one line, make sure there's a new line after\n                            this.print_newline(false, preserve_statement_flags);\n                        }\n                        this._flags.alignment = 0;\n                    }\n                };\n                Beautifier.prototype.handle_comment = function(current_token, preserve_statement_flags) {\n                    if (current_token.newlines) {\n                        this.print_newline(false, preserve_statement_flags);\n                    } else {\n                        this._output.trim(true);\n                    }\n                    this._output.space_before_token = true;\n                    this.print_token(current_token);\n                    this.print_newline(false, preserve_statement_flags);\n                };\n                Beautifier.prototype.handle_dot = function(current_token) {\n                    if (this.start_of_statement(current_token)) {\n                    // The conditional starts the statement if appropriate.\n                    } else {\n                        this.handle_whitespace_and_comments(current_token, true);\n                    }\n                    if (this._flags.last_token.text.match(\"^[0-9]+$\")) {\n                        this._output.space_before_token = true;\n                    }\n                    if (reserved_array(this._flags.last_token, special_words)) {\n                        this._output.space_before_token = false;\n                    } else {\n                        // allow preserved newlines before dots in general\n                        // force newlines on dots after close paren when break_chained - for bar().baz()\n                        this.allow_wrap_or_preserved_newline(current_token, this._flags.last_token.text === \")\" && this._options.break_chained_methods);\n                    }\n                    // Only unindent chained method dot if this dot starts a new line.\n                    // Otherwise the automatic extra indentation removal will handle the over indent\n                    if (this._options.unindent_chained_methods && this._output.just_added_newline()) {\n                        this.deindent();\n                    }\n                    this.print_token(current_token);\n                };\n                Beautifier.prototype.handle_unknown = function(current_token, preserve_statement_flags) {\n                    this.print_token(current_token);\n                    if (current_token.text[current_token.text.length - 1] === \"\\n\") {\n                        this.print_newline(false, preserve_statement_flags);\n                    }\n                };\n                Beautifier.prototype.handle_eof = function(current_token) {\n                    // Unwind any open statements\n                    while(this._flags.mode === MODE.Statement){\n                        this.restore_mode();\n                    }\n                    this.handle_whitespace_and_comments(current_token);\n                };\n                module.exports.Beautifier = Beautifier;\n            /***/ },\n            /* 2 */ /***/ function(module) {\n                /*jshint node:true */ /*\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function OutputLine(parent) {\n                    this.__parent = parent;\n                    this.__character_count = 0;\n                    // use indent_count as a marker for this.__lines that have preserved indentation\n                    this.__indent_count = -1;\n                    this.__alignment_count = 0;\n                    this.__wrap_point_index = 0;\n                    this.__wrap_point_character_count = 0;\n                    this.__wrap_point_indent_count = -1;\n                    this.__wrap_point_alignment_count = 0;\n                    this.__items = [];\n                }\n                OutputLine.prototype.clone_empty = function() {\n                    var line = new OutputLine(this.__parent);\n                    line.set_indent(this.__indent_count, this.__alignment_count);\n                    return line;\n                };\n                OutputLine.prototype.item = function(index) {\n                    if (index < 0) {\n                        return this.__items[this.__items.length + index];\n                    } else {\n                        return this.__items[index];\n                    }\n                };\n                OutputLine.prototype.has_match = function(pattern) {\n                    for(var lastCheckedOutput = this.__items.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--){\n                        if (this.__items[lastCheckedOutput].match(pattern)) {\n                            return true;\n                        }\n                    }\n                    return false;\n                };\n                OutputLine.prototype.set_indent = function(indent, alignment) {\n                    if (this.is_empty()) {\n                        this.__indent_count = indent || 0;\n                        this.__alignment_count = alignment || 0;\n                        this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);\n                    }\n                };\n                OutputLine.prototype._set_wrap_point = function() {\n                    if (this.__parent.wrap_line_length) {\n                        this.__wrap_point_index = this.__items.length;\n                        this.__wrap_point_character_count = this.__character_count;\n                        this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;\n                        this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;\n                    }\n                };\n                OutputLine.prototype._should_wrap = function() {\n                    return this.__wrap_point_index && this.__character_count > this.__parent.wrap_line_length && this.__wrap_point_character_count > this.__parent.next_line.__character_count;\n                };\n                OutputLine.prototype._allow_wrap = function() {\n                    if (this._should_wrap()) {\n                        this.__parent.add_new_line();\n                        var next = this.__parent.current_line;\n                        next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);\n                        next.__items = this.__items.slice(this.__wrap_point_index);\n                        this.__items = this.__items.slice(0, this.__wrap_point_index);\n                        next.__character_count += this.__character_count - this.__wrap_point_character_count;\n                        this.__character_count = this.__wrap_point_character_count;\n                        if (next.__items[0] === \" \") {\n                            next.__items.splice(0, 1);\n                            next.__character_count -= 1;\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n                OutputLine.prototype.is_empty = function() {\n                    return this.__items.length === 0;\n                };\n                OutputLine.prototype.last = function() {\n                    if (!this.is_empty()) {\n                        return this.__items[this.__items.length - 1];\n                    } else {\n                        return null;\n                    }\n                };\n                OutputLine.prototype.push = function(item) {\n                    this.__items.push(item);\n                    var last_newline_index = item.lastIndexOf(\"\\n\");\n                    if (last_newline_index !== -1) {\n                        this.__character_count = item.length - last_newline_index;\n                    } else {\n                        this.__character_count += item.length;\n                    }\n                };\n                OutputLine.prototype.pop = function() {\n                    var item = null;\n                    if (!this.is_empty()) {\n                        item = this.__items.pop();\n                        this.__character_count -= item.length;\n                    }\n                    return item;\n                };\n                OutputLine.prototype._remove_indent = function() {\n                    if (this.__indent_count > 0) {\n                        this.__indent_count -= 1;\n                        this.__character_count -= this.__parent.indent_size;\n                    }\n                };\n                OutputLine.prototype._remove_wrap_indent = function() {\n                    if (this.__wrap_point_indent_count > 0) {\n                        this.__wrap_point_indent_count -= 1;\n                    }\n                };\n                OutputLine.prototype.trim = function() {\n                    while(this.last() === \" \"){\n                        this.__items.pop();\n                        this.__character_count -= 1;\n                    }\n                };\n                OutputLine.prototype.toString = function() {\n                    var result = \"\";\n                    if (this.is_empty()) {\n                        if (this.__parent.indent_empty_lines) {\n                            result = this.__parent.get_indent_string(this.__indent_count);\n                        }\n                    } else {\n                        result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);\n                        result += this.__items.join(\"\");\n                    }\n                    return result;\n                };\n                function IndentStringCache(options, baseIndentString) {\n                    this.__cache = [\n                        \"\"\n                    ];\n                    this.__indent_size = options.indent_size;\n                    this.__indent_string = options.indent_char;\n                    if (!options.indent_with_tabs) {\n                        this.__indent_string = new Array(options.indent_size + 1).join(options.indent_char);\n                    }\n                    // Set to null to continue support for auto detection of base indent\n                    baseIndentString = baseIndentString || \"\";\n                    if (options.indent_level > 0) {\n                        baseIndentString = new Array(options.indent_level + 1).join(this.__indent_string);\n                    }\n                    this.__base_string = baseIndentString;\n                    this.__base_string_length = baseIndentString.length;\n                }\n                IndentStringCache.prototype.get_indent_size = function(indent, column) {\n                    var result = this.__base_string_length;\n                    column = column || 0;\n                    if (indent < 0) {\n                        result = 0;\n                    }\n                    result += indent * this.__indent_size;\n                    result += column;\n                    return result;\n                };\n                IndentStringCache.prototype.get_indent_string = function(indent_level, column) {\n                    var result = this.__base_string;\n                    column = column || 0;\n                    if (indent_level < 0) {\n                        indent_level = 0;\n                        result = \"\";\n                    }\n                    column += indent_level * this.__indent_size;\n                    this.__ensure_cache(column);\n                    result += this.__cache[column];\n                    return result;\n                };\n                IndentStringCache.prototype.__ensure_cache = function(column) {\n                    while(column >= this.__cache.length){\n                        this.__add_column();\n                    }\n                };\n                IndentStringCache.prototype.__add_column = function() {\n                    var column = this.__cache.length;\n                    var indent = 0;\n                    var result = \"\";\n                    if (this.__indent_size && column >= this.__indent_size) {\n                        indent = Math.floor(column / this.__indent_size);\n                        column -= indent * this.__indent_size;\n                        result = new Array(indent + 1).join(this.__indent_string);\n                    }\n                    if (column) {\n                        result += new Array(column + 1).join(\" \");\n                    }\n                    this.__cache.push(result);\n                };\n                function Output(options, baseIndentString) {\n                    this.__indent_cache = new IndentStringCache(options, baseIndentString);\n                    this.raw = false;\n                    this._end_with_newline = options.end_with_newline;\n                    this.indent_size = options.indent_size;\n                    this.wrap_line_length = options.wrap_line_length;\n                    this.indent_empty_lines = options.indent_empty_lines;\n                    this.__lines = [];\n                    this.previous_line = null;\n                    this.current_line = null;\n                    this.next_line = new OutputLine(this);\n                    this.space_before_token = false;\n                    this.non_breaking_space = false;\n                    this.previous_token_wrapped = false;\n                    // initialize\n                    this.__add_outputline();\n                }\n                Output.prototype.__add_outputline = function() {\n                    this.previous_line = this.current_line;\n                    this.current_line = this.next_line.clone_empty();\n                    this.__lines.push(this.current_line);\n                };\n                Output.prototype.get_line_number = function() {\n                    return this.__lines.length;\n                };\n                Output.prototype.get_indent_string = function(indent, column) {\n                    return this.__indent_cache.get_indent_string(indent, column);\n                };\n                Output.prototype.get_indent_size = function(indent, column) {\n                    return this.__indent_cache.get_indent_size(indent, column);\n                };\n                Output.prototype.is_empty = function() {\n                    return !this.previous_line && this.current_line.is_empty();\n                };\n                Output.prototype.add_new_line = function(force_newline) {\n                    // never newline at the start of file\n                    // otherwise, newline only if we didn't just add one or we're forced\n                    if (this.is_empty() || !force_newline && this.just_added_newline()) {\n                        return false;\n                    }\n                    // if raw output is enabled, don't print additional newlines,\n                    // but still return True as though you had\n                    if (!this.raw) {\n                        this.__add_outputline();\n                    }\n                    return true;\n                };\n                Output.prototype.get_code = function(eol) {\n                    this.trim(true);\n                    // handle some edge cases where the last tokens\n                    // has text that ends with newline(s)\n                    var last_item = this.current_line.pop();\n                    if (last_item) {\n                        if (last_item[last_item.length - 1] === \"\\n\") {\n                            last_item = last_item.replace(/\\n+$/g, \"\");\n                        }\n                        this.current_line.push(last_item);\n                    }\n                    if (this._end_with_newline) {\n                        this.__add_outputline();\n                    }\n                    var sweet_code = this.__lines.join(\"\\n\");\n                    if (eol !== \"\\n\") {\n                        sweet_code = sweet_code.replace(/[\\n]/g, eol);\n                    }\n                    return sweet_code;\n                };\n                Output.prototype.set_wrap_point = function() {\n                    this.current_line._set_wrap_point();\n                };\n                Output.prototype.set_indent = function(indent, alignment) {\n                    indent = indent || 0;\n                    alignment = alignment || 0;\n                    // Next line stores alignment values\n                    this.next_line.set_indent(indent, alignment);\n                    // Never indent your first output indent at the start of the file\n                    if (this.__lines.length > 1) {\n                        this.current_line.set_indent(indent, alignment);\n                        return true;\n                    }\n                    this.current_line.set_indent();\n                    return false;\n                };\n                Output.prototype.add_raw_token = function(token) {\n                    for(var x = 0; x < token.newlines; x++){\n                        this.__add_outputline();\n                    }\n                    this.current_line.set_indent(-1);\n                    this.current_line.push(token.whitespace_before);\n                    this.current_line.push(token.text);\n                    this.space_before_token = false;\n                    this.non_breaking_space = false;\n                    this.previous_token_wrapped = false;\n                };\n                Output.prototype.add_token = function(printable_token) {\n                    this.__add_space_before_token();\n                    this.current_line.push(printable_token);\n                    this.space_before_token = false;\n                    this.non_breaking_space = false;\n                    this.previous_token_wrapped = this.current_line._allow_wrap();\n                };\n                Output.prototype.__add_space_before_token = function() {\n                    if (this.space_before_token && !this.just_added_newline()) {\n                        if (!this.non_breaking_space) {\n                            this.set_wrap_point();\n                        }\n                        this.current_line.push(\" \");\n                    }\n                };\n                Output.prototype.remove_indent = function(index) {\n                    var output_length = this.__lines.length;\n                    while(index < output_length){\n                        this.__lines[index]._remove_indent();\n                        index++;\n                    }\n                    this.current_line._remove_wrap_indent();\n                };\n                Output.prototype.trim = function(eat_newlines) {\n                    eat_newlines = eat_newlines === undefined ? false : eat_newlines;\n                    this.current_line.trim();\n                    while(eat_newlines && this.__lines.length > 1 && this.current_line.is_empty()){\n                        this.__lines.pop();\n                        this.current_line = this.__lines[this.__lines.length - 1];\n                        this.current_line.trim();\n                    }\n                    this.previous_line = this.__lines.length > 1 ? this.__lines[this.__lines.length - 2] : null;\n                };\n                Output.prototype.just_added_newline = function() {\n                    return this.current_line.is_empty();\n                };\n                Output.prototype.just_added_blankline = function() {\n                    return this.is_empty() || this.current_line.is_empty() && this.previous_line.is_empty();\n                };\n                Output.prototype.ensure_empty_line_above = function(starts_with, ends_with) {\n                    var index = this.__lines.length - 2;\n                    while(index >= 0){\n                        var potentialEmptyLine = this.__lines[index];\n                        if (potentialEmptyLine.is_empty()) {\n                            break;\n                        } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 && potentialEmptyLine.item(-1) !== ends_with) {\n                            this.__lines.splice(index + 1, 0, new OutputLine(this));\n                            this.previous_line = this.__lines[this.__lines.length - 2];\n                            break;\n                        }\n                        index--;\n                    }\n                };\n                module.exports.Output = Output;\n            /***/ },\n            /* 3 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function Token(type, text, newlines, whitespace_before) {\n                    this.type = type;\n                    this.text = text;\n                    // comments_before are\n                    // comments that have a new line before them\n                    // and may or may not have a newline after\n                    // this is a set of comments before\n                    this.comments_before = null; /* inline comment*/ \n                    // this.comments_after =  new TokenStream(); // no new line before and newline after\n                    this.newlines = newlines || 0;\n                    this.whitespace_before = whitespace_before || \"\";\n                    this.parent = null;\n                    this.next = null;\n                    this.previous = null;\n                    this.opened = null;\n                    this.closed = null;\n                    this.directives = null;\n                }\n                module.exports.Token = Token;\n            /***/ },\n            /* 4 */ /***/ function(__unused_webpack_module, exports1) {\n                /* jshint node: true, curly: false */ // Parts of this section of code is taken from acorn.\n                //\n                // Acorn was written by Marijn Haverbeke and released under an MIT\n                // license. The Unicode regexps (for identifiers and whitespace) were\n                // taken from [Esprima](http://esprima.org) by Ariya Hidayat.\n                //\n                // Git repositories for Acorn are available at\n                //\n                //     http://marijnhaverbeke.nl/git/acorn\n                //     https://github.com/marijnh/acorn.git\n                // ## Character categories\n                // acorn used char codes to squeeze the last bit of performance out\n                // Beautifier is okay without that, so we're using regex\n                // permit # (23), $ (36), and @ (64). @ is used in ES7 decorators.\n                // 65 through 91 are uppercase letters.\n                // permit _ (95).\n                // 97 through 123 are lowercase letters.\n                var baseASCIIidentifierStartChars = \"\\\\x23\\\\x24\\\\x40\\\\x41-\\\\x5a\\\\x5f\\\\x61-\\\\x7a\";\n                // inside an identifier @ is not allowed but 0-9 are.\n                var baseASCIIidentifierChars = \"\\\\x24\\\\x30-\\\\x39\\\\x41-\\\\x5a\\\\x5f\\\\x61-\\\\x7a\";\n                // Big ugly regular expressions that match characters in the\n                // whitespace, identifier, and identifier-start categories. These\n                // are only applied when a character is found to actually have a\n                // code point above 128.\n                var nonASCIIidentifierStartChars = \"\\\\xaa\\\\xb5\\\\xba\\\\xc0-\\\\xd6\\\\xd8-\\\\xf6\\\\xf8-\\\\u02c1\\\\u02c6-\\\\u02d1\\\\u02e0-\\\\u02e4\\\\u02ec\\\\u02ee\\\\u0370-\\\\u0374\\\\u0376\\\\u0377\\\\u037a-\\\\u037d\\\\u0386\\\\u0388-\\\\u038a\\\\u038c\\\\u038e-\\\\u03a1\\\\u03a3-\\\\u03f5\\\\u03f7-\\\\u0481\\\\u048a-\\\\u0527\\\\u0531-\\\\u0556\\\\u0559\\\\u0561-\\\\u0587\\\\u05d0-\\\\u05ea\\\\u05f0-\\\\u05f2\\\\u0620-\\\\u064a\\\\u066e\\\\u066f\\\\u0671-\\\\u06d3\\\\u06d5\\\\u06e5\\\\u06e6\\\\u06ee\\\\u06ef\\\\u06fa-\\\\u06fc\\\\u06ff\\\\u0710\\\\u0712-\\\\u072f\\\\u074d-\\\\u07a5\\\\u07b1\\\\u07ca-\\\\u07ea\\\\u07f4\\\\u07f5\\\\u07fa\\\\u0800-\\\\u0815\\\\u081a\\\\u0824\\\\u0828\\\\u0840-\\\\u0858\\\\u08a0\\\\u08a2-\\\\u08ac\\\\u0904-\\\\u0939\\\\u093d\\\\u0950\\\\u0958-\\\\u0961\\\\u0971-\\\\u0977\\\\u0979-\\\\u097f\\\\u0985-\\\\u098c\\\\u098f\\\\u0990\\\\u0993-\\\\u09a8\\\\u09aa-\\\\u09b0\\\\u09b2\\\\u09b6-\\\\u09b9\\\\u09bd\\\\u09ce\\\\u09dc\\\\u09dd\\\\u09df-\\\\u09e1\\\\u09f0\\\\u09f1\\\\u0a05-\\\\u0a0a\\\\u0a0f\\\\u0a10\\\\u0a13-\\\\u0a28\\\\u0a2a-\\\\u0a30\\\\u0a32\\\\u0a33\\\\u0a35\\\\u0a36\\\\u0a38\\\\u0a39\\\\u0a59-\\\\u0a5c\\\\u0a5e\\\\u0a72-\\\\u0a74\\\\u0a85-\\\\u0a8d\\\\u0a8f-\\\\u0a91\\\\u0a93-\\\\u0aa8\\\\u0aaa-\\\\u0ab0\\\\u0ab2\\\\u0ab3\\\\u0ab5-\\\\u0ab9\\\\u0abd\\\\u0ad0\\\\u0ae0\\\\u0ae1\\\\u0b05-\\\\u0b0c\\\\u0b0f\\\\u0b10\\\\u0b13-\\\\u0b28\\\\u0b2a-\\\\u0b30\\\\u0b32\\\\u0b33\\\\u0b35-\\\\u0b39\\\\u0b3d\\\\u0b5c\\\\u0b5d\\\\u0b5f-\\\\u0b61\\\\u0b71\\\\u0b83\\\\u0b85-\\\\u0b8a\\\\u0b8e-\\\\u0b90\\\\u0b92-\\\\u0b95\\\\u0b99\\\\u0b9a\\\\u0b9c\\\\u0b9e\\\\u0b9f\\\\u0ba3\\\\u0ba4\\\\u0ba8-\\\\u0baa\\\\u0bae-\\\\u0bb9\\\\u0bd0\\\\u0c05-\\\\u0c0c\\\\u0c0e-\\\\u0c10\\\\u0c12-\\\\u0c28\\\\u0c2a-\\\\u0c33\\\\u0c35-\\\\u0c39\\\\u0c3d\\\\u0c58\\\\u0c59\\\\u0c60\\\\u0c61\\\\u0c85-\\\\u0c8c\\\\u0c8e-\\\\u0c90\\\\u0c92-\\\\u0ca8\\\\u0caa-\\\\u0cb3\\\\u0cb5-\\\\u0cb9\\\\u0cbd\\\\u0cde\\\\u0ce0\\\\u0ce1\\\\u0cf1\\\\u0cf2\\\\u0d05-\\\\u0d0c\\\\u0d0e-\\\\u0d10\\\\u0d12-\\\\u0d3a\\\\u0d3d\\\\u0d4e\\\\u0d60\\\\u0d61\\\\u0d7a-\\\\u0d7f\\\\u0d85-\\\\u0d96\\\\u0d9a-\\\\u0db1\\\\u0db3-\\\\u0dbb\\\\u0dbd\\\\u0dc0-\\\\u0dc6\\\\u0e01-\\\\u0e30\\\\u0e32\\\\u0e33\\\\u0e40-\\\\u0e46\\\\u0e81\\\\u0e82\\\\u0e84\\\\u0e87\\\\u0e88\\\\u0e8a\\\\u0e8d\\\\u0e94-\\\\u0e97\\\\u0e99-\\\\u0e9f\\\\u0ea1-\\\\u0ea3\\\\u0ea5\\\\u0ea7\\\\u0eaa\\\\u0eab\\\\u0ead-\\\\u0eb0\\\\u0eb2\\\\u0eb3\\\\u0ebd\\\\u0ec0-\\\\u0ec4\\\\u0ec6\\\\u0edc-\\\\u0edf\\\\u0f00\\\\u0f40-\\\\u0f47\\\\u0f49-\\\\u0f6c\\\\u0f88-\\\\u0f8c\\\\u1000-\\\\u102a\\\\u103f\\\\u1050-\\\\u1055\\\\u105a-\\\\u105d\\\\u1061\\\\u1065\\\\u1066\\\\u106e-\\\\u1070\\\\u1075-\\\\u1081\\\\u108e\\\\u10a0-\\\\u10c5\\\\u10c7\\\\u10cd\\\\u10d0-\\\\u10fa\\\\u10fc-\\\\u1248\\\\u124a-\\\\u124d\\\\u1250-\\\\u1256\\\\u1258\\\\u125a-\\\\u125d\\\\u1260-\\\\u1288\\\\u128a-\\\\u128d\\\\u1290-\\\\u12b0\\\\u12b2-\\\\u12b5\\\\u12b8-\\\\u12be\\\\u12c0\\\\u12c2-\\\\u12c5\\\\u12c8-\\\\u12d6\\\\u12d8-\\\\u1310\\\\u1312-\\\\u1315\\\\u1318-\\\\u135a\\\\u1380-\\\\u138f\\\\u13a0-\\\\u13f4\\\\u1401-\\\\u166c\\\\u166f-\\\\u167f\\\\u1681-\\\\u169a\\\\u16a0-\\\\u16ea\\\\u16ee-\\\\u16f0\\\\u1700-\\\\u170c\\\\u170e-\\\\u1711\\\\u1720-\\\\u1731\\\\u1740-\\\\u1751\\\\u1760-\\\\u176c\\\\u176e-\\\\u1770\\\\u1780-\\\\u17b3\\\\u17d7\\\\u17dc\\\\u1820-\\\\u1877\\\\u1880-\\\\u18a8\\\\u18aa\\\\u18b0-\\\\u18f5\\\\u1900-\\\\u191c\\\\u1950-\\\\u196d\\\\u1970-\\\\u1974\\\\u1980-\\\\u19ab\\\\u19c1-\\\\u19c7\\\\u1a00-\\\\u1a16\\\\u1a20-\\\\u1a54\\\\u1aa7\\\\u1b05-\\\\u1b33\\\\u1b45-\\\\u1b4b\\\\u1b83-\\\\u1ba0\\\\u1bae\\\\u1baf\\\\u1bba-\\\\u1be5\\\\u1c00-\\\\u1c23\\\\u1c4d-\\\\u1c4f\\\\u1c5a-\\\\u1c7d\\\\u1ce9-\\\\u1cec\\\\u1cee-\\\\u1cf1\\\\u1cf5\\\\u1cf6\\\\u1d00-\\\\u1dbf\\\\u1e00-\\\\u1f15\\\\u1f18-\\\\u1f1d\\\\u1f20-\\\\u1f45\\\\u1f48-\\\\u1f4d\\\\u1f50-\\\\u1f57\\\\u1f59\\\\u1f5b\\\\u1f5d\\\\u1f5f-\\\\u1f7d\\\\u1f80-\\\\u1fb4\\\\u1fb6-\\\\u1fbc\\\\u1fbe\\\\u1fc2-\\\\u1fc4\\\\u1fc6-\\\\u1fcc\\\\u1fd0-\\\\u1fd3\\\\u1fd6-\\\\u1fdb\\\\u1fe0-\\\\u1fec\\\\u1ff2-\\\\u1ff4\\\\u1ff6-\\\\u1ffc\\\\u2071\\\\u207f\\\\u2090-\\\\u209c\\\\u2102\\\\u2107\\\\u210a-\\\\u2113\\\\u2115\\\\u2119-\\\\u211d\\\\u2124\\\\u2126\\\\u2128\\\\u212a-\\\\u212d\\\\u212f-\\\\u2139\\\\u213c-\\\\u213f\\\\u2145-\\\\u2149\\\\u214e\\\\u2160-\\\\u2188\\\\u2c00-\\\\u2c2e\\\\u2c30-\\\\u2c5e\\\\u2c60-\\\\u2ce4\\\\u2ceb-\\\\u2cee\\\\u2cf2\\\\u2cf3\\\\u2d00-\\\\u2d25\\\\u2d27\\\\u2d2d\\\\u2d30-\\\\u2d67\\\\u2d6f\\\\u2d80-\\\\u2d96\\\\u2da0-\\\\u2da6\\\\u2da8-\\\\u2dae\\\\u2db0-\\\\u2db6\\\\u2db8-\\\\u2dbe\\\\u2dc0-\\\\u2dc6\\\\u2dc8-\\\\u2dce\\\\u2dd0-\\\\u2dd6\\\\u2dd8-\\\\u2dde\\\\u2e2f\\\\u3005-\\\\u3007\\\\u3021-\\\\u3029\\\\u3031-\\\\u3035\\\\u3038-\\\\u303c\\\\u3041-\\\\u3096\\\\u309d-\\\\u309f\\\\u30a1-\\\\u30fa\\\\u30fc-\\\\u30ff\\\\u3105-\\\\u312d\\\\u3131-\\\\u318e\\\\u31a0-\\\\u31ba\\\\u31f0-\\\\u31ff\\\\u3400-\\\\u4db5\\\\u4e00-\\\\u9fcc\\\\ua000-\\\\ua48c\\\\ua4d0-\\\\ua4fd\\\\ua500-\\\\ua60c\\\\ua610-\\\\ua61f\\\\ua62a\\\\ua62b\\\\ua640-\\\\ua66e\\\\ua67f-\\\\ua697\\\\ua6a0-\\\\ua6ef\\\\ua717-\\\\ua71f\\\\ua722-\\\\ua788\\\\ua78b-\\\\ua78e\\\\ua790-\\\\ua793\\\\ua7a0-\\\\ua7aa\\\\ua7f8-\\\\ua801\\\\ua803-\\\\ua805\\\\ua807-\\\\ua80a\\\\ua80c-\\\\ua822\\\\ua840-\\\\ua873\\\\ua882-\\\\ua8b3\\\\ua8f2-\\\\ua8f7\\\\ua8fb\\\\ua90a-\\\\ua925\\\\ua930-\\\\ua946\\\\ua960-\\\\ua97c\\\\ua984-\\\\ua9b2\\\\ua9cf\\\\uaa00-\\\\uaa28\\\\uaa40-\\\\uaa42\\\\uaa44-\\\\uaa4b\\\\uaa60-\\\\uaa76\\\\uaa7a\\\\uaa80-\\\\uaaaf\\\\uaab1\\\\uaab5\\\\uaab6\\\\uaab9-\\\\uaabd\\\\uaac0\\\\uaac2\\\\uaadb-\\\\uaadd\\\\uaae0-\\\\uaaea\\\\uaaf2-\\\\uaaf4\\\\uab01-\\\\uab06\\\\uab09-\\\\uab0e\\\\uab11-\\\\uab16\\\\uab20-\\\\uab26\\\\uab28-\\\\uab2e\\\\uabc0-\\\\uabe2\\\\uac00-\\\\ud7a3\\\\ud7b0-\\\\ud7c6\\\\ud7cb-\\\\ud7fb\\\\uf900-\\\\ufa6d\\\\ufa70-\\\\ufad9\\\\ufb00-\\\\ufb06\\\\ufb13-\\\\ufb17\\\\ufb1d\\\\ufb1f-\\\\ufb28\\\\ufb2a-\\\\ufb36\\\\ufb38-\\\\ufb3c\\\\ufb3e\\\\ufb40\\\\ufb41\\\\ufb43\\\\ufb44\\\\ufb46-\\\\ufbb1\\\\ufbd3-\\\\ufd3d\\\\ufd50-\\\\ufd8f\\\\ufd92-\\\\ufdc7\\\\ufdf0-\\\\ufdfb\\\\ufe70-\\\\ufe74\\\\ufe76-\\\\ufefc\\\\uff21-\\\\uff3a\\\\uff41-\\\\uff5a\\\\uff66-\\\\uffbe\\\\uffc2-\\\\uffc7\\\\uffca-\\\\uffcf\\\\uffd2-\\\\uffd7\\\\uffda-\\\\uffdc\";\n                var nonASCIIidentifierChars = \"\\\\u0300-\\\\u036f\\\\u0483-\\\\u0487\\\\u0591-\\\\u05bd\\\\u05bf\\\\u05c1\\\\u05c2\\\\u05c4\\\\u05c5\\\\u05c7\\\\u0610-\\\\u061a\\\\u0620-\\\\u0649\\\\u0672-\\\\u06d3\\\\u06e7-\\\\u06e8\\\\u06fb-\\\\u06fc\\\\u0730-\\\\u074a\\\\u0800-\\\\u0814\\\\u081b-\\\\u0823\\\\u0825-\\\\u0827\\\\u0829-\\\\u082d\\\\u0840-\\\\u0857\\\\u08e4-\\\\u08fe\\\\u0900-\\\\u0903\\\\u093a-\\\\u093c\\\\u093e-\\\\u094f\\\\u0951-\\\\u0957\\\\u0962-\\\\u0963\\\\u0966-\\\\u096f\\\\u0981-\\\\u0983\\\\u09bc\\\\u09be-\\\\u09c4\\\\u09c7\\\\u09c8\\\\u09d7\\\\u09df-\\\\u09e0\\\\u0a01-\\\\u0a03\\\\u0a3c\\\\u0a3e-\\\\u0a42\\\\u0a47\\\\u0a48\\\\u0a4b-\\\\u0a4d\\\\u0a51\\\\u0a66-\\\\u0a71\\\\u0a75\\\\u0a81-\\\\u0a83\\\\u0abc\\\\u0abe-\\\\u0ac5\\\\u0ac7-\\\\u0ac9\\\\u0acb-\\\\u0acd\\\\u0ae2-\\\\u0ae3\\\\u0ae6-\\\\u0aef\\\\u0b01-\\\\u0b03\\\\u0b3c\\\\u0b3e-\\\\u0b44\\\\u0b47\\\\u0b48\\\\u0b4b-\\\\u0b4d\\\\u0b56\\\\u0b57\\\\u0b5f-\\\\u0b60\\\\u0b66-\\\\u0b6f\\\\u0b82\\\\u0bbe-\\\\u0bc2\\\\u0bc6-\\\\u0bc8\\\\u0bca-\\\\u0bcd\\\\u0bd7\\\\u0be6-\\\\u0bef\\\\u0c01-\\\\u0c03\\\\u0c46-\\\\u0c48\\\\u0c4a-\\\\u0c4d\\\\u0c55\\\\u0c56\\\\u0c62-\\\\u0c63\\\\u0c66-\\\\u0c6f\\\\u0c82\\\\u0c83\\\\u0cbc\\\\u0cbe-\\\\u0cc4\\\\u0cc6-\\\\u0cc8\\\\u0cca-\\\\u0ccd\\\\u0cd5\\\\u0cd6\\\\u0ce2-\\\\u0ce3\\\\u0ce6-\\\\u0cef\\\\u0d02\\\\u0d03\\\\u0d46-\\\\u0d48\\\\u0d57\\\\u0d62-\\\\u0d63\\\\u0d66-\\\\u0d6f\\\\u0d82\\\\u0d83\\\\u0dca\\\\u0dcf-\\\\u0dd4\\\\u0dd6\\\\u0dd8-\\\\u0ddf\\\\u0df2\\\\u0df3\\\\u0e34-\\\\u0e3a\\\\u0e40-\\\\u0e45\\\\u0e50-\\\\u0e59\\\\u0eb4-\\\\u0eb9\\\\u0ec8-\\\\u0ecd\\\\u0ed0-\\\\u0ed9\\\\u0f18\\\\u0f19\\\\u0f20-\\\\u0f29\\\\u0f35\\\\u0f37\\\\u0f39\\\\u0f41-\\\\u0f47\\\\u0f71-\\\\u0f84\\\\u0f86-\\\\u0f87\\\\u0f8d-\\\\u0f97\\\\u0f99-\\\\u0fbc\\\\u0fc6\\\\u1000-\\\\u1029\\\\u1040-\\\\u1049\\\\u1067-\\\\u106d\\\\u1071-\\\\u1074\\\\u1082-\\\\u108d\\\\u108f-\\\\u109d\\\\u135d-\\\\u135f\\\\u170e-\\\\u1710\\\\u1720-\\\\u1730\\\\u1740-\\\\u1750\\\\u1772\\\\u1773\\\\u1780-\\\\u17b2\\\\u17dd\\\\u17e0-\\\\u17e9\\\\u180b-\\\\u180d\\\\u1810-\\\\u1819\\\\u1920-\\\\u192b\\\\u1930-\\\\u193b\\\\u1951-\\\\u196d\\\\u19b0-\\\\u19c0\\\\u19c8-\\\\u19c9\\\\u19d0-\\\\u19d9\\\\u1a00-\\\\u1a15\\\\u1a20-\\\\u1a53\\\\u1a60-\\\\u1a7c\\\\u1a7f-\\\\u1a89\\\\u1a90-\\\\u1a99\\\\u1b46-\\\\u1b4b\\\\u1b50-\\\\u1b59\\\\u1b6b-\\\\u1b73\\\\u1bb0-\\\\u1bb9\\\\u1be6-\\\\u1bf3\\\\u1c00-\\\\u1c22\\\\u1c40-\\\\u1c49\\\\u1c5b-\\\\u1c7d\\\\u1cd0-\\\\u1cd2\\\\u1d00-\\\\u1dbe\\\\u1e01-\\\\u1f15\\\\u200c\\\\u200d\\\\u203f\\\\u2040\\\\u2054\\\\u20d0-\\\\u20dc\\\\u20e1\\\\u20e5-\\\\u20f0\\\\u2d81-\\\\u2d96\\\\u2de0-\\\\u2dff\\\\u3021-\\\\u3028\\\\u3099\\\\u309a\\\\ua640-\\\\ua66d\\\\ua674-\\\\ua67d\\\\ua69f\\\\ua6f0-\\\\ua6f1\\\\ua7f8-\\\\ua800\\\\ua806\\\\ua80b\\\\ua823-\\\\ua827\\\\ua880-\\\\ua881\\\\ua8b4-\\\\ua8c4\\\\ua8d0-\\\\ua8d9\\\\ua8f3-\\\\ua8f7\\\\ua900-\\\\ua909\\\\ua926-\\\\ua92d\\\\ua930-\\\\ua945\\\\ua980-\\\\ua983\\\\ua9b3-\\\\ua9c0\\\\uaa00-\\\\uaa27\\\\uaa40-\\\\uaa41\\\\uaa4c-\\\\uaa4d\\\\uaa50-\\\\uaa59\\\\uaa7b\\\\uaae0-\\\\uaae9\\\\uaaf2-\\\\uaaf3\\\\uabc0-\\\\uabe1\\\\uabec\\\\uabed\\\\uabf0-\\\\uabf9\\\\ufb20-\\\\ufb28\\\\ufe00-\\\\ufe0f\\\\ufe20-\\\\ufe26\\\\ufe33\\\\ufe34\\\\ufe4d-\\\\ufe4f\\\\uff10-\\\\uff19\\\\uff3f\";\n                //var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n                //var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n                var unicodeEscapeOrCodePoint = \"\\\\\\\\u[0-9a-fA-F]{4}|\\\\\\\\u\\\\{[0-9a-fA-F]+\\\\}\";\n                var identifierStart = \"(?:\" + unicodeEscapeOrCodePoint + \"|[\" + baseASCIIidentifierStartChars + nonASCIIidentifierStartChars + \"])\";\n                var identifierChars = \"(?:\" + unicodeEscapeOrCodePoint + \"|[\" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"])*\";\n                exports1.identifier = new RegExp(identifierStart + identifierChars, \"g\");\n                exports1.identifierStart = new RegExp(identifierStart);\n                exports1.identifierMatch = new RegExp(\"(?:\" + unicodeEscapeOrCodePoint + \"|[\" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"])+\");\n                var nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/; // jshint ignore:line\n                // Whether a single character denotes a newline.\n                exports1.newline = /[\\n\\r\\u2028\\u2029]/;\n                // Matches a whole line break (where CRLF is considered a single\n                // line break). Used to count lines.\n                // in javascript, these two differ\n                // in python they are the same, different methods are called on them\n                exports1.lineBreak = new RegExp(\"\\r\\n|\" + exports1.newline.source);\n                exports1.allLineBreaks = new RegExp(exports1.lineBreak.source, \"g\");\n            /***/ },\n            /* 5 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_122906__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var BaseOptions = __nested_webpack_require_122906__(6).Options;\n                var validPositionValues = [\n                    \"before-newline\",\n                    \"after-newline\",\n                    \"preserve-newline\"\n                ];\n                function Options(options) {\n                    BaseOptions.call(this, options, \"js\");\n                    // compatibility, re\n                    var raw_brace_style = this.raw_options.brace_style || null;\n                    if (raw_brace_style === \"expand-strict\") {\n                        this.raw_options.brace_style = \"expand\";\n                    } else if (raw_brace_style === \"collapse-preserve-inline\") {\n                        this.raw_options.brace_style = \"collapse,preserve-inline\";\n                    } else if (this.raw_options.braces_on_own_line !== undefined) {\n                        this.raw_options.brace_style = this.raw_options.braces_on_own_line ? \"expand\" : \"collapse\";\n                    // } else if (!raw_brace_style) { //Nothing exists to set it\n                    //   raw_brace_style = \"collapse\";\n                    }\n                    //preserve-inline in delimited string will trigger brace_preserve_inline, everything\n                    //else is considered a brace_style and the last one only will have an effect\n                    var brace_style_split = this._get_selection_list(\"brace_style\", [\n                        \"collapse\",\n                        \"expand\",\n                        \"end-expand\",\n                        \"none\",\n                        \"preserve-inline\"\n                    ]);\n                    this.brace_preserve_inline = false; //Defaults in case one or other was not specified in meta-option\n                    this.brace_style = \"collapse\";\n                    for(var bs = 0; bs < brace_style_split.length; bs++){\n                        if (brace_style_split[bs] === \"preserve-inline\") {\n                            this.brace_preserve_inline = true;\n                        } else {\n                            this.brace_style = brace_style_split[bs];\n                        }\n                    }\n                    this.unindent_chained_methods = this._get_boolean(\"unindent_chained_methods\");\n                    this.break_chained_methods = this._get_boolean(\"break_chained_methods\");\n                    this.space_in_paren = this._get_boolean(\"space_in_paren\");\n                    this.space_in_empty_paren = this._get_boolean(\"space_in_empty_paren\");\n                    this.jslint_happy = this._get_boolean(\"jslint_happy\");\n                    this.space_after_anon_function = this._get_boolean(\"space_after_anon_function\");\n                    this.space_after_named_function = this._get_boolean(\"space_after_named_function\");\n                    this.keep_array_indentation = this._get_boolean(\"keep_array_indentation\");\n                    this.space_before_conditional = this._get_boolean(\"space_before_conditional\", true);\n                    this.unescape_strings = this._get_boolean(\"unescape_strings\");\n                    this.e4x = this._get_boolean(\"e4x\");\n                    this.comma_first = this._get_boolean(\"comma_first\");\n                    this.operator_position = this._get_selection(\"operator_position\", validPositionValues);\n                    // For testing of beautify preserve:start directive\n                    this.test_output_raw = this._get_boolean(\"test_output_raw\");\n                    // force this._options.space_after_anon_function to true if this._options.jslint_happy\n                    if (this.jslint_happy) {\n                        this.space_after_anon_function = true;\n                    }\n                }\n                Options.prototype = new BaseOptions();\n                module.exports.Options = Options;\n            /***/ },\n            /* 6 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function Options(options, merge_child_field) {\n                    this.raw_options = _mergeOpts(options, merge_child_field);\n                    // Support passing the source text back with no change\n                    this.disabled = this._get_boolean(\"disabled\");\n                    this.eol = this._get_characters(\"eol\", \"auto\");\n                    this.end_with_newline = this._get_boolean(\"end_with_newline\");\n                    this.indent_size = this._get_number(\"indent_size\", 4);\n                    this.indent_char = this._get_characters(\"indent_char\", \" \");\n                    this.indent_level = this._get_number(\"indent_level\");\n                    this.preserve_newlines = this._get_boolean(\"preserve_newlines\", true);\n                    this.max_preserve_newlines = this._get_number(\"max_preserve_newlines\", 32786);\n                    if (!this.preserve_newlines) {\n                        this.max_preserve_newlines = 0;\n                    }\n                    this.indent_with_tabs = this._get_boolean(\"indent_with_tabs\", this.indent_char === \"\t\");\n                    if (this.indent_with_tabs) {\n                        this.indent_char = \"\t\";\n                        // indent_size behavior changed after 1.8.6\n                        // It used to be that indent_size would be\n                        // set to 1 for indent_with_tabs. That is no longer needed and\n                        // actually doesn't make sense - why not use spaces? Further,\n                        // that might produce unexpected behavior - tabs being used\n                        // for single-column alignment. So, when indent_with_tabs is true\n                        // and indent_size is 1, reset indent_size to 4.\n                        if (this.indent_size === 1) {\n                            this.indent_size = 4;\n                        }\n                    }\n                    // Backwards compat with 1.3.x\n                    this.wrap_line_length = this._get_number(\"wrap_line_length\", this._get_number(\"max_char\"));\n                    this.indent_empty_lines = this._get_boolean(\"indent_empty_lines\");\n                    // valid templating languages ['django', 'erb', 'handlebars', 'php', 'smarty']\n                    // For now, 'auto' = all off for javascript, all on for html (and inline javascript).\n                    // other values ignored\n                    this.templating = this._get_selection_list(\"templating\", [\n                        \"auto\",\n                        \"none\",\n                        \"django\",\n                        \"erb\",\n                        \"handlebars\",\n                        \"php\",\n                        \"smarty\"\n                    ], [\n                        \"auto\"\n                    ]);\n                }\n                Options.prototype._get_array = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    var result = default_value || [];\n                    if (typeof option_value === \"object\") {\n                        if (option_value !== null && typeof option_value.concat === \"function\") {\n                            result = option_value.concat();\n                        }\n                    } else if (typeof option_value === \"string\") {\n                        result = option_value.split(/[^a-zA-Z0-9_\\/\\-]+/);\n                    }\n                    return result;\n                };\n                Options.prototype._get_boolean = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    var result = option_value === undefined ? !!default_value : !!option_value;\n                    return result;\n                };\n                Options.prototype._get_characters = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    var result = default_value || \"\";\n                    if (typeof option_value === \"string\") {\n                        result = option_value.replace(/\\\\r/, \"\\r\").replace(/\\\\n/, \"\\n\").replace(/\\\\t/, \"\t\");\n                    }\n                    return result;\n                };\n                Options.prototype._get_number = function(name, default_value) {\n                    var option_value = this.raw_options[name];\n                    default_value = parseInt(default_value, 10);\n                    if (isNaN(default_value)) {\n                        default_value = 0;\n                    }\n                    var result = parseInt(option_value, 10);\n                    if (isNaN(result)) {\n                        result = default_value;\n                    }\n                    return result;\n                };\n                Options.prototype._get_selection = function(name, selection_list, default_value) {\n                    var result = this._get_selection_list(name, selection_list, default_value);\n                    if (result.length !== 1) {\n                        throw new Error(\"Invalid Option Value: The option '\" + name + \"' can only be one of the following values:\\n\" + selection_list + \"\\nYou passed in: '\" + this.raw_options[name] + \"'\");\n                    }\n                    return result[0];\n                };\n                Options.prototype._get_selection_list = function(name, selection_list, default_value) {\n                    if (!selection_list || selection_list.length === 0) {\n                        throw new Error(\"Selection list cannot be empty.\");\n                    }\n                    default_value = default_value || [\n                        selection_list[0]\n                    ];\n                    if (!this._is_valid_selection(default_value, selection_list)) {\n                        throw new Error(\"Invalid Default Value!\");\n                    }\n                    var result = this._get_array(name, default_value);\n                    if (!this._is_valid_selection(result, selection_list)) {\n                        throw new Error(\"Invalid Option Value: The option '\" + name + \"' can contain only the following values:\\n\" + selection_list + \"\\nYou passed in: '\" + this.raw_options[name] + \"'\");\n                    }\n                    return result;\n                };\n                Options.prototype._is_valid_selection = function(result, selection_list) {\n                    return result.length && selection_list.length && !result.some(function(item) {\n                        return selection_list.indexOf(item) === -1;\n                    });\n                };\n                // merges child options up with the parent options object\n                // Example: obj = {a: 1, b: {a: 2}}\n                //          mergeOpts(obj, 'b')\n                //\n                //          Returns: {a: 2}\n                function _mergeOpts(allOptions, childFieldName) {\n                    var finalOpts = {};\n                    allOptions = _normalizeOpts(allOptions);\n                    var name;\n                    for(name in allOptions){\n                        if (name !== childFieldName) {\n                            finalOpts[name] = allOptions[name];\n                        }\n                    }\n                    //merge in the per type settings for the childFieldName\n                    if (childFieldName && allOptions[childFieldName]) {\n                        for(name in allOptions[childFieldName]){\n                            finalOpts[name] = allOptions[childFieldName][name];\n                        }\n                    }\n                    return finalOpts;\n                }\n                function _normalizeOpts(options) {\n                    var convertedOpts = {};\n                    var key;\n                    for(key in options){\n                        var newKey = key.replace(/-/g, \"_\");\n                        convertedOpts[newKey] = options[key];\n                    }\n                    return convertedOpts;\n                }\n                module.exports.Options = Options;\n                module.exports.normalizeOpts = _normalizeOpts;\n                module.exports.mergeOpts = _mergeOpts;\n            /***/ },\n            /* 7 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_137433__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var InputScanner = __nested_webpack_require_137433__(8).InputScanner;\n                var BaseTokenizer = __nested_webpack_require_137433__(9).Tokenizer;\n                var BASETOKEN = __nested_webpack_require_137433__(9).TOKEN;\n                var Directives = __nested_webpack_require_137433__(13).Directives;\n                var acorn = __nested_webpack_require_137433__(4);\n                var Pattern = __nested_webpack_require_137433__(12).Pattern;\n                var TemplatablePattern = __nested_webpack_require_137433__(14).TemplatablePattern;\n                function in_array(what, arr) {\n                    return arr.indexOf(what) !== -1;\n                }\n                var TOKEN = {\n                    START_EXPR: \"TK_START_EXPR\",\n                    END_EXPR: \"TK_END_EXPR\",\n                    START_BLOCK: \"TK_START_BLOCK\",\n                    END_BLOCK: \"TK_END_BLOCK\",\n                    WORD: \"TK_WORD\",\n                    RESERVED: \"TK_RESERVED\",\n                    SEMICOLON: \"TK_SEMICOLON\",\n                    STRING: \"TK_STRING\",\n                    EQUALS: \"TK_EQUALS\",\n                    OPERATOR: \"TK_OPERATOR\",\n                    COMMA: \"TK_COMMA\",\n                    BLOCK_COMMENT: \"TK_BLOCK_COMMENT\",\n                    COMMENT: \"TK_COMMENT\",\n                    DOT: \"TK_DOT\",\n                    UNKNOWN: \"TK_UNKNOWN\",\n                    START: BASETOKEN.START,\n                    RAW: BASETOKEN.RAW,\n                    EOF: BASETOKEN.EOF\n                };\n                var directives_core = new Directives(/\\/\\*/, /\\*\\//);\n                var number_pattern = /0[xX][0123456789abcdefABCDEF_]*n?|0[oO][01234567_]*n?|0[bB][01_]*n?|\\d[\\d_]*n|(?:\\.\\d[\\d_]*|\\d[\\d_]*\\.?[\\d_]*)(?:[eE][+-]?[\\d_]+)?/;\n                var digit = /[0-9]/;\n                // Dot \".\" must be distinguished from \"...\" and decimal\n                var dot_pattern = /[^\\d\\.]/;\n                var positionable_operators = (\">>> === !== &&= ??= ||= \" + \"<< && >= ** != == <= >> || ?? |> \" + \"< / - + > : & % ? ^ | *\").split(\" \");\n                // IMPORTANT: this must be sorted longest to shortest or tokenizing many not work.\n                // Also, you must update possitionable operators separately from punct\n                var punct = \">>>= \" + \"... >>= <<= === >>> !== **= &&= ??= ||= \" + \"=> ^= :: /= << <= == && -= >= >> != -- += ** || ?? ++ %= &= *= |= |> \" + \"= ! ? > < : / ^ - + * & % ~ |\";\n                punct = punct.replace(/[-[\\]{}()*+?.,\\\\^$|#]/g, \"\\\\$&\");\n                // ?. but not if followed by a number \n                punct = \"\\\\?\\\\.(?!\\\\d) \" + punct;\n                punct = punct.replace(/ /g, \"|\");\n                var punct_pattern = new RegExp(punct);\n                // words which should always start on new line.\n                var line_starters = \"continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export\".split(\",\");\n                var reserved_words = line_starters.concat([\n                    \"do\",\n                    \"in\",\n                    \"of\",\n                    \"else\",\n                    \"get\",\n                    \"set\",\n                    \"new\",\n                    \"catch\",\n                    \"finally\",\n                    \"typeof\",\n                    \"yield\",\n                    \"async\",\n                    \"await\",\n                    \"from\",\n                    \"as\",\n                    \"class\",\n                    \"extends\"\n                ]);\n                var reserved_word_pattern = new RegExp(\"^(?:\" + reserved_words.join(\"|\") + \")$\");\n                // var template_pattern = /(?:(?:<\\?php|<\\?=)[\\s\\S]*?\\?>)|(?:<%[\\s\\S]*?%>)/g;\n                var in_html_comment;\n                var Tokenizer = function(input_string, options) {\n                    BaseTokenizer.call(this, input_string, options);\n                    this._patterns.whitespace = this._patterns.whitespace.matching(/\\u00A0\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff/.source, /\\u2028\\u2029/.source);\n                    var pattern_reader = new Pattern(this._input);\n                    var templatable = new TemplatablePattern(this._input).read_options(this._options);\n                    this.__patterns = {\n                        template: templatable,\n                        identifier: templatable.starting_with(acorn.identifier).matching(acorn.identifierMatch),\n                        number: pattern_reader.matching(number_pattern),\n                        punct: pattern_reader.matching(punct_pattern),\n                        // comment ends just before nearest linefeed or end of file\n                        comment: pattern_reader.starting_with(/\\/\\//).until(/[\\n\\r\\u2028\\u2029]/),\n                        //  /* ... */ comment ends with nearest */ or end of file\n                        block_comment: pattern_reader.starting_with(/\\/\\*/).until_after(/\\*\\//),\n                        html_comment_start: pattern_reader.matching(/<!--/),\n                        html_comment_end: pattern_reader.matching(/-->/),\n                        include: pattern_reader.starting_with(/#include/).until_after(acorn.lineBreak),\n                        shebang: pattern_reader.starting_with(/#!/).until_after(acorn.lineBreak),\n                        xml: pattern_reader.matching(/[\\s\\S]*?<(\\/?)([-a-zA-Z:0-9_.]+|{[^}]+?}|!\\[CDATA\\[[^\\]]*?\\]\\]|)(\\s*{[^}]+?}|\\s+[-a-zA-Z:0-9_.]+|\\s+[-a-zA-Z:0-9_.]+\\s*=\\s*('[^']*'|\"[^\"]*\"|{([^{}]|{[^}]+?})+?}))*\\s*(\\/?)\\s*>/),\n                        single_quote: templatable.until(/['\\\\\\n\\r\\u2028\\u2029]/),\n                        double_quote: templatable.until(/[\"\\\\\\n\\r\\u2028\\u2029]/),\n                        template_text: templatable.until(/[`\\\\$]/),\n                        template_expression: templatable.until(/[`}\\\\]/)\n                    };\n                };\n                Tokenizer.prototype = new BaseTokenizer();\n                Tokenizer.prototype._is_comment = function(current_token) {\n                    return current_token.type === TOKEN.COMMENT || current_token.type === TOKEN.BLOCK_COMMENT || current_token.type === TOKEN.UNKNOWN;\n                };\n                Tokenizer.prototype._is_opening = function(current_token) {\n                    return current_token.type === TOKEN.START_BLOCK || current_token.type === TOKEN.START_EXPR;\n                };\n                Tokenizer.prototype._is_closing = function(current_token, open_token) {\n                    return (current_token.type === TOKEN.END_BLOCK || current_token.type === TOKEN.END_EXPR) && open_token && (current_token.text === \"]\" && open_token.text === \"[\" || current_token.text === \")\" && open_token.text === \"(\" || current_token.text === \"}\" && open_token.text === \"{\");\n                };\n                Tokenizer.prototype._reset = function() {\n                    in_html_comment = false;\n                };\n                Tokenizer.prototype._get_next_token = function(previous_token, open_token) {\n                    var token = null;\n                    this._readWhitespace();\n                    var c = this._input.peek();\n                    if (c === null) {\n                        return this._create_token(TOKEN.EOF, \"\");\n                    }\n                    token = token || this._read_non_javascript(c);\n                    token = token || this._read_string(c);\n                    token = token || this._read_pair(c, this._input.peek(1)); // Issue #2062 hack for record type '#{'\n                    token = token || this._read_word(previous_token);\n                    token = token || this._read_singles(c);\n                    token = token || this._read_comment(c);\n                    token = token || this._read_regexp(c, previous_token);\n                    token = token || this._read_xml(c, previous_token);\n                    token = token || this._read_punctuation();\n                    token = token || this._create_token(TOKEN.UNKNOWN, this._input.next());\n                    return token;\n                };\n                Tokenizer.prototype._read_word = function(previous_token) {\n                    var resulting_string;\n                    resulting_string = this.__patterns.identifier.read();\n                    if (resulting_string !== \"\") {\n                        resulting_string = resulting_string.replace(acorn.allLineBreaks, \"\\n\");\n                        if (!(previous_token.type === TOKEN.DOT || previous_token.type === TOKEN.RESERVED && (previous_token.text === \"set\" || previous_token.text === \"get\")) && reserved_word_pattern.test(resulting_string)) {\n                            if ((resulting_string === \"in\" || resulting_string === \"of\") && (previous_token.type === TOKEN.WORD || previous_token.type === TOKEN.STRING)) {\n                                return this._create_token(TOKEN.OPERATOR, resulting_string);\n                            }\n                            return this._create_token(TOKEN.RESERVED, resulting_string);\n                        }\n                        return this._create_token(TOKEN.WORD, resulting_string);\n                    }\n                    resulting_string = this.__patterns.number.read();\n                    if (resulting_string !== \"\") {\n                        return this._create_token(TOKEN.WORD, resulting_string);\n                    }\n                };\n                Tokenizer.prototype._read_singles = function(c) {\n                    var token = null;\n                    if (c === \"(\" || c === \"[\") {\n                        token = this._create_token(TOKEN.START_EXPR, c);\n                    } else if (c === \")\" || c === \"]\") {\n                        token = this._create_token(TOKEN.END_EXPR, c);\n                    } else if (c === \"{\") {\n                        token = this._create_token(TOKEN.START_BLOCK, c);\n                    } else if (c === \"}\") {\n                        token = this._create_token(TOKEN.END_BLOCK, c);\n                    } else if (c === \";\") {\n                        token = this._create_token(TOKEN.SEMICOLON, c);\n                    } else if (c === \".\" && dot_pattern.test(this._input.peek(1))) {\n                        token = this._create_token(TOKEN.DOT, c);\n                    } else if (c === \",\") {\n                        token = this._create_token(TOKEN.COMMA, c);\n                    }\n                    if (token) {\n                        this._input.next();\n                    }\n                    return token;\n                };\n                Tokenizer.prototype._read_pair = function(c, d) {\n                    var token = null;\n                    if (c === \"#\" && d === \"{\") {\n                        token = this._create_token(TOKEN.START_BLOCK, c + d);\n                    }\n                    if (token) {\n                        this._input.next();\n                        this._input.next();\n                    }\n                    return token;\n                };\n                Tokenizer.prototype._read_punctuation = function() {\n                    var resulting_string = this.__patterns.punct.read();\n                    if (resulting_string !== \"\") {\n                        if (resulting_string === \"=\") {\n                            return this._create_token(TOKEN.EQUALS, resulting_string);\n                        } else if (resulting_string === \"?.\") {\n                            return this._create_token(TOKEN.DOT, resulting_string);\n                        } else {\n                            return this._create_token(TOKEN.OPERATOR, resulting_string);\n                        }\n                    }\n                };\n                Tokenizer.prototype._read_non_javascript = function(c) {\n                    var resulting_string = \"\";\n                    if (c === \"#\") {\n                        if (this._is_first_token()) {\n                            resulting_string = this.__patterns.shebang.read();\n                            if (resulting_string) {\n                                return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + \"\\n\");\n                            }\n                        }\n                        // handles extendscript #includes\n                        resulting_string = this.__patterns.include.read();\n                        if (resulting_string) {\n                            return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + \"\\n\");\n                        }\n                        c = this._input.next();\n                        // Spidermonkey-specific sharp variables for circular references. Considered obsolete.\n                        var sharp = \"#\";\n                        if (this._input.hasNext() && this._input.testChar(digit)) {\n                            do {\n                                c = this._input.next();\n                                sharp += c;\n                            }while (this._input.hasNext() && c !== \"#\" && c !== \"=\");\n                            if (c === \"#\") {\n                            //\n                            } else if (this._input.peek() === \"[\" && this._input.peek(1) === \"]\") {\n                                sharp += \"[]\";\n                                this._input.next();\n                                this._input.next();\n                            } else if (this._input.peek() === \"{\" && this._input.peek(1) === \"}\") {\n                                sharp += \"{}\";\n                                this._input.next();\n                                this._input.next();\n                            }\n                            return this._create_token(TOKEN.WORD, sharp);\n                        }\n                        this._input.back();\n                    } else if (c === \"<\" && this._is_first_token()) {\n                        resulting_string = this.__patterns.html_comment_start.read();\n                        if (resulting_string) {\n                            while(this._input.hasNext() && !this._input.testChar(acorn.newline)){\n                                resulting_string += this._input.next();\n                            }\n                            in_html_comment = true;\n                            return this._create_token(TOKEN.COMMENT, resulting_string);\n                        }\n                    } else if (in_html_comment && c === \"-\") {\n                        resulting_string = this.__patterns.html_comment_end.read();\n                        if (resulting_string) {\n                            in_html_comment = false;\n                            return this._create_token(TOKEN.COMMENT, resulting_string);\n                        }\n                    }\n                    return null;\n                };\n                Tokenizer.prototype._read_comment = function(c) {\n                    var token = null;\n                    if (c === \"/\") {\n                        var comment = \"\";\n                        if (this._input.peek(1) === \"*\") {\n                            // peek for comment /* ... */\n                            comment = this.__patterns.block_comment.read();\n                            var directives = directives_core.get_directives(comment);\n                            if (directives && directives.ignore === \"start\") {\n                                comment += directives_core.readIgnored(this._input);\n                            }\n                            comment = comment.replace(acorn.allLineBreaks, \"\\n\");\n                            token = this._create_token(TOKEN.BLOCK_COMMENT, comment);\n                            token.directives = directives;\n                        } else if (this._input.peek(1) === \"/\") {\n                            // peek for comment // ...\n                            comment = this.__patterns.comment.read();\n                            token = this._create_token(TOKEN.COMMENT, comment);\n                        }\n                    }\n                    return token;\n                };\n                Tokenizer.prototype._read_string = function(c) {\n                    if (c === \"`\" || c === \"'\" || c === '\"') {\n                        var resulting_string = this._input.next();\n                        this.has_char_escapes = false;\n                        if (c === \"`\") {\n                            resulting_string += this._read_string_recursive(\"`\", true, \"${\");\n                        } else {\n                            resulting_string += this._read_string_recursive(c);\n                        }\n                        if (this.has_char_escapes && this._options.unescape_strings) {\n                            resulting_string = unescape_string(resulting_string);\n                        }\n                        if (this._input.peek() === c) {\n                            resulting_string += this._input.next();\n                        }\n                        resulting_string = resulting_string.replace(acorn.allLineBreaks, \"\\n\");\n                        return this._create_token(TOKEN.STRING, resulting_string);\n                    }\n                    return null;\n                };\n                Tokenizer.prototype._allow_regexp_or_xml = function(previous_token) {\n                    // regex and xml can only appear in specific locations during parsing\n                    return previous_token.type === TOKEN.RESERVED && in_array(previous_token.text, [\n                        \"return\",\n                        \"case\",\n                        \"throw\",\n                        \"else\",\n                        \"do\",\n                        \"typeof\",\n                        \"yield\"\n                    ]) || previous_token.type === TOKEN.END_EXPR && previous_token.text === \")\" && previous_token.opened.previous.type === TOKEN.RESERVED && in_array(previous_token.opened.previous.text, [\n                        \"if\",\n                        \"while\",\n                        \"for\"\n                    ]) || in_array(previous_token.type, [\n                        TOKEN.COMMENT,\n                        TOKEN.START_EXPR,\n                        TOKEN.START_BLOCK,\n                        TOKEN.START,\n                        TOKEN.END_BLOCK,\n                        TOKEN.OPERATOR,\n                        TOKEN.EQUALS,\n                        TOKEN.EOF,\n                        TOKEN.SEMICOLON,\n                        TOKEN.COMMA\n                    ]);\n                };\n                Tokenizer.prototype._read_regexp = function(c, previous_token) {\n                    if (c === \"/\" && this._allow_regexp_or_xml(previous_token)) {\n                        // handle regexp\n                        //\n                        var resulting_string = this._input.next();\n                        var esc = false;\n                        var in_char_class = false;\n                        while(this._input.hasNext() && (esc || in_char_class || this._input.peek() !== c) && !this._input.testChar(acorn.newline)){\n                            resulting_string += this._input.peek();\n                            if (!esc) {\n                                esc = this._input.peek() === \"\\\\\";\n                                if (this._input.peek() === \"[\") {\n                                    in_char_class = true;\n                                } else if (this._input.peek() === \"]\") {\n                                    in_char_class = false;\n                                }\n                            } else {\n                                esc = false;\n                            }\n                            this._input.next();\n                        }\n                        if (this._input.peek() === c) {\n                            resulting_string += this._input.next();\n                            // regexps may have modifiers /regexp/MOD , so fetch those, too\n                            // Only [gim] are valid, but if the user puts in garbage, do what we can to take it.\n                            resulting_string += this._input.read(acorn.identifier);\n                        }\n                        return this._create_token(TOKEN.STRING, resulting_string);\n                    }\n                    return null;\n                };\n                Tokenizer.prototype._read_xml = function(c, previous_token) {\n                    if (this._options.e4x && c === \"<\" && this._allow_regexp_or_xml(previous_token)) {\n                        var xmlStr = \"\";\n                        var match = this.__patterns.xml.read_match();\n                        // handle e4x xml literals\n                        //\n                        if (match) {\n                            // Trim root tag to attempt to\n                            var rootTag = match[2].replace(/^{\\s+/, \"{\").replace(/\\s+}$/, \"}\");\n                            var isCurlyRoot = rootTag.indexOf(\"{\") === 0;\n                            var depth = 0;\n                            while(match){\n                                var isEndTag = !!match[1];\n                                var tagName = match[2];\n                                var isSingletonTag = !!match[match.length - 1] || tagName.slice(0, 8) === \"![CDATA[\";\n                                if (!isSingletonTag && (tagName === rootTag || isCurlyRoot && tagName.replace(/^{\\s+/, \"{\").replace(/\\s+}$/, \"}\"))) {\n                                    if (isEndTag) {\n                                        --depth;\n                                    } else {\n                                        ++depth;\n                                    }\n                                }\n                                xmlStr += match[0];\n                                if (depth <= 0) {\n                                    break;\n                                }\n                                match = this.__patterns.xml.read_match();\n                            }\n                            // if we didn't close correctly, keep unformatted.\n                            if (!match) {\n                                xmlStr += this._input.match(/[\\s\\S]*/g)[0];\n                            }\n                            xmlStr = xmlStr.replace(acorn.allLineBreaks, \"\\n\");\n                            return this._create_token(TOKEN.STRING, xmlStr);\n                        }\n                    }\n                    return null;\n                };\n                function unescape_string(s) {\n                    // You think that a regex would work for this\n                    // return s.replace(/\\\\x([0-9a-f]{2})/gi, function(match, val) {\n                    //         return String.fromCharCode(parseInt(val, 16));\n                    //     })\n                    // However, dealing with '\\xff', '\\\\xff', '\\\\\\xff' makes this more fun.\n                    var out = \"\", escaped = 0;\n                    var input_scan = new InputScanner(s);\n                    var matched = null;\n                    while(input_scan.hasNext()){\n                        // Keep any whitespace, non-slash characters\n                        // also keep slash pairs.\n                        matched = input_scan.match(/([\\s]|[^\\\\]|\\\\\\\\)+/g);\n                        if (matched) {\n                            out += matched[0];\n                        }\n                        if (input_scan.peek() === \"\\\\\") {\n                            input_scan.next();\n                            if (input_scan.peek() === \"x\") {\n                                matched = input_scan.match(/x([0-9A-Fa-f]{2})/g);\n                            } else if (input_scan.peek() === \"u\") {\n                                matched = input_scan.match(/u([0-9A-Fa-f]{4})/g);\n                                if (!matched) {\n                                    matched = input_scan.match(/u\\{([0-9A-Fa-f]+)\\}/g);\n                                }\n                            } else {\n                                out += \"\\\\\";\n                                if (input_scan.hasNext()) {\n                                    out += input_scan.next();\n                                }\n                                continue;\n                            }\n                            // If there's some error decoding, return the original string\n                            if (!matched) {\n                                return s;\n                            }\n                            escaped = parseInt(matched[1], 16);\n                            if (escaped > 0x7e && escaped <= 0xff && matched[0].indexOf(\"x\") === 0) {\n                                // we bail out on \\x7f..\\xff,\n                                // leaving whole string escaped,\n                                // as it's probably completely binary\n                                return s;\n                            } else if (escaped >= 0x00 && escaped < 0x20) {\n                                // leave 0x00...0x1f escaped\n                                out += \"\\\\\" + matched[0];\n                            } else if (escaped > 0x10FFFF) {\n                                // If the escape sequence is out of bounds, keep the original sequence and continue conversion\n                                out += \"\\\\\" + matched[0];\n                            } else if (escaped === 0x22 || escaped === 0x27 || escaped === 0x5c) {\n                                // single-quote, apostrophe, backslash - escape these\n                                out += \"\\\\\" + String.fromCharCode(escaped);\n                            } else {\n                                out += String.fromCharCode(escaped);\n                            }\n                        }\n                    }\n                    return out;\n                }\n                // handle string\n                //\n                Tokenizer.prototype._read_string_recursive = function(delimiter, allow_unescaped_newlines, start_sub) {\n                    var current_char;\n                    var pattern;\n                    if (delimiter === \"'\") {\n                        pattern = this.__patterns.single_quote;\n                    } else if (delimiter === '\"') {\n                        pattern = this.__patterns.double_quote;\n                    } else if (delimiter === \"`\") {\n                        pattern = this.__patterns.template_text;\n                    } else if (delimiter === \"}\") {\n                        pattern = this.__patterns.template_expression;\n                    }\n                    var resulting_string = pattern.read();\n                    var next = \"\";\n                    while(this._input.hasNext()){\n                        next = this._input.next();\n                        if (next === delimiter || !allow_unescaped_newlines && acorn.newline.test(next)) {\n                            this._input.back();\n                            break;\n                        } else if (next === \"\\\\\" && this._input.hasNext()) {\n                            current_char = this._input.peek();\n                            if (current_char === \"x\" || current_char === \"u\") {\n                                this.has_char_escapes = true;\n                            } else if (current_char === \"\\r\" && this._input.peek(1) === \"\\n\") {\n                                this._input.next();\n                            }\n                            next += this._input.next();\n                        } else if (start_sub) {\n                            if (start_sub === \"${\" && next === \"$\" && this._input.peek() === \"{\") {\n                                next += this._input.next();\n                            }\n                            if (start_sub === next) {\n                                if (delimiter === \"`\") {\n                                    next += this._read_string_recursive(\"}\", allow_unescaped_newlines, \"`\");\n                                } else {\n                                    next += this._read_string_recursive(\"`\", allow_unescaped_newlines, \"${\");\n                                }\n                                if (this._input.hasNext()) {\n                                    next += this._input.next();\n                                }\n                            }\n                        }\n                        next += pattern.read();\n                        resulting_string += next;\n                    }\n                    return resulting_string;\n                };\n                module.exports.Tokenizer = Tokenizer;\n                module.exports.TOKEN = TOKEN;\n                module.exports.positionable_operators = positionable_operators.slice();\n                module.exports.line_starters = line_starters.slice();\n            /***/ },\n            /* 8 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var regexp_has_sticky = RegExp.prototype.hasOwnProperty(\"sticky\");\n                function InputScanner(input_string) {\n                    this.__input = input_string || \"\";\n                    this.__input_length = this.__input.length;\n                    this.__position = 0;\n                }\n                InputScanner.prototype.restart = function() {\n                    this.__position = 0;\n                };\n                InputScanner.prototype.back = function() {\n                    if (this.__position > 0) {\n                        this.__position -= 1;\n                    }\n                };\n                InputScanner.prototype.hasNext = function() {\n                    return this.__position < this.__input_length;\n                };\n                InputScanner.prototype.next = function() {\n                    var val = null;\n                    if (this.hasNext()) {\n                        val = this.__input.charAt(this.__position);\n                        this.__position += 1;\n                    }\n                    return val;\n                };\n                InputScanner.prototype.peek = function(index) {\n                    var val = null;\n                    index = index || 0;\n                    index += this.__position;\n                    if (index >= 0 && index < this.__input_length) {\n                        val = this.__input.charAt(index);\n                    }\n                    return val;\n                };\n                // This is a JavaScript only helper function (not in python)\n                // Javascript doesn't have a match method\n                // and not all implementation support \"sticky\" flag.\n                // If they do not support sticky then both this.match() and this.test() method\n                // must get the match and check the index of the match.\n                // If sticky is supported and set, this method will use it.\n                // Otherwise it will check that global is set, and fall back to the slower method.\n                InputScanner.prototype.__match = function(pattern, index) {\n                    pattern.lastIndex = index;\n                    var pattern_match = pattern.exec(this.__input);\n                    if (pattern_match && !(regexp_has_sticky && pattern.sticky)) {\n                        if (pattern_match.index !== index) {\n                            pattern_match = null;\n                        }\n                    }\n                    return pattern_match;\n                };\n                InputScanner.prototype.test = function(pattern, index) {\n                    index = index || 0;\n                    index += this.__position;\n                    if (index >= 0 && index < this.__input_length) {\n                        return !!this.__match(pattern, index);\n                    } else {\n                        return false;\n                    }\n                };\n                InputScanner.prototype.testChar = function(pattern, index) {\n                    // test one character regex match\n                    var val = this.peek(index);\n                    pattern.lastIndex = 0;\n                    return val !== null && pattern.test(val);\n                };\n                InputScanner.prototype.match = function(pattern) {\n                    var pattern_match = this.__match(pattern, this.__position);\n                    if (pattern_match) {\n                        this.__position += pattern_match[0].length;\n                    } else {\n                        pattern_match = null;\n                    }\n                    return pattern_match;\n                };\n                InputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {\n                    var val = \"\";\n                    var match;\n                    if (starting_pattern) {\n                        match = this.match(starting_pattern);\n                        if (match) {\n                            val += match[0];\n                        }\n                    }\n                    if (until_pattern && (match || !starting_pattern)) {\n                        val += this.readUntil(until_pattern, until_after);\n                    }\n                    return val;\n                };\n                InputScanner.prototype.readUntil = function(pattern, until_after) {\n                    var val = \"\";\n                    var match_index = this.__position;\n                    pattern.lastIndex = this.__position;\n                    var pattern_match = pattern.exec(this.__input);\n                    if (pattern_match) {\n                        match_index = pattern_match.index;\n                        if (until_after) {\n                            match_index += pattern_match[0].length;\n                        }\n                    } else {\n                        match_index = this.__input_length;\n                    }\n                    val = this.__input.substring(this.__position, match_index);\n                    this.__position = match_index;\n                    return val;\n                };\n                InputScanner.prototype.readUntilAfter = function(pattern) {\n                    return this.readUntil(pattern, true);\n                };\n                InputScanner.prototype.get_regexp = function(pattern, match_from) {\n                    var result = null;\n                    var flags = \"g\";\n                    if (match_from && regexp_has_sticky) {\n                        flags = \"y\";\n                    }\n                    // strings are converted to regexp\n                    if (typeof pattern === \"string\" && pattern !== \"\") {\n                        // result = new RegExp(pattern.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'), flags);\n                        result = new RegExp(pattern, flags);\n                    } else if (pattern) {\n                        result = new RegExp(pattern.source, flags);\n                    }\n                    return result;\n                };\n                InputScanner.prototype.get_literal_regexp = function(literal_string) {\n                    return RegExp(literal_string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\"));\n                };\n                /* css beautifier legacy helpers */ InputScanner.prototype.peekUntilAfter = function(pattern) {\n                    var start = this.__position;\n                    var val = this.readUntilAfter(pattern);\n                    this.__position = start;\n                    return val;\n                };\n                InputScanner.prototype.lookBack = function(testVal) {\n                    var start = this.__position - 1;\n                    return start >= testVal.length && this.__input.substring(start - testVal.length, start).toLowerCase() === testVal;\n                };\n                module.exports.InputScanner = InputScanner;\n            /***/ },\n            /* 9 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_175279__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var InputScanner = __nested_webpack_require_175279__(8).InputScanner;\n                var Token = __nested_webpack_require_175279__(3).Token;\n                var TokenStream = __nested_webpack_require_175279__(10).TokenStream;\n                var WhitespacePattern = __nested_webpack_require_175279__(11).WhitespacePattern;\n                var TOKEN = {\n                    START: \"TK_START\",\n                    RAW: \"TK_RAW\",\n                    EOF: \"TK_EOF\"\n                };\n                var Tokenizer = function(input_string, options) {\n                    this._input = new InputScanner(input_string);\n                    this._options = options || {};\n                    this.__tokens = null;\n                    this._patterns = {};\n                    this._patterns.whitespace = new WhitespacePattern(this._input);\n                };\n                Tokenizer.prototype.tokenize = function() {\n                    this._input.restart();\n                    this.__tokens = new TokenStream();\n                    this._reset();\n                    var current;\n                    var previous = new Token(TOKEN.START, \"\");\n                    var open_token = null;\n                    var open_stack = [];\n                    var comments = new TokenStream();\n                    while(previous.type !== TOKEN.EOF){\n                        current = this._get_next_token(previous, open_token);\n                        while(this._is_comment(current)){\n                            comments.add(current);\n                            current = this._get_next_token(previous, open_token);\n                        }\n                        if (!comments.isEmpty()) {\n                            current.comments_before = comments;\n                            comments = new TokenStream();\n                        }\n                        current.parent = open_token;\n                        if (this._is_opening(current)) {\n                            open_stack.push(open_token);\n                            open_token = current;\n                        } else if (open_token && this._is_closing(current, open_token)) {\n                            current.opened = open_token;\n                            open_token.closed = current;\n                            open_token = open_stack.pop();\n                            current.parent = open_token;\n                        }\n                        current.previous = previous;\n                        previous.next = current;\n                        this.__tokens.add(current);\n                        previous = current;\n                    }\n                    return this.__tokens;\n                };\n                Tokenizer.prototype._is_first_token = function() {\n                    return this.__tokens.isEmpty();\n                };\n                Tokenizer.prototype._reset = function() {};\n                Tokenizer.prototype._get_next_token = function(previous_token, open_token) {\n                    this._readWhitespace();\n                    var resulting_string = this._input.read(/.+/g);\n                    if (resulting_string) {\n                        return this._create_token(TOKEN.RAW, resulting_string);\n                    } else {\n                        return this._create_token(TOKEN.EOF, \"\");\n                    }\n                };\n                Tokenizer.prototype._is_comment = function(current_token) {\n                    return false;\n                };\n                Tokenizer.prototype._is_opening = function(current_token) {\n                    return false;\n                };\n                Tokenizer.prototype._is_closing = function(current_token, open_token) {\n                    return false;\n                };\n                Tokenizer.prototype._create_token = function(type, text) {\n                    var token = new Token(type, text, this._patterns.whitespace.newline_count, this._patterns.whitespace.whitespace_before_token);\n                    return token;\n                };\n                Tokenizer.prototype._readWhitespace = function() {\n                    return this._patterns.whitespace.read();\n                };\n                module.exports.Tokenizer = Tokenizer;\n                module.exports.TOKEN = TOKEN;\n            /***/ },\n            /* 10 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function TokenStream(parent_token) {\n                    // private\n                    this.__tokens = [];\n                    this.__tokens_length = this.__tokens.length;\n                    this.__position = 0;\n                    this.__parent_token = parent_token;\n                }\n                TokenStream.prototype.restart = function() {\n                    this.__position = 0;\n                };\n                TokenStream.prototype.isEmpty = function() {\n                    return this.__tokens_length === 0;\n                };\n                TokenStream.prototype.hasNext = function() {\n                    return this.__position < this.__tokens_length;\n                };\n                TokenStream.prototype.next = function() {\n                    var val = null;\n                    if (this.hasNext()) {\n                        val = this.__tokens[this.__position];\n                        this.__position += 1;\n                    }\n                    return val;\n                };\n                TokenStream.prototype.peek = function(index) {\n                    var val = null;\n                    index = index || 0;\n                    index += this.__position;\n                    if (index >= 0 && index < this.__tokens_length) {\n                        val = this.__tokens[index];\n                    }\n                    return val;\n                };\n                TokenStream.prototype.add = function(token) {\n                    if (this.__parent_token) {\n                        token.parent = this.__parent_token;\n                    }\n                    this.__tokens.push(token);\n                    this.__tokens_length += 1;\n                };\n                module.exports.TokenStream = TokenStream;\n            /***/ },\n            /* 11 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_183813__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var Pattern = __nested_webpack_require_183813__(12).Pattern;\n                function WhitespacePattern(input_scanner, parent) {\n                    Pattern.call(this, input_scanner, parent);\n                    if (parent) {\n                        this._line_regexp = this._input.get_regexp(parent._line_regexp);\n                    } else {\n                        this.__set_whitespace_patterns(\"\", \"\");\n                    }\n                    this.newline_count = 0;\n                    this.whitespace_before_token = \"\";\n                }\n                WhitespacePattern.prototype = new Pattern();\n                WhitespacePattern.prototype.__set_whitespace_patterns = function(whitespace_chars, newline_chars) {\n                    whitespace_chars += \"\\\\t \";\n                    newline_chars += \"\\\\n\\\\r\";\n                    this._match_pattern = this._input.get_regexp(\"[\" + whitespace_chars + newline_chars + \"]+\", true);\n                    this._newline_regexp = this._input.get_regexp(\"\\\\r\\\\n|[\" + newline_chars + \"]\");\n                };\n                WhitespacePattern.prototype.read = function() {\n                    this.newline_count = 0;\n                    this.whitespace_before_token = \"\";\n                    var resulting_string = this._input.read(this._match_pattern);\n                    if (resulting_string === \" \") {\n                        this.whitespace_before_token = \" \";\n                    } else if (resulting_string) {\n                        var matches = this.__split(this._newline_regexp, resulting_string);\n                        this.newline_count = matches.length - 1;\n                        this.whitespace_before_token = matches[this.newline_count];\n                    }\n                    return resulting_string;\n                };\n                WhitespacePattern.prototype.matching = function(whitespace_chars, newline_chars) {\n                    var result = this._create();\n                    result.__set_whitespace_patterns(whitespace_chars, newline_chars);\n                    result._update();\n                    return result;\n                };\n                WhitespacePattern.prototype._create = function() {\n                    return new WhitespacePattern(this._input, this);\n                };\n                WhitespacePattern.prototype.__split = function(regexp, input_string) {\n                    regexp.lastIndex = 0;\n                    var start_index = 0;\n                    var result = [];\n                    var next_match = regexp.exec(input_string);\n                    while(next_match){\n                        result.push(input_string.substring(start_index, next_match.index));\n                        start_index = next_match.index + next_match[0].length;\n                        next_match = regexp.exec(input_string);\n                    }\n                    if (start_index < input_string.length) {\n                        result.push(input_string.substring(start_index, input_string.length));\n                    } else {\n                        result.push(\"\");\n                    }\n                    return result;\n                };\n                module.exports.WhitespacePattern = WhitespacePattern;\n            /***/ },\n            /* 12 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function Pattern(input_scanner, parent) {\n                    this._input = input_scanner;\n                    this._starting_pattern = null;\n                    this._match_pattern = null;\n                    this._until_pattern = null;\n                    this._until_after = false;\n                    if (parent) {\n                        this._starting_pattern = this._input.get_regexp(parent._starting_pattern, true);\n                        this._match_pattern = this._input.get_regexp(parent._match_pattern, true);\n                        this._until_pattern = this._input.get_regexp(parent._until_pattern);\n                        this._until_after = parent._until_after;\n                    }\n                }\n                Pattern.prototype.read = function() {\n                    var result = this._input.read(this._starting_pattern);\n                    if (!this._starting_pattern || result) {\n                        result += this._input.read(this._match_pattern, this._until_pattern, this._until_after);\n                    }\n                    return result;\n                };\n                Pattern.prototype.read_match = function() {\n                    return this._input.match(this._match_pattern);\n                };\n                Pattern.prototype.until_after = function(pattern) {\n                    var result = this._create();\n                    result._until_after = true;\n                    result._until_pattern = this._input.get_regexp(pattern);\n                    result._update();\n                    return result;\n                };\n                Pattern.prototype.until = function(pattern) {\n                    var result = this._create();\n                    result._until_after = false;\n                    result._until_pattern = this._input.get_regexp(pattern);\n                    result._update();\n                    return result;\n                };\n                Pattern.prototype.starting_with = function(pattern) {\n                    var result = this._create();\n                    result._starting_pattern = this._input.get_regexp(pattern, true);\n                    result._update();\n                    return result;\n                };\n                Pattern.prototype.matching = function(pattern) {\n                    var result = this._create();\n                    result._match_pattern = this._input.get_regexp(pattern, true);\n                    result._update();\n                    return result;\n                };\n                Pattern.prototype._create = function() {\n                    return new Pattern(this._input, this);\n                };\n                Pattern.prototype._update = function() {};\n                module.exports.Pattern = Pattern;\n            /***/ },\n            /* 13 */ /***/ function(module) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ function Directives(start_block_pattern, end_block_pattern) {\n                    start_block_pattern = typeof start_block_pattern === \"string\" ? start_block_pattern : start_block_pattern.source;\n                    end_block_pattern = typeof end_block_pattern === \"string\" ? end_block_pattern : end_block_pattern.source;\n                    this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \\w+[:]\\w+)+ /.source + end_block_pattern, \"g\");\n                    this.__directive_pattern = / (\\w+)[:](\\w+)/g;\n                    this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\\sbeautify\\signore:end\\s/.source + end_block_pattern, \"g\");\n                }\n                Directives.prototype.get_directives = function(text) {\n                    if (!text.match(this.__directives_block_pattern)) {\n                        return null;\n                    }\n                    var directives = {};\n                    this.__directive_pattern.lastIndex = 0;\n                    var directive_match = this.__directive_pattern.exec(text);\n                    while(directive_match){\n                        directives[directive_match[1]] = directive_match[2];\n                        directive_match = this.__directive_pattern.exec(text);\n                    }\n                    return directives;\n                };\n                Directives.prototype.readIgnored = function(input) {\n                    return input.readUntilAfter(this.__directives_end_ignore_pattern);\n                };\n                module.exports.Directives = Directives;\n            /***/ },\n            /* 14 */ /***/ function(module, __unused_webpack_exports, __nested_webpack_require_195205__) {\n                /*jshint node:true */ /*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n*/ var Pattern = __nested_webpack_require_195205__(12).Pattern;\n                var template_names = {\n                    django: false,\n                    erb: false,\n                    handlebars: false,\n                    php: false,\n                    smarty: false\n                };\n                // This lets templates appear anywhere we would do a readUntil\n                // The cost is higher but it is pay to play.\n                function TemplatablePattern(input_scanner, parent) {\n                    Pattern.call(this, input_scanner, parent);\n                    this.__template_pattern = null;\n                    this._disabled = Object.assign({}, template_names);\n                    this._excluded = Object.assign({}, template_names);\n                    if (parent) {\n                        this.__template_pattern = this._input.get_regexp(parent.__template_pattern);\n                        this._excluded = Object.assign(this._excluded, parent._excluded);\n                        this._disabled = Object.assign(this._disabled, parent._disabled);\n                    }\n                    var pattern = new Pattern(input_scanner);\n                    this.__patterns = {\n                        handlebars_comment: pattern.starting_with(/{{!--/).until_after(/--}}/),\n                        handlebars_unescaped: pattern.starting_with(/{{{/).until_after(/}}}/),\n                        handlebars: pattern.starting_with(/{{/).until_after(/}}/),\n                        php: pattern.starting_with(/<\\?(?:[= ]|php)/).until_after(/\\?>/),\n                        erb: pattern.starting_with(/<%[^%]/).until_after(/[^%]%>/),\n                        // django coflicts with handlebars a bit.\n                        django: pattern.starting_with(/{%/).until_after(/%}/),\n                        django_value: pattern.starting_with(/{{/).until_after(/}}/),\n                        django_comment: pattern.starting_with(/{#/).until_after(/#}/),\n                        smarty: pattern.starting_with(/{(?=[^}{\\s\\n])/).until_after(/[^\\s\\n]}/),\n                        smarty_comment: pattern.starting_with(/{\\*/).until_after(/\\*}/),\n                        smarty_literal: pattern.starting_with(/{literal}/).until_after(/{\\/literal}/)\n                    };\n                }\n                TemplatablePattern.prototype = new Pattern();\n                TemplatablePattern.prototype._create = function() {\n                    return new TemplatablePattern(this._input, this);\n                };\n                TemplatablePattern.prototype._update = function() {\n                    this.__set_templated_pattern();\n                };\n                TemplatablePattern.prototype.disable = function(language) {\n                    var result = this._create();\n                    result._disabled[language] = true;\n                    result._update();\n                    return result;\n                };\n                TemplatablePattern.prototype.read_options = function(options) {\n                    var result = this._create();\n                    for(var language in template_names){\n                        result._disabled[language] = options.templating.indexOf(language) === -1;\n                    }\n                    result._update();\n                    return result;\n                };\n                TemplatablePattern.prototype.exclude = function(language) {\n                    var result = this._create();\n                    result._excluded[language] = true;\n                    result._update();\n                    return result;\n                };\n                TemplatablePattern.prototype.read = function() {\n                    var result = \"\";\n                    if (this._match_pattern) {\n                        result = this._input.read(this._starting_pattern);\n                    } else {\n                        result = this._input.read(this._starting_pattern, this.__template_pattern);\n                    }\n                    var next = this._read_template();\n                    while(next){\n                        if (this._match_pattern) {\n                            next += this._input.read(this._match_pattern);\n                        } else {\n                            next += this._input.readUntil(this.__template_pattern);\n                        }\n                        result += next;\n                        next = this._read_template();\n                    }\n                    if (this._until_after) {\n                        result += this._input.readUntilAfter(this._until_pattern);\n                    }\n                    return result;\n                };\n                TemplatablePattern.prototype.__set_templated_pattern = function() {\n                    var items = [];\n                    if (!this._disabled.php) {\n                        items.push(this.__patterns.php._starting_pattern.source);\n                    }\n                    if (!this._disabled.handlebars) {\n                        items.push(this.__patterns.handlebars._starting_pattern.source);\n                    }\n                    if (!this._disabled.erb) {\n                        items.push(this.__patterns.erb._starting_pattern.source);\n                    }\n                    if (!this._disabled.django) {\n                        items.push(this.__patterns.django._starting_pattern.source);\n                        // The starting pattern for django is more complex because it has different\n                        // patterns for value, comment, and other sections\n                        items.push(this.__patterns.django_value._starting_pattern.source);\n                        items.push(this.__patterns.django_comment._starting_pattern.source);\n                    }\n                    if (!this._disabled.smarty) {\n                        items.push(this.__patterns.smarty._starting_pattern.source);\n                    }\n                    if (this._until_pattern) {\n                        items.push(this._until_pattern.source);\n                    }\n                    this.__template_pattern = this._input.get_regexp(\"(?:\" + items.join(\"|\") + \")\");\n                };\n                TemplatablePattern.prototype._read_template = function() {\n                    var resulting_string = \"\";\n                    var c = this._input.peek();\n                    if (c === \"<\") {\n                        var peek1 = this._input.peek(1);\n                        //if we're in a comment, do something special\n                        // We treat all comments as literals, even more than preformatted tags\n                        // we just look for the appropriate close tag\n                        if (!this._disabled.php && !this._excluded.php && peek1 === \"?\") {\n                            resulting_string = resulting_string || this.__patterns.php.read();\n                        }\n                        if (!this._disabled.erb && !this._excluded.erb && peek1 === \"%\") {\n                            resulting_string = resulting_string || this.__patterns.erb.read();\n                        }\n                    } else if (c === \"{\") {\n                        if (!this._disabled.handlebars && !this._excluded.handlebars) {\n                            resulting_string = resulting_string || this.__patterns.handlebars_comment.read();\n                            resulting_string = resulting_string || this.__patterns.handlebars_unescaped.read();\n                            resulting_string = resulting_string || this.__patterns.handlebars.read();\n                        }\n                        if (!this._disabled.django) {\n                            // django coflicts with handlebars a bit.\n                            if (!this._excluded.django && !this._excluded.handlebars) {\n                                resulting_string = resulting_string || this.__patterns.django_value.read();\n                            }\n                            if (!this._excluded.django) {\n                                resulting_string = resulting_string || this.__patterns.django_comment.read();\n                                resulting_string = resulting_string || this.__patterns.django.read();\n                            }\n                        }\n                        if (!this._disabled.smarty) {\n                            // smarty cannot be enabled with django or handlebars enabled\n                            if (this._disabled.django && this._disabled.handlebars) {\n                                resulting_string = resulting_string || this.__patterns.smarty_comment.read();\n                                resulting_string = resulting_string || this.__patterns.smarty_literal.read();\n                                resulting_string = resulting_string || this.__patterns.smarty.read();\n                            }\n                        }\n                    }\n                    return resulting_string;\n                };\n                module.exports.TemplatablePattern = TemplatablePattern;\n            /***/ }\n        ];\n        /************************************************************************/ /******/ // The module cache\n        /******/ var __webpack_module_cache__ = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_205681__(moduleId) {\n            /******/ // Check if module is in cache\n            /******/ var cachedModule = __webpack_module_cache__[moduleId];\n            /******/ if (cachedModule !== undefined) {\n                /******/ return cachedModule.exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module = __webpack_module_cache__[moduleId] = {\n                /******/ // no module.id needed\n                /******/ // no module.loaded needed\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ __webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_205681__);\n            /******/ /******/ // Return the exports of the module\n            /******/ return module.exports;\n        /******/ }\n        /******/ /************************************************************************/ /******/ /******/ // startup\n        /******/ // Load entry module and return exports\n        /******/ // This entry module is referenced by other modules so it can't be inlined\n        /******/ var __nested_webpack_exports__ = __nested_webpack_require_205681__(0);\n        /******/ legacy_beautify_js = __nested_webpack_exports__;\n    /******/ /******/ })();\n    var js_beautify = legacy_beautify_js;\n    /* Footer */ if (true) {\n        // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return {\n                js_beautify: js_beautify\n            };\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qcy1iZWF1dGlmeS9qcy9saWIvYmVhdXRpZnkuanMiLCJtYXBwaW5ncyI6IkFBQUEsa0dBQWtDLEdBQ2xDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvRkEsR0FFQztJQUVELDBCQUEwQixHQUMxQixJQUFJQTtJQUNKLE1BQU0sR0FBSTtRQUNWLE1BQU0sR0FBSTtRQUNWLE1BQU0sR0FBSSxJQUFJQyxzQkFBdUI7WUFDckMsS0FBSyxHQUNMLEdBQUcsR0FBSSxTQUFTQyxNQUFNLEVBQUVDLHdCQUF3QixFQUFFQywrQkFBbUI7Z0JBRXJFLG1CQUFtQixHQUNuQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQSxHQUlBLElBQUlDLGFBQWNELCtCQUFtQkEsQ0FBQyxHQUFHQyxVQUFVLEVBQ2pEQyxVQUFXRiwrQkFBbUJBLENBQUMsR0FBR0UsT0FBTztnQkFFM0MsU0FBU0MsWUFBWUMsY0FBYyxFQUFFQyxPQUFPO29CQUMxQyxJQUFJQyxhQUFhLElBQUlMLFdBQVdHLGdCQUFnQkM7b0JBQ2hELE9BQU9DLFdBQVdDLFFBQVE7Z0JBQzVCO2dCQUVBVCxPQUFPVSxPQUFPLEdBQUdMO2dCQUNqQkwsT0FBT1UsT0FBTyxDQUFDQyxjQUFjLEdBQUc7b0JBQzlCLE9BQU8sSUFBSVA7Z0JBQ2I7WUFHQSxHQUFHLEdBQUc7WUFDTixLQUFLLEdBQ0wsR0FBRyxHQUFJLFNBQVNKLE1BQU0sRUFBRUMsd0JBQXdCLEVBQUVDLCtCQUFtQjtnQkFFckUsbUJBQW1CLEdBQ25COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBLEdBSUEsSUFBSVUsU0FBVVYsK0JBQW1CQSxDQUFDLEdBQUdVLE1BQU07Z0JBQzNDLElBQUlDLFFBQVNYLCtCQUFtQkEsQ0FBQyxHQUFHVyxLQUFLO2dCQUN6QyxJQUFJQyxRQUFRWiwr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MEJBQTBCO2dCQUN0QyxNQUFNLEdBQU1uaEIsU0FBUyxDQUFDO1lBQ1g7WUFDWCxNQUFNLEdBQ04sTUFBTSxHQUFLLDhCQUE4QjtZQUN6QyxNQUFNLEdBQUtYLG1CQUFtQixDQUFDOGhCLFNBQVMsQ0FBQzdoQixRQUFRQSxPQUFPVSxPQUFPLEVBQUVSLGlDQUFtQkE7WUFDcEYsTUFBTSxHQUNOLE1BQU0sR0FBSyxtQ0FBbUM7WUFDOUMsTUFBTSxHQUFLLE9BQU9GLE9BQU9VLE9BQU87UUFDaEMsTUFBTSxHQUFJO1FBQ1YsTUFBTSxHQUNOLHdFQUF3RSxHQUN4RSxNQUFNLEdBQ04sTUFBTSxHQUFJLFVBQVU7UUFDcEIsTUFBTSxHQUFJLHVDQUF1QztRQUNqRCxNQUFNLEdBQUksMEVBQTBFO1FBQ3BGLE1BQU0sR0FBSSxJQUFJcWhCLDBCQUFtQkEsR0FBRzdoQixpQ0FBbUJBLENBQUM7UUFDeEQsTUFBTSxHQUFJSixxQkFBcUJpaUIsMEJBQW1CQTtJQUNsRCxNQUFNLEdBQ04sTUFBTSxHQUFHO0lBRVQsSUFBSTFoQixjQUFjUDtJQUNsQixVQUFVLEdBQ1YsSUFBSSxJQUEwQyxFQUFFO1FBQzVDLDBGQUEwRjtRQUMxRmtpQixpQ0FBTyxFQUFFLG1DQUFFO1lBQ1AsT0FBTztnQkFBRTNoQixhQUFhQTtZQUFZO1FBQ3RDLENBQUM7QUFBQSxrR0FBQztJQUNOLE9BQU8sRUFVTjtBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3Blbi1wcm8tbmV4dC8uL25vZGVfbW9kdWxlcy9qcy1iZWF1dGlmeS9qcy9saWIvYmVhdXRpZnkuanM/YzdjMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBBVVRPLUdFTkVSQVRFRC4gRE8gTk9UIE1PRElGWS4gKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuXG4gSlMgQmVhdXRpZmllclxuLS0tLS0tLS0tLS0tLS0tXG5cblxuICBXcml0dGVuIGJ5IEVpbmFyIExpZWxtYW5pcywgPGVpbmFyQGJlYXV0aWZpZXIuaW8+XG4gICAgICBodHRwczovL2JlYXV0aWZpZXIuaW8vXG5cbiAgT3JpZ2luYWxseSBjb252ZXJ0ZWQgdG8gamF2YXNjcmlwdCBieSBWaXRhbCwgPHZpdGFsNzZAZ21haWwuY29tPlxuICBcIkVuZCBicmFjZXMgb24gb3duIGxpbmVcIiBhZGRlZCBieSBDaHJpcyBKLiBTaHVsbCwgPGNocmlzanNodWxsQGdtYWlsLmNvbT5cbiAgUGFyc2luZyBpbXByb3ZlbWVudHMgZm9yIGJyYWNlLWxlc3Mgc3RhdGVtZW50cyBieSBMaWFtIE5ld21hbiA8Yml0d2lzZW1hbkBiZWF1dGlmaWVyLmlvPlxuXG5cbiAgVXNhZ2U6XG4gICAganNfYmVhdXRpZnkoanNfc291cmNlX3RleHQpO1xuICAgIGpzX2JlYXV0aWZ5KGpzX3NvdXJjZV90ZXh0LCBvcHRpb25zKTtcblxuICBUaGUgb3B0aW9ucyBhcmU6XG4gICAgaW5kZW50X3NpemUgKGRlZmF1bHQgNCkgICAgICAgICAgLSBpbmRlbnRhdGlvbiBzaXplLFxuICAgIGluZGVudF9jaGFyIChkZWZhdWx0IHNwYWNlKSAgICAgIC0gY2hhcmFjdGVyIHRvIGluZGVudCB3aXRoLFxuICAgIHByZXNlcnZlX25ld2xpbmVzIChkZWZhdWx0IHRydWUpIC0gd2hldGhlciBleGlzdGluZyBsaW5lIGJyZWFrcyBzaG91bGQgYmUgcHJlc2VydmVkLFxuICAgIG1heF9wcmVzZXJ2ZV9uZXdsaW5lcyAoZGVmYXVsdCB1bmxpbWl0ZWQpIC0gbWF4aW11bSBudW1iZXIgb2YgbGluZSBicmVha3MgdG8gYmUgcHJlc2VydmVkIGluIG9uZSBjaHVuayxcblxuICAgIGpzbGludF9oYXBweSAoZGVmYXVsdCBmYWxzZSkgLSBpZiB0cnVlLCB0aGVuIGpzbGludC1zdHJpY3RlciBtb2RlIGlzIGVuZm9yY2VkLlxuXG4gICAgICAgICAgICBqc2xpbnRfaGFwcHkgICAgICAgICFqc2xpbnRfaGFwcHlcbiAgICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgZnVuY3Rpb24gKCkgICAgICAgICBmdW5jdGlvbigpXG5cbiAgICAgICAgICAgIHN3aXRjaCAoKSB7ICAgICAgICAgc3dpdGNoKCkge1xuICAgICAgICAgICAgY2FzZSAxOiAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgYnJlYWs7ICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICB9XG5cbiAgICBzcGFjZV9hZnRlcl9hbm9uX2Z1bmN0aW9uIChkZWZhdWx0IGZhbHNlKSAtIHNob3VsZCB0aGUgc3BhY2UgYmVmb3JlIGFuIGFub255bW91cyBmdW5jdGlvbidzIHBhcmVucyBiZSBhZGRlZCwgXCJmdW5jdGlvbigpXCIgdnMgXCJmdW5jdGlvbiAoKVwiLFxuICAgICAgICAgIE5PVEU6IFRoaXMgb3B0aW9uIGlzIG92ZXJyaWRkZW4gYnkganNsaW50X2hhcHB5IChpLmUuIGlmIGpzbGludF9oYXBweSBpcyB0cnVlLCBzcGFjZV9hZnRlcl9hbm9uX2Z1bmN0aW9uIGlzIHRydWUgYnkgZGVzaWduKVxuXG4gICAgYnJhY2Vfc3R5bGUgKGRlZmF1bHQgXCJjb2xsYXBzZVwiKSAtIFwiY29sbGFwc2VcIiB8IFwiZXhwYW5kXCIgfCBcImVuZC1leHBhbmRcIiB8IFwibm9uZVwiIHwgYW55IG9mIHRoZSBmb3JtZXIgKyBcIixwcmVzZXJ2ZS1pbmxpbmVcIlxuICAgICAgICAgICAgcHV0IGJyYWNlcyBvbiB0aGUgc2FtZSBsaW5lIGFzIGNvbnRyb2wgc3RhdGVtZW50cyAoZGVmYXVsdCksIG9yIHB1dCBicmFjZXMgb24gb3duIGxpbmUgKEFsbG1hbiAvIEFOU0kgc3R5bGUpLCBvciBqdXN0IHB1dCBlbmQgYnJhY2VzIG9uIG93biBsaW5lLCBvciBhdHRlbXB0IHRvIGtlZXAgdGhlbSB3aGVyZSB0aGV5IGFyZS5cbiAgICAgICAgICAgIHByZXNlcnZlLWlubGluZSB3aWxsIHRyeSB0byBwcmVzZXJ2ZSBpbmxpbmUgYmxvY2tzIG9mIGN1cmx5IGJyYWNlc1xuXG4gICAgc3BhY2VfYmVmb3JlX2NvbmRpdGlvbmFsIChkZWZhdWx0IHRydWUpIC0gc2hvdWxkIHRoZSBzcGFjZSBiZWZvcmUgY29uZGl0aW9uYWwgc3RhdGVtZW50IGJlIGFkZGVkLCBcImlmKHRydWUpXCIgdnMgXCJpZiAodHJ1ZSlcIixcblxuICAgIHVuZXNjYXBlX3N0cmluZ3MgKGRlZmF1bHQgZmFsc2UpIC0gc2hvdWxkIHByaW50YWJsZSBjaGFyYWN0ZXJzIGluIHN0cmluZ3MgZW5jb2RlZCBpbiBcXHhOTiBub3RhdGlvbiBiZSB1bmVzY2FwZWQsIFwiZXhhbXBsZVwiIHZzIFwiXFx4NjVcXHg3OFxceDYxXFx4NmRcXHg3MFxceDZjXFx4NjVcIlxuXG4gICAgd3JhcF9saW5lX2xlbmd0aCAoZGVmYXVsdCB1bmxpbWl0ZWQpIC0gbGluZXMgc2hvdWxkIHdyYXAgYXQgbmV4dCBvcHBvcnR1bml0eSBhZnRlciB0aGlzIG51bWJlciBvZiBjaGFyYWN0ZXJzLlxuICAgICAgICAgIE5PVEU6IFRoaXMgaXMgbm90IGEgaGFyZCBsaW1pdC4gTGluZXMgd2lsbCBjb250aW51ZSB1bnRpbCBhIHBvaW50IHdoZXJlIGEgbmV3bGluZSB3b3VsZFxuICAgICAgICAgICAgICAgIGJlIHByZXNlcnZlZCBpZiBpdCB3ZXJlIHByZXNlbnQuXG5cbiAgICBlbmRfd2l0aF9uZXdsaW5lIChkZWZhdWx0IGZhbHNlKSAgLSBlbmQgb3V0cHV0IHdpdGggYSBuZXdsaW5lXG5cblxuICAgIGUuZ1xuXG4gICAganNfYmVhdXRpZnkoanNfc291cmNlX3RleHQsIHtcbiAgICAgICdpbmRlbnRfc2l6ZSc6IDEsXG4gICAgICAnaW5kZW50X2NoYXInOiAnXFx0J1xuICAgIH0pO1xuXG4qL1xuXG4oZnVuY3Rpb24oKSB7XG5cbi8qIEdFTkVSQVRFRF9CVUlMRF9PVVRQVVQgKi9cbnZhciBsZWdhY3lfYmVhdXRpZnlfanM7XG4vKioqKioqLyAoZnVuY3Rpb24oKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0XCJ1c2Ugc3RyaWN0XCI7XG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciBCZWF1dGlmaWVyID0gKF9fd2VicGFja19yZXF1aXJlX18oMSkuQmVhdXRpZmllciksXG4gIE9wdGlvbnMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXyg1KS5PcHRpb25zKTtcblxuZnVuY3Rpb24ganNfYmVhdXRpZnkoanNfc291cmNlX3RleHQsIG9wdGlvbnMpIHtcbiAgdmFyIGJlYXV0aWZpZXIgPSBuZXcgQmVhdXRpZmllcihqc19zb3VyY2VfdGV4dCwgb3B0aW9ucyk7XG4gIHJldHVybiBiZWF1dGlmaWVyLmJlYXV0aWZ5KCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ganNfYmVhdXRpZnk7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IE9wdGlvbnMoKTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG52YXIgT3V0cHV0ID0gKF9fd2VicGFja19yZXF1aXJlX18oMikuT3V0cHV0KTtcbnZhciBUb2tlbiA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpLlRva2VuKTtcbnZhciBhY29ybiA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG52YXIgT3B0aW9ucyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDUpLk9wdGlvbnMpO1xudmFyIFRva2VuaXplciA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDcpLlRva2VuaXplcik7XG52YXIgbGluZV9zdGFydGVycyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDcpLmxpbmVfc3RhcnRlcnMpO1xudmFyIHBvc2l0aW9uYWJsZV9vcGVyYXRvcnMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXyg3KS5wb3NpdGlvbmFibGVfb3BlcmF0b3JzKTtcbnZhciBUT0tFTiA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDcpLlRPS0VOKTtcblxuXG5mdW5jdGlvbiBpbl9hcnJheSh3aGF0LCBhcnIpIHtcbiAgcmV0dXJuIGFyci5pbmRleE9mKHdoYXQpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gbHRyaW0ocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC9eXFxzKy9nLCAnJyk7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlTWFwRnJvbVN0cmluZ3MobGlzdCkge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZvciAodmFyIHggPSAwOyB4IDwgbGlzdC5sZW5ndGg7IHgrKykge1xuICAgIC8vIG1ha2UgdGhlIG1hcHBlZCBuYW1lcyB1bmRlcnNjb3JlZCBpbnN0ZWFkIG9mIGRhc2hcbiAgICByZXN1bHRbbGlzdFt4XS5yZXBsYWNlKC8tL2csICdfJyldID0gbGlzdFt4XTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiByZXNlcnZlZF93b3JkKHRva2VuLCB3b3JkKSB7XG4gIHJldHVybiB0b2tlbiAmJiB0b2tlbi50eXBlID09PSBUT0tFTi5SRVNFUlZFRCAmJiB0b2tlbi50ZXh0ID09PSB3b3JkO1xufVxuXG5mdW5jdGlvbiByZXNlcnZlZF9hcnJheSh0b2tlbiwgd29yZHMpIHtcbiAgcmV0dXJuIHRva2VuICYmIHRva2VuLnR5cGUgPT09IFRPS0VOLlJFU0VSVkVEICYmIGluX2FycmF5KHRva2VuLnRleHQsIHdvcmRzKTtcbn1cbi8vIFVuc3VyZSBvZiB3aGF0IHRoZXkgbWVhbiwgYnV0IHRoZXkgd29yay4gV29ydGggY2xlYW5pbmcgdXAgaW4gZnV0dXJlLlxudmFyIHNwZWNpYWxfd29yZHMgPSBbJ2Nhc2UnLCAncmV0dXJuJywgJ2RvJywgJ2lmJywgJ3Rocm93JywgJ2Vsc2UnLCAnYXdhaXQnLCAnYnJlYWsnLCAnY29udGludWUnLCAnYXN5bmMnXTtcblxudmFyIHZhbGlkUG9zaXRpb25WYWx1ZXMgPSBbJ2JlZm9yZS1uZXdsaW5lJywgJ2FmdGVyLW5ld2xpbmUnLCAncHJlc2VydmUtbmV3bGluZSddO1xuXG4vLyBHZW5lcmF0ZSBtYXAgZnJvbSBhcnJheVxudmFyIE9QRVJBVE9SX1BPU0lUSU9OID0gZ2VuZXJhdGVNYXBGcm9tU3RyaW5ncyh2YWxpZFBvc2l0aW9uVmFsdWVzKTtcblxudmFyIE9QRVJBVE9SX1BPU0lUSU9OX0JFRk9SRV9PUl9QUkVTRVJWRSA9IFtPUEVSQVRPUl9QT1NJVElPTi5iZWZvcmVfbmV3bGluZSwgT1BFUkFUT1JfUE9TSVRJT04ucHJlc2VydmVfbmV3bGluZV07XG5cbnZhciBNT0RFID0ge1xuICBCbG9ja1N0YXRlbWVudDogJ0Jsb2NrU3RhdGVtZW50JywgLy8gJ0JMT0NLJ1xuICBTdGF0ZW1lbnQ6ICdTdGF0ZW1lbnQnLCAvLyAnU1RBVEVNRU5UJ1xuICBPYmplY3RMaXRlcmFsOiAnT2JqZWN0TGl0ZXJhbCcsIC8vICdPQkpFQ1QnLFxuICBBcnJheUxpdGVyYWw6ICdBcnJheUxpdGVyYWwnLCAvLydbRVhQUkVTU0lPTl0nLFxuICBGb3JJbml0aWFsaXplcjogJ0ZvckluaXRpYWxpemVyJywgLy8nKEZPUi1FWFBSRVNTSU9OKScsXG4gIENvbmRpdGlvbmFsOiAnQ29uZGl0aW9uYWwnLCAvLycoQ09ORC1FWFBSRVNTSU9OKScsXG4gIEV4cHJlc3Npb246ICdFeHByZXNzaW9uJyAvLycoRVhQUkVTU0lPTiknXG59O1xuXG5mdW5jdGlvbiByZW1vdmVfcmVkdW5kYW50X2luZGVudGF0aW9uKG91dHB1dCwgZnJhbWUpIHtcbiAgLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBlZmZlY3RpdmUgYnV0IGhhcyBzb21lIGlzc3VlczpcbiAgLy8gICAgIC0gY2FuIGNhdXNlIGxpbmUgd3JhcCB0byBoYXBwZW4gdG9vIHNvb24gZHVlIHRvIGluZGVudCByZW1vdmFsXG4gIC8vICAgICAgICAgICBhZnRlciB3cmFwIHBvaW50cyBhcmUgY2FsY3VsYXRlZFxuICAvLyBUaGVzZSBpc3N1ZXMgYXJlIG1pbm9yIGNvbXBhcmVkIHRvIHVnbHkgaW5kZW50YXRpb24uXG5cbiAgaWYgKGZyYW1lLm11bHRpbGluZV9mcmFtZSB8fFxuICAgIGZyYW1lLm1vZGUgPT09IE1PREUuRm9ySW5pdGlhbGl6ZXIgfHxcbiAgICBmcmFtZS5tb2RlID09PSBNT0RFLkNvbmRpdGlvbmFsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gcmVtb3ZlIG9uZSBpbmRlbnQgZnJvbSBlYWNoIGxpbmUgaW5zaWRlIHRoaXMgc2VjdGlvblxuICBvdXRwdXQucmVtb3ZlX2luZGVudChmcmFtZS5zdGFydF9saW5lX2luZGV4KTtcbn1cblxuLy8gd2UgY291bGQgdXNlIGp1c3Qgc3RyaW5nLnNwbGl0LCBidXRcbi8vIElFIGRvZXNuJ3QgbGlrZSByZXR1cm5pbmcgZW1wdHkgc3RyaW5nc1xuZnVuY3Rpb24gc3BsaXRfbGluZWJyZWFrcyhzKSB7XG4gIC8vcmV0dXJuIHMuc3BsaXQoL1xceDBkXFx4MGF8XFx4MGEvKTtcblxuICBzID0gcy5yZXBsYWNlKGFjb3JuLmFsbExpbmVCcmVha3MsICdcXG4nKTtcbiAgdmFyIG91dCA9IFtdLFxuICAgIGlkeCA9IHMuaW5kZXhPZihcIlxcblwiKTtcbiAgd2hpbGUgKGlkeCAhPT0gLTEpIHtcbiAgICBvdXQucHVzaChzLnN1YnN0cmluZygwLCBpZHgpKTtcbiAgICBzID0gcy5zdWJzdHJpbmcoaWR4ICsgMSk7XG4gICAgaWR4ID0gcy5pbmRleE9mKFwiXFxuXCIpO1xuICB9XG4gIGlmIChzLmxlbmd0aCkge1xuICAgIG91dC5wdXNoKHMpO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGlzX2FycmF5KG1vZGUpIHtcbiAgcmV0dXJuIG1vZGUgPT09IE1PREUuQXJyYXlMaXRlcmFsO1xufVxuXG5mdW5jdGlvbiBpc19leHByZXNzaW9uKG1vZGUpIHtcbiAgcmV0dXJuIGluX2FycmF5KG1vZGUsIFtNT0RFLkV4cHJlc3Npb24sIE1PREUuRm9ySW5pdGlhbGl6ZXIsIE1PREUuQ29uZGl0aW9uYWxdKTtcbn1cblxuZnVuY3Rpb24gYWxsX2xpbmVzX3N0YXJ0X3dpdGgobGluZXMsIGMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsaW5lID0gbGluZXNbaV0udHJpbSgpO1xuICAgIGlmIChsaW5lLmNoYXJBdCgwKSAhPT0gYykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZWFjaF9saW5lX21hdGNoZXNfaW5kZW50KGxpbmVzLCBpbmRlbnQpIHtcbiAgdmFyIGkgPSAwLFxuICAgIGxlbiA9IGxpbmVzLmxlbmd0aCxcbiAgICBsaW5lO1xuICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbGluZSA9IGxpbmVzW2ldO1xuICAgIC8vIGFsbG93IGVtcHR5IGxpbmVzIHRvIHBhc3MgdGhyb3VnaFxuICAgIGlmIChsaW5lICYmIGxpbmUuaW5kZXhPZihpbmRlbnQpICE9PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5cbmZ1bmN0aW9uIEJlYXV0aWZpZXIoc291cmNlX3RleHQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuX3NvdXJjZV90ZXh0ID0gc291cmNlX3RleHQgfHwgJyc7XG5cbiAgdGhpcy5fb3V0cHV0ID0gbnVsbDtcbiAgdGhpcy5fdG9rZW5zID0gbnVsbDtcbiAgdGhpcy5fbGFzdF9sYXN0X3RleHQgPSBudWxsO1xuICB0aGlzLl9mbGFncyA9IG51bGw7XG4gIHRoaXMuX3ByZXZpb3VzX2ZsYWdzID0gbnVsbDtcblxuICB0aGlzLl9mbGFnX3N0b3JlID0gbnVsbDtcbiAgdGhpcy5fb3B0aW9ucyA9IG5ldyBPcHRpb25zKG9wdGlvbnMpO1xufVxuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5jcmVhdGVfZmxhZ3MgPSBmdW5jdGlvbihmbGFnc19iYXNlLCBtb2RlKSB7XG4gIHZhciBuZXh0X2luZGVudF9sZXZlbCA9IDA7XG4gIGlmIChmbGFnc19iYXNlKSB7XG4gICAgbmV4dF9pbmRlbnRfbGV2ZWwgPSBmbGFnc19iYXNlLmluZGVudGF0aW9uX2xldmVsO1xuICAgIGlmICghdGhpcy5fb3V0cHV0Lmp1c3RfYWRkZWRfbmV3bGluZSgpICYmXG4gICAgICBmbGFnc19iYXNlLmxpbmVfaW5kZW50X2xldmVsID4gbmV4dF9pbmRlbnRfbGV2ZWwpIHtcbiAgICAgIG5leHRfaW5kZW50X2xldmVsID0gZmxhZ3NfYmFzZS5saW5lX2luZGVudF9sZXZlbDtcbiAgICB9XG4gIH1cblxuICB2YXIgbmV4dF9mbGFncyA9IHtcbiAgICBtb2RlOiBtb2RlLFxuICAgIHBhcmVudDogZmxhZ3NfYmFzZSxcbiAgICBsYXN0X3Rva2VuOiBmbGFnc19iYXNlID8gZmxhZ3NfYmFzZS5sYXN0X3Rva2VuIDogbmV3IFRva2VuKFRPS0VOLlNUQVJUX0JMT0NLLCAnJyksIC8vIGxhc3QgdG9rZW4gdGV4dFxuICAgIGxhc3Rfd29yZDogZmxhZ3NfYmFzZSA/IGZsYWdzX2Jhc2UubGFzdF93b3JkIDogJycsIC8vIGxhc3QgVE9LRU4uV09SRCBwYXNzZWRcbiAgICBkZWNsYXJhdGlvbl9zdGF0ZW1lbnQ6IGZhbHNlLFxuICAgIGRlY2xhcmF0aW9uX2Fzc2lnbm1lbnQ6IGZhbHNlLFxuICAgIG11bHRpbGluZV9mcmFtZTogZmFsc2UsXG4gICAgaW5saW5lX2ZyYW1lOiBmYWxzZSxcbiAgICBpZl9ibG9jazogZmFsc2UsXG4gICAgZWxzZV9ibG9jazogZmFsc2UsXG4gICAgY2xhc3Nfc3RhcnRfYmxvY2s6IGZhbHNlLCAvLyBjbGFzcyBBIHsgSU5TSURFIEhFUkUgfSBvciBjbGFzcyBCIGV4dGVuZHMgQyB7IElOU0lERSBIRVJFIH1cbiAgICBkb19ibG9jazogZmFsc2UsXG4gICAgZG9fd2hpbGU6IGZhbHNlLFxuICAgIGltcG9ydF9ibG9jazogZmFsc2UsXG4gICAgaW5fY2FzZV9zdGF0ZW1lbnQ6IGZhbHNlLCAvLyBzd2l0Y2goLi4peyBJTlNJREUgSEVSRSB9XG4gICAgaW5fY2FzZTogZmFsc2UsIC8vIHdlJ3JlIG9uIHRoZSBleGFjdCBsaW5lIHdpdGggXCJjYXNlIDA6XCJcbiAgICBjYXNlX2JvZHk6IGZhbHNlLCAvLyB0aGUgaW5kZW50ZWQgY2FzZS1hY3Rpb24gYmxvY2tcbiAgICBjYXNlX2Jsb2NrOiBmYWxzZSwgLy8gdGhlIGluZGVudGVkIGNhc2UtYWN0aW9uIGJsb2NrIGlzIHdyYXBwZWQgd2l0aCB7fVxuICAgIGluZGVudGF0aW9uX2xldmVsOiBuZXh0X2luZGVudF9sZXZlbCxcbiAgICBhbGlnbm1lbnQ6IDAsXG4gICAgbGluZV9pbmRlbnRfbGV2ZWw6IGZsYWdzX2Jhc2UgPyBmbGFnc19iYXNlLmxpbmVfaW5kZW50X2xldmVsIDogbmV4dF9pbmRlbnRfbGV2ZWwsXG4gICAgc3RhcnRfbGluZV9pbmRleDogdGhpcy5fb3V0cHV0LmdldF9saW5lX251bWJlcigpLFxuICAgIHRlcm5hcnlfZGVwdGg6IDBcbiAgfTtcbiAgcmV0dXJuIG5leHRfZmxhZ3M7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5fcmVzZXQgPSBmdW5jdGlvbihzb3VyY2VfdGV4dCkge1xuICB2YXIgYmFzZUluZGVudFN0cmluZyA9IHNvdXJjZV90ZXh0Lm1hdGNoKC9eW1xcdCBdKi8pWzBdO1xuXG4gIHRoaXMuX2xhc3RfbGFzdF90ZXh0ID0gJyc7IC8vIHByZS1sYXN0IHRva2VuIHRleHRcbiAgdGhpcy5fb3V0cHV0ID0gbmV3IE91dHB1dCh0aGlzLl9vcHRpb25zLCBiYXNlSW5kZW50U3RyaW5nKTtcblxuICAvLyBJZiB0ZXN0aW5nIHRoZSBpZ25vcmUgZGlyZWN0aXZlLCBzdGFydCB3aXRoIG91dHB1dCBkaXNhYmxlIHNldCB0byB0cnVlXG4gIHRoaXMuX291dHB1dC5yYXcgPSB0aGlzLl9vcHRpb25zLnRlc3Rfb3V0cHV0X3JhdztcblxuXG4gIC8vIFN0YWNrIG9mIHBhcnNpbmcvZm9ybWF0dGluZyBzdGF0ZXMsIGluY2x1ZGluZyBNT0RFLlxuICAvLyBXZSB0b2tlbml6ZSwgcGFyc2UsIGFuZCBvdXRwdXQgaW4gYW4gYWxtb3N0IHB1cmVseSBhIGZvcndhcmQtb25seSBzdHJlYW0gb2YgdG9rZW4gaW5wdXRcbiAgLy8gYW5kIGZvcm1hdHRlZCBvdXRwdXQuICBUaGlzIG1ha2VzIHRoZSBiZWF1dGlmaWVyIGxlc3MgYWNjdXJhdGUgdGhhbiBmdWxsIHBhcnNlcnNcbiAgLy8gYnV0IGFsc28gZmFyIG1vcmUgdG9sZXJhbnQgb2Ygc3ludGF4IGVycm9ycy5cbiAgLy9cbiAgLy8gRm9yIGV4YW1wbGUsIHRoZSBkZWZhdWx0IG1vZGUgaXMgTU9ERS5CbG9ja1N0YXRlbWVudC4gSWYgd2Ugc2VlIGEgJ3snIHdlIHB1c2ggYSBuZXcgZnJhbWUgb2YgdHlwZVxuICAvLyBNT0RFLkJsb2NrU3RhdGVtZW50IG9uIHRoZSB0aGUgc3RhY2ssIGV2ZW4gdGhvdWdoIGl0IGNvdWxkIGJlIG9iamVjdCBsaXRlcmFsLiAgSWYgd2UgbGF0ZXJcbiAgLy8gZW5jb3VudGVyIGEgXCI6XCIsIHdlJ2xsIHN3aXRjaCB0byB0byBNT0RFLk9iamVjdExpdGVyYWwuICBJZiB3ZSB0aGVuIHNlZSBhIFwiO1wiLFxuICAvLyBtb3N0IGZ1bGwgcGFyc2VycyB3b3VsZCBkaWUsIGJ1dCB0aGUgYmVhdXRpZmllciBncmFjZWZ1bGx5IGZhbGxzIGJhY2sgdG9cbiAgLy8gTU9ERS5CbG9ja1N0YXRlbWVudCBhbmQgY29udGludWVzIG9uLlxuICB0aGlzLl9mbGFnX3N0b3JlID0gW107XG4gIHRoaXMuc2V0X21vZGUoTU9ERS5CbG9ja1N0YXRlbWVudCk7XG4gIHZhciB0b2tlbml6ZXIgPSBuZXcgVG9rZW5pemVyKHNvdXJjZV90ZXh0LCB0aGlzLl9vcHRpb25zKTtcbiAgdGhpcy5fdG9rZW5zID0gdG9rZW5pemVyLnRva2VuaXplKCk7XG4gIHJldHVybiBzb3VyY2VfdGV4dDtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmJlYXV0aWZ5ID0gZnVuY3Rpb24oKSB7XG4gIC8vIGlmIGRpc2FibGVkLCByZXR1cm4gdGhlIGlucHV0IHVuY2hhbmdlZC5cbiAgaWYgKHRoaXMuX29wdGlvbnMuZGlzYWJsZWQpIHtcbiAgICByZXR1cm4gdGhpcy5fc291cmNlX3RleHQ7XG4gIH1cblxuICB2YXIgc3dlZXRfY29kZTtcbiAgdmFyIHNvdXJjZV90ZXh0ID0gdGhpcy5fcmVzZXQodGhpcy5fc291cmNlX3RleHQpO1xuXG4gIHZhciBlb2wgPSB0aGlzLl9vcHRpb25zLmVvbDtcbiAgaWYgKHRoaXMuX29wdGlvbnMuZW9sID09PSAnYXV0bycpIHtcbiAgICBlb2wgPSAnXFxuJztcbiAgICBpZiAoc291cmNlX3RleHQgJiYgYWNvcm4ubGluZUJyZWFrLnRlc3Qoc291cmNlX3RleHQgfHwgJycpKSB7XG4gICAgICBlb2wgPSBzb3VyY2VfdGV4dC5tYXRjaChhY29ybi5saW5lQnJlYWspWzBdO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjdXJyZW50X3Rva2VuID0gdGhpcy5fdG9rZW5zLm5leHQoKTtcbiAgd2hpbGUgKGN1cnJlbnRfdG9rZW4pIHtcbiAgICB0aGlzLmhhbmRsZV90b2tlbihjdXJyZW50X3Rva2VuKTtcblxuICAgIHRoaXMuX2xhc3RfbGFzdF90ZXh0ID0gdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0O1xuICAgIHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4gPSBjdXJyZW50X3Rva2VuO1xuXG4gICAgY3VycmVudF90b2tlbiA9IHRoaXMuX3Rva2Vucy5uZXh0KCk7XG4gIH1cblxuICBzd2VldF9jb2RlID0gdGhpcy5fb3V0cHV0LmdldF9jb2RlKGVvbCk7XG5cbiAgcmV0dXJuIHN3ZWV0X2NvZGU7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5oYW5kbGVfdG9rZW4gPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpIHtcbiAgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RBUlRfRVhQUikge1xuICAgIHRoaXMuaGFuZGxlX3N0YXJ0X2V4cHIoY3VycmVudF90b2tlbik7XG4gIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5FTkRfRVhQUikge1xuICAgIHRoaXMuaGFuZGxlX2VuZF9leHByKGN1cnJlbnRfdG9rZW4pO1xuICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RBUlRfQkxPQ0spIHtcbiAgICB0aGlzLmhhbmRsZV9zdGFydF9ibG9jayhjdXJyZW50X3Rva2VuKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVORF9CTE9DSykge1xuICAgIHRoaXMuaGFuZGxlX2VuZF9ibG9jayhjdXJyZW50X3Rva2VuKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLldPUkQpIHtcbiAgICB0aGlzLmhhbmRsZV93b3JkKGN1cnJlbnRfdG9rZW4pO1xuICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uUkVTRVJWRUQpIHtcbiAgICB0aGlzLmhhbmRsZV93b3JkKGN1cnJlbnRfdG9rZW4pO1xuICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uU0VNSUNPTE9OKSB7XG4gICAgdGhpcy5oYW5kbGVfc2VtaWNvbG9uKGN1cnJlbnRfdG9rZW4pO1xuICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RSSU5HKSB7XG4gICAgdGhpcy5oYW5kbGVfc3RyaW5nKGN1cnJlbnRfdG9rZW4pO1xuICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uRVFVQUxTKSB7XG4gICAgdGhpcy5oYW5kbGVfZXF1YWxzKGN1cnJlbnRfdG9rZW4pO1xuICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uT1BFUkFUT1IpIHtcbiAgICB0aGlzLmhhbmRsZV9vcGVyYXRvcihjdXJyZW50X3Rva2VuKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLkNPTU1BKSB7XG4gICAgdGhpcy5oYW5kbGVfY29tbWEoY3VycmVudF90b2tlbik7XG4gIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5CTE9DS19DT01NRU5UKSB7XG4gICAgdGhpcy5oYW5kbGVfYmxvY2tfY29tbWVudChjdXJyZW50X3Rva2VuLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uQ09NTUVOVCkge1xuICAgIHRoaXMuaGFuZGxlX2NvbW1lbnQoY3VycmVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLkRPVCkge1xuICAgIHRoaXMuaGFuZGxlX2RvdChjdXJyZW50X3Rva2VuKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVPRikge1xuICAgIHRoaXMuaGFuZGxlX2VvZihjdXJyZW50X3Rva2VuKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLlVOS05PV04pIHtcbiAgICB0aGlzLmhhbmRsZV91bmtub3duKGN1cnJlbnRfdG9rZW4sIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5oYW5kbGVfdW5rbm93bihjdXJyZW50X3Rva2VuLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpIHtcbiAgdmFyIG5ld2xpbmVzID0gY3VycmVudF90b2tlbi5uZXdsaW5lcztcbiAgdmFyIGtlZXBfd2hpdGVzcGFjZSA9IHRoaXMuX29wdGlvbnMua2VlcF9hcnJheV9pbmRlbnRhdGlvbiAmJiBpc19hcnJheSh0aGlzLl9mbGFncy5tb2RlKTtcblxuICBpZiAoY3VycmVudF90b2tlbi5jb21tZW50c19iZWZvcmUpIHtcbiAgICB2YXIgY29tbWVudF90b2tlbiA9IGN1cnJlbnRfdG9rZW4uY29tbWVudHNfYmVmb3JlLm5leHQoKTtcbiAgICB3aGlsZSAoY29tbWVudF90b2tlbikge1xuICAgICAgLy8gVGhlIGNsZWFuZXN0IGhhbmRsaW5nIG9mIGlubGluZSBjb21tZW50cyBpcyB0byB0cmVhdCB0aGVtIGFzIHRob3VnaCB0aGV5IGFyZW4ndCB0aGVyZS5cbiAgICAgIC8vIEp1c3QgY29udGludWUgZm9ybWF0dGluZyBhbmQgdGhlIGJlaGF2aW9yIHNob3VsZCBiZSBsb2dpY2FsLlxuICAgICAgLy8gQWxzbyBpZ25vcmUgdW5rbm93biB0b2tlbnMuICBBZ2FpbiwgdGhpcyBzaG91bGQgcmVzdWx0IGluIGJldHRlciBiZWhhdmlvci5cbiAgICAgIHRoaXMuaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGNvbW1lbnRfdG9rZW4sIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gICAgICB0aGlzLmhhbmRsZV90b2tlbihjb21tZW50X3Rva2VuLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICAgICAgY29tbWVudF90b2tlbiA9IGN1cnJlbnRfdG9rZW4uY29tbWVudHNfYmVmb3JlLm5leHQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoa2VlcF93aGl0ZXNwYWNlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdsaW5lczsgaSArPSAxKSB7XG4gICAgICB0aGlzLnByaW50X25ld2xpbmUoaSA+IDAsIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0aGlzLl9vcHRpb25zLm1heF9wcmVzZXJ2ZV9uZXdsaW5lcyAmJiBuZXdsaW5lcyA+IHRoaXMuX29wdGlvbnMubWF4X3ByZXNlcnZlX25ld2xpbmVzKSB7XG4gICAgICBuZXdsaW5lcyA9IHRoaXMuX29wdGlvbnMubWF4X3ByZXNlcnZlX25ld2xpbmVzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vcHRpb25zLnByZXNlcnZlX25ld2xpbmVzKSB7XG4gICAgICBpZiAobmV3bGluZXMgPiAxKSB7XG4gICAgICAgIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBuZXdsaW5lczsgaiArPSAxKSB7XG4gICAgICAgICAgdGhpcy5wcmludF9uZXdsaW5lKHRydWUsIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxudmFyIG5ld2xpbmVfcmVzdHJpY3RlZF90b2tlbnMgPSBbJ2FzeW5jJywgJ2JyZWFrJywgJ2NvbnRpbnVlJywgJ3JldHVybicsICd0aHJvdycsICd5aWVsZCddO1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lID0gZnVuY3Rpb24oY3VycmVudF90b2tlbiwgZm9yY2VfbGluZXdyYXApIHtcbiAgZm9yY2VfbGluZXdyYXAgPSAoZm9yY2VfbGluZXdyYXAgPT09IHVuZGVmaW5lZCkgPyBmYWxzZSA6IGZvcmNlX2xpbmV3cmFwO1xuXG4gIC8vIE5ldmVyIHdyYXAgdGhlIGZpcnN0IHRva2VuIG9uIGEgbGluZVxuICBpZiAodGhpcy5fb3V0cHV0Lmp1c3RfYWRkZWRfbmV3bGluZSgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNob3VsZFByZXNlcnZlT3JGb3JjZSA9ICh0aGlzLl9vcHRpb25zLnByZXNlcnZlX25ld2xpbmVzICYmIGN1cnJlbnRfdG9rZW4ubmV3bGluZXMpIHx8IGZvcmNlX2xpbmV3cmFwO1xuICB2YXIgb3BlcmF0b3JMb2dpY0FwcGxpZXMgPSBpbl9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQsIHBvc2l0aW9uYWJsZV9vcGVyYXRvcnMpIHx8XG4gICAgaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LCBwb3NpdGlvbmFibGVfb3BlcmF0b3JzKTtcblxuICBpZiAob3BlcmF0b3JMb2dpY0FwcGxpZXMpIHtcbiAgICB2YXIgc2hvdWxkUHJpbnRPcGVyYXRvck5ld2xpbmUgPSAoXG4gICAgICAgIGluX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCwgcG9zaXRpb25hYmxlX29wZXJhdG9ycykgJiZcbiAgICAgICAgaW5fYXJyYXkodGhpcy5fb3B0aW9ucy5vcGVyYXRvcl9wb3NpdGlvbiwgT1BFUkFUT1JfUE9TSVRJT05fQkVGT1JFX09SX1BSRVNFUlZFKVxuICAgICAgKSB8fFxuICAgICAgaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LCBwb3NpdGlvbmFibGVfb3BlcmF0b3JzKTtcbiAgICBzaG91bGRQcmVzZXJ2ZU9yRm9yY2UgPSBzaG91bGRQcmVzZXJ2ZU9yRm9yY2UgJiYgc2hvdWxkUHJpbnRPcGVyYXRvck5ld2xpbmU7XG4gIH1cblxuICBpZiAoc2hvdWxkUHJlc2VydmVPckZvcmNlKSB7XG4gICAgdGhpcy5wcmludF9uZXdsaW5lKGZhbHNlLCB0cnVlKTtcbiAgfSBlbHNlIGlmICh0aGlzLl9vcHRpb25zLndyYXBfbGluZV9sZW5ndGgpIHtcbiAgICBpZiAocmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgbmV3bGluZV9yZXN0cmljdGVkX3Rva2VucykpIHtcbiAgICAgIC8vIFRoZXNlIHRva2VucyBzaG91bGQgbmV2ZXIgaGF2ZSBhIG5ld2xpbmUgaW5zZXJ0ZWRcbiAgICAgIC8vIGJldHdlZW4gdGhlbSBhbmQgdGhlIGZvbGxvd2luZyBleHByZXNzaW9uLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9vdXRwdXQuc2V0X3dyYXBfcG9pbnQoKTtcbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUucHJpbnRfbmV3bGluZSA9IGZ1bmN0aW9uKGZvcmNlX25ld2xpbmUsIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncykge1xuICBpZiAoIXByZXNlcnZlX3N0YXRlbWVudF9mbGFncykge1xuICAgIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgIT09ICc7JyAmJiB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgIT09ICcsJyAmJiB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgIT09ICc9JyAmJiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlICE9PSBUT0tFTi5PUEVSQVRPUiB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICctLScgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnKysnKSkge1xuICAgICAgdmFyIG5leHRfdG9rZW4gPSB0aGlzLl90b2tlbnMucGVlaygpO1xuICAgICAgd2hpbGUgKHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50ICYmXG4gICAgICAgICEodGhpcy5fZmxhZ3MuaWZfYmxvY2sgJiYgcmVzZXJ2ZWRfd29yZChuZXh0X3Rva2VuLCAnZWxzZScpKSAmJlxuICAgICAgICAhdGhpcy5fZmxhZ3MuZG9fYmxvY2spIHtcbiAgICAgICAgdGhpcy5yZXN0b3JlX21vZGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5fb3V0cHV0LmFkZF9uZXdfbGluZShmb3JjZV9uZXdsaW5lKSkge1xuICAgIHRoaXMuX2ZsYWdzLm11bHRpbGluZV9mcmFtZSA9IHRydWU7XG4gIH1cbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLnByaW50X3Rva2VuX2xpbmVfaW5kZW50YXRpb24gPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIGlmICh0aGlzLl9vdXRwdXQuanVzdF9hZGRlZF9uZXdsaW5lKCkpIHtcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5rZWVwX2FycmF5X2luZGVudGF0aW9uICYmXG4gICAgICBjdXJyZW50X3Rva2VuLm5ld2xpbmVzICYmXG4gICAgICAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnWycgfHwgaXNfYXJyYXkodGhpcy5fZmxhZ3MubW9kZSkpKSB7XG4gICAgICB0aGlzLl9vdXRwdXQuY3VycmVudF9saW5lLnNldF9pbmRlbnQoLTEpO1xuICAgICAgdGhpcy5fb3V0cHV0LmN1cnJlbnRfbGluZS5wdXNoKGN1cnJlbnRfdG9rZW4ud2hpdGVzcGFjZV9iZWZvcmUpO1xuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3V0cHV0LnNldF9pbmRlbnQodGhpcy5fZmxhZ3MuaW5kZW50YXRpb25fbGV2ZWwsIHRoaXMuX2ZsYWdzLmFsaWdubWVudCkpIHtcbiAgICAgIHRoaXMuX2ZsYWdzLmxpbmVfaW5kZW50X2xldmVsID0gdGhpcy5fZmxhZ3MuaW5kZW50YXRpb25fbGV2ZWw7XG4gICAgfVxuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5wcmludF90b2tlbiA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgaWYgKHRoaXMuX291dHB1dC5yYXcpIHtcbiAgICB0aGlzLl9vdXRwdXQuYWRkX3Jhd190b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGhpcy5fb3B0aW9ucy5jb21tYV9maXJzdCAmJiBjdXJyZW50X3Rva2VuLnByZXZpb3VzICYmIGN1cnJlbnRfdG9rZW4ucHJldmlvdXMudHlwZSA9PT0gVE9LRU4uQ09NTUEgJiZcbiAgICB0aGlzLl9vdXRwdXQuanVzdF9hZGRlZF9uZXdsaW5lKCkpIHtcbiAgICBpZiAodGhpcy5fb3V0cHV0LnByZXZpb3VzX2xpbmUubGFzdCgpID09PSAnLCcpIHtcbiAgICAgIHZhciBwb3BwZWQgPSB0aGlzLl9vdXRwdXQucHJldmlvdXNfbGluZS5wb3AoKTtcbiAgICAgIC8vIGlmIHRoZSBjb21tYSB3YXMgYWxyZWFkeSBhdCB0aGUgc3RhcnQgb2YgdGhlIGxpbmUsXG4gICAgICAvLyBwdWxsIGJhY2sgb250byB0aGF0IGxpbmUgYW5kIHJlcHJpbnQgdGhlIGluZGVudGF0aW9uXG4gICAgICBpZiAodGhpcy5fb3V0cHV0LnByZXZpb3VzX2xpbmUuaXNfZW1wdHkoKSkge1xuICAgICAgICB0aGlzLl9vdXRwdXQucHJldmlvdXNfbGluZS5wdXNoKHBvcHBlZCk7XG4gICAgICAgIHRoaXMuX291dHB1dC50cmltKHRydWUpO1xuICAgICAgICB0aGlzLl9vdXRwdXQuY3VycmVudF9saW5lLnBvcCgpO1xuICAgICAgICB0aGlzLl9vdXRwdXQudHJpbSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBhZGQgdGhlIGNvbW1hIGluIGZyb250IG9mIHRoZSBuZXh0IHRva2VuXG4gICAgICB0aGlzLnByaW50X3Rva2VuX2xpbmVfaW5kZW50YXRpb24oY3VycmVudF90b2tlbik7XG4gICAgICB0aGlzLl9vdXRwdXQuYWRkX3Rva2VuKCcsJyk7XG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB0aGlzLnByaW50X3Rva2VuX2xpbmVfaW5kZW50YXRpb24oY3VycmVudF90b2tlbik7XG4gIHRoaXMuX291dHB1dC5ub25fYnJlYWtpbmdfc3BhY2UgPSB0cnVlO1xuICB0aGlzLl9vdXRwdXQuYWRkX3Rva2VuKGN1cnJlbnRfdG9rZW4udGV4dCk7XG4gIGlmICh0aGlzLl9vdXRwdXQucHJldmlvdXNfdG9rZW5fd3JhcHBlZCkge1xuICAgIHRoaXMuX2ZsYWdzLm11bHRpbGluZV9mcmFtZSA9IHRydWU7XG4gIH1cbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmluZGVudCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9mbGFncy5pbmRlbnRhdGlvbl9sZXZlbCArPSAxO1xuICB0aGlzLl9vdXRwdXQuc2V0X2luZGVudCh0aGlzLl9mbGFncy5pbmRlbnRhdGlvbl9sZXZlbCwgdGhpcy5fZmxhZ3MuYWxpZ25tZW50KTtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmRlaW5kZW50ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9mbGFncy5pbmRlbnRhdGlvbl9sZXZlbCA+IDAgJiZcbiAgICAoKCF0aGlzLl9mbGFncy5wYXJlbnQpIHx8IHRoaXMuX2ZsYWdzLmluZGVudGF0aW9uX2xldmVsID4gdGhpcy5fZmxhZ3MucGFyZW50LmluZGVudGF0aW9uX2xldmVsKSkge1xuICAgIHRoaXMuX2ZsYWdzLmluZGVudGF0aW9uX2xldmVsIC09IDE7XG4gICAgdGhpcy5fb3V0cHV0LnNldF9pbmRlbnQodGhpcy5fZmxhZ3MuaW5kZW50YXRpb25fbGV2ZWwsIHRoaXMuX2ZsYWdzLmFsaWdubWVudCk7XG4gIH1cbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLnNldF9tb2RlID0gZnVuY3Rpb24obW9kZSkge1xuICBpZiAodGhpcy5fZmxhZ3MpIHtcbiAgICB0aGlzLl9mbGFnX3N0b3JlLnB1c2godGhpcy5fZmxhZ3MpO1xuICAgIHRoaXMuX3ByZXZpb3VzX2ZsYWdzID0gdGhpcy5fZmxhZ3M7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fcHJldmlvdXNfZmxhZ3MgPSB0aGlzLmNyZWF0ZV9mbGFncyhudWxsLCBtb2RlKTtcbiAgfVxuXG4gIHRoaXMuX2ZsYWdzID0gdGhpcy5jcmVhdGVfZmxhZ3ModGhpcy5fcHJldmlvdXNfZmxhZ3MsIG1vZGUpO1xuICB0aGlzLl9vdXRwdXQuc2V0X2luZGVudCh0aGlzLl9mbGFncy5pbmRlbnRhdGlvbl9sZXZlbCwgdGhpcy5fZmxhZ3MuYWxpZ25tZW50KTtcbn07XG5cblxuQmVhdXRpZmllci5wcm90b3R5cGUucmVzdG9yZV9tb2RlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9mbGFnX3N0b3JlLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLl9wcmV2aW91c19mbGFncyA9IHRoaXMuX2ZsYWdzO1xuICAgIHRoaXMuX2ZsYWdzID0gdGhpcy5fZmxhZ19zdG9yZS5wb3AoKTtcbiAgICBpZiAodGhpcy5fcHJldmlvdXNfZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQpIHtcbiAgICAgIHJlbW92ZV9yZWR1bmRhbnRfaW5kZW50YXRpb24odGhpcy5fb3V0cHV0LCB0aGlzLl9wcmV2aW91c19mbGFncyk7XG4gICAgfVxuICAgIHRoaXMuX291dHB1dC5zZXRfaW5kZW50KHRoaXMuX2ZsYWdzLmluZGVudGF0aW9uX2xldmVsLCB0aGlzLl9mbGFncy5hbGlnbm1lbnQpO1xuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5zdGFydF9vZl9vYmplY3RfcHJvcGVydHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2ZsYWdzLnBhcmVudC5tb2RlID09PSBNT0RFLk9iamVjdExpdGVyYWwgJiYgdGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQgJiYgKFxuICAgICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICc6JyAmJiB0aGlzLl9mbGFncy50ZXJuYXJ5X2RlcHRoID09PSAwKSB8fCAocmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgWydnZXQnLCAnc2V0J10pKSk7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5zdGFydF9vZl9zdGF0ZW1lbnQgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIHZhciBzdGFydCA9IGZhbHNlO1xuICBzdGFydCA9IHN0YXJ0IHx8IHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIFsndmFyJywgJ2xldCcsICdjb25zdCddKSAmJiBjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLldPUkQ7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgcmVzZXJ2ZWRfd29yZCh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLCAnZG8nKTtcbiAgc3RhcnQgPSBzdGFydCB8fCAoISh0aGlzLl9mbGFncy5wYXJlbnQubW9kZSA9PT0gTU9ERS5PYmplY3RMaXRlcmFsICYmIHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50KSkgJiYgcmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgbmV3bGluZV9yZXN0cmljdGVkX3Rva2VucykgJiYgIWN1cnJlbnRfdG9rZW4ubmV3bGluZXM7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgcmVzZXJ2ZWRfd29yZCh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLCAnZWxzZScpICYmXG4gICAgIShyZXNlcnZlZF93b3JkKGN1cnJlbnRfdG9rZW4sICdpZicpICYmICFjdXJyZW50X3Rva2VuLmNvbW1lbnRzX2JlZm9yZSk7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uRU5EX0VYUFIgJiYgKHRoaXMuX3ByZXZpb3VzX2ZsYWdzLm1vZGUgPT09IE1PREUuRm9ySW5pdGlhbGl6ZXIgfHwgdGhpcy5fcHJldmlvdXNfZmxhZ3MubW9kZSA9PT0gTU9ERS5Db25kaXRpb25hbCkpO1xuICBzdGFydCA9IHN0YXJ0IHx8ICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLldPUkQgJiYgdGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5CbG9ja1N0YXRlbWVudCAmJlxuICAgICF0aGlzLl9mbGFncy5pbl9jYXNlICYmXG4gICAgIShjdXJyZW50X3Rva2VuLnRleHQgPT09ICctLScgfHwgY3VycmVudF90b2tlbi50ZXh0ID09PSAnKysnKSAmJlxuICAgIHRoaXMuX2xhc3RfbGFzdF90ZXh0ICE9PSAnZnVuY3Rpb24nICYmXG4gICAgY3VycmVudF90b2tlbi50eXBlICE9PSBUT0tFTi5XT1JEICYmIGN1cnJlbnRfdG9rZW4udHlwZSAhPT0gVE9LRU4uUkVTRVJWRUQpO1xuICBzdGFydCA9IHN0YXJ0IHx8ICh0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLk9iamVjdExpdGVyYWwgJiYgKFxuICAgICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICc6JyAmJiB0aGlzLl9mbGFncy50ZXJuYXJ5X2RlcHRoID09PSAwKSB8fCByZXNlcnZlZF9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLCBbJ2dldCcsICdzZXQnXSkpKTtcblxuICBpZiAoc3RhcnQpIHtcbiAgICB0aGlzLnNldF9tb2RlKE1PREUuU3RhdGVtZW50KTtcbiAgICB0aGlzLmluZGVudCgpO1xuXG4gICAgdGhpcy5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbiwgdHJ1ZSk7XG5cbiAgICAvLyBJc3N1ZSAjMjc2OlxuICAgIC8vIElmIHN0YXJ0aW5nIGEgbmV3IHN0YXRlbWVudCB3aXRoIFtpZiwgZm9yLCB3aGlsZSwgZG9dLCBwdXNoIHRvIGEgbmV3IGxpbmUuXG4gICAgLy8gaWYgKGEpIGlmIChiKSBpZihjKSBkKCk7IGVsc2UgZSgpOyBlbHNlIGYoKTtcbiAgICBpZiAoIXRoaXMuc3RhcnRfb2Zfb2JqZWN0X3Byb3BlcnR5KCkpIHtcbiAgICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuLFxuICAgICAgICByZXNlcnZlZF9hcnJheShjdXJyZW50X3Rva2VuLCBbJ2RvJywgJ2ZvcicsICdpZicsICd3aGlsZSddKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmhhbmRsZV9zdGFydF9leHByID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikge1xuICAvLyBUaGUgY29uZGl0aW9uYWwgc3RhcnRzIHRoZSBzdGF0ZW1lbnQgaWYgYXBwcm9wcmlhdGUuXG4gIGlmICghdGhpcy5zdGFydF9vZl9zdGF0ZW1lbnQoY3VycmVudF90b2tlbikpIHtcbiAgICB0aGlzLmhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuKTtcbiAgfVxuXG4gIHZhciBuZXh0X21vZGUgPSBNT0RFLkV4cHJlc3Npb247XG4gIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICdbJykge1xuXG4gICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uV09SRCB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICcpJykge1xuICAgICAgLy8gdGhpcyBpcyBhcnJheSBpbmRleCBzcGVjaWZpZXIsIGJyZWFrIGltbWVkaWF0ZWx5XG4gICAgICAvLyBhW3hdLCBmbigpW3hdXG4gICAgICBpZiAocmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgbGluZV9zdGFydGVycykpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICAgICAgdGhpcy5zZXRfbW9kZShuZXh0X21vZGUpO1xuICAgICAgdGhpcy5pbmRlbnQoKTtcbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLnNwYWNlX2luX3BhcmVuKSB7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5leHRfbW9kZSA9IE1PREUuQXJyYXlMaXRlcmFsO1xuICAgIGlmIChpc19hcnJheSh0aGlzLl9mbGFncy5tb2RlKSkge1xuICAgICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJ1snIHx8XG4gICAgICAgICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICcsJyAmJiAodGhpcy5fbGFzdF9sYXN0X3RleHQgPT09ICddJyB8fCB0aGlzLl9sYXN0X2xhc3RfdGV4dCA9PT0gJ30nKSkpIHtcbiAgICAgICAgLy8gXSwgWyBnb2VzIHRvIG5ldyBsaW5lXG4gICAgICAgIC8vIH0sIFsgZ29lcyB0byBuZXcgbGluZVxuICAgICAgICBpZiAoIXRoaXMuX29wdGlvbnMua2VlcF9hcnJheV9pbmRlbnRhdGlvbikge1xuICAgICAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpbl9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUsIFtUT0tFTi5TVEFSVF9FWFBSLCBUT0tFTi5FTkRfRVhQUiwgVE9LRU4uV09SRCwgVE9LRU4uT1BFUkFUT1IsIFRPS0VOLkRPVF0pKSB7XG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uUkVTRVJWRUQpIHtcbiAgICAgIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICdmb3InKSB7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0aGlzLl9vcHRpb25zLnNwYWNlX2JlZm9yZV9jb25kaXRpb25hbDtcbiAgICAgICAgbmV4dF9tb2RlID0gTU9ERS5Gb3JJbml0aWFsaXplcjtcbiAgICAgIH0gZWxzZSBpZiAoaW5fYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0LCBbJ2lmJywgJ3doaWxlJywgJ3N3aXRjaCddKSkge1xuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdGhpcy5fb3B0aW9ucy5zcGFjZV9iZWZvcmVfY29uZGl0aW9uYWw7XG4gICAgICAgIG5leHRfbW9kZSA9IE1PREUuQ29uZGl0aW9uYWw7XG4gICAgICB9IGVsc2UgaWYgKGluX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3Rfd29yZCwgWydhd2FpdCcsICdhc3luYyddKSkge1xuICAgICAgICAvLyBTaG91bGQgYmUgYSBzcGFjZSBiZXR3ZWVuIGF3YWl0IGFuZCBhbiBJSUZFLCBvciBhc3luYyBhbmQgYW4gYXJyb3cgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJ2ltcG9ydCcgJiYgY3VycmVudF90b2tlbi53aGl0ZXNwYWNlX2JlZm9yZSA9PT0gJycpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpbl9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQsIGxpbmVfc3RhcnRlcnMpIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJ2NhdGNoJykge1xuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uRVFVQUxTIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uT1BFUkFUT1IpIHtcbiAgICAgIC8vIFN1cHBvcnQgb2YgdGhpcyBraW5kIG9mIG5ld2xpbmUgcHJlc2VydmF0aW9uLlxuICAgICAgLy8gYSA9IChiICYmXG4gICAgICAvLyAgICAgKGMgfHwgZCkpO1xuICAgICAgaWYgKCF0aGlzLnN0YXJ0X29mX29iamVjdF9wcm9wZXJ0eSgpKSB7XG4gICAgICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uV09SRCkge1xuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuXG4gICAgICAvLyBmdW5jdGlvbiBuYW1lKCkgdnMgZnVuY3Rpb24gbmFtZSAoKVxuICAgICAgLy8gZnVuY3Rpb24qIG5hbWUoKSB2cyBmdW5jdGlvbiogbmFtZSAoKVxuICAgICAgLy8gYXN5bmMgbmFtZSgpIHZzIGFzeW5jIG5hbWUgKClcbiAgICAgIC8vIEluIEVTNiwgeW91IGNhbiBhbHNvIGRlZmluZSB0aGUgbWV0aG9kIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0XG4gICAgICAvLyB2YXIgb2JqID0ge2E6IGZ1bmN0aW9uKCkge319XG4gICAgICAvLyBJdCBjYW4gYmUgYWJicmV2aWF0ZWRcbiAgICAgIC8vIHZhciBvYmogPSB7YSgpIHt9fVxuICAgICAgLy8gdmFyIG9iaiA9IHsgYSgpIHt9fSB2cyB2YXIgb2JqID0geyBhICgpIHt9fVxuICAgICAgLy8gdmFyIG9iaiA9IHsgKiBhKCkge319IHZzIHZhciBvYmogPSB7ICogYSAoKSB7fX1cbiAgICAgIHZhciBwZWVrX2JhY2tfdHdvID0gdGhpcy5fdG9rZW5zLnBlZWsoLTMpO1xuICAgICAgaWYgKHRoaXMuX29wdGlvbnMuc3BhY2VfYWZ0ZXJfbmFtZWRfZnVuY3Rpb24gJiYgcGVla19iYWNrX3R3bykge1xuICAgICAgICAvLyBwZWVrIHN0YXJ0cyBhdCBuZXh0IGNoYXJhY3RlciBzbyAtMSBpcyBjdXJyZW50IHRva2VuXG4gICAgICAgIHZhciBwZWVrX2JhY2tfdGhyZWUgPSB0aGlzLl90b2tlbnMucGVlaygtNCk7XG4gICAgICAgIGlmIChyZXNlcnZlZF9hcnJheShwZWVrX2JhY2tfdHdvLCBbJ2FzeW5jJywgJ2Z1bmN0aW9uJ10pIHx8XG4gICAgICAgICAgKHBlZWtfYmFja190d28udGV4dCA9PT0gJyonICYmIHJlc2VydmVkX2FycmF5KHBlZWtfYmFja190aHJlZSwgWydhc3luYycsICdmdW5jdGlvbiddKSkpIHtcbiAgICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLk9iamVjdExpdGVyYWwpIHtcbiAgICAgICAgICBpZiAoKHBlZWtfYmFja190d28udGV4dCA9PT0gJ3snIHx8IHBlZWtfYmFja190d28udGV4dCA9PT0gJywnKSB8fFxuICAgICAgICAgICAgKHBlZWtfYmFja190d28udGV4dCA9PT0gJyonICYmIChwZWVrX2JhY2tfdGhyZWUudGV4dCA9PT0gJ3snIHx8IHBlZWtfYmFja190aHJlZS50ZXh0ID09PSAnLCcpKSkge1xuICAgICAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLnBhcmVudCAmJiB0aGlzLl9mbGFncy5wYXJlbnQuY2xhc3Nfc3RhcnRfYmxvY2spIHtcbiAgICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdXBwb3J0IHByZXNlcnZpbmcgd3JhcHBlZCBhcnJvdyBmdW5jdGlvbiBleHByZXNzaW9uc1xuICAgICAgLy8gYS5iKCdjJyxcbiAgICAgIC8vICAgICAoKSA9PiBkLmVcbiAgICAgIC8vIClcbiAgICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuKTtcbiAgICB9XG5cbiAgICAvLyBmdW5jdGlvbigpIHZzIGZ1bmN0aW9uICgpXG4gICAgLy8geWllbGQqKCkgdnMgeWllbGQqICgpXG4gICAgLy8gZnVuY3Rpb24qKCkgdnMgZnVuY3Rpb24qICgpXG4gICAgaWYgKCh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlJFU0VSVkVEICYmICh0aGlzLl9mbGFncy5sYXN0X3dvcmQgPT09ICdmdW5jdGlvbicgfHwgdGhpcy5fZmxhZ3MubGFzdF93b3JkID09PSAndHlwZW9mJykpIHx8XG4gICAgICAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnKicgJiZcbiAgICAgICAgKGluX2FycmF5KHRoaXMuX2xhc3RfbGFzdF90ZXh0LCBbJ2Z1bmN0aW9uJywgJ3lpZWxkJ10pIHx8XG4gICAgICAgICAgKHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuT2JqZWN0TGl0ZXJhbCAmJiBpbl9hcnJheSh0aGlzLl9sYXN0X2xhc3RfdGV4dCwgWyd7JywgJywnXSkpKSkpIHtcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0aGlzLl9vcHRpb25zLnNwYWNlX2FmdGVyX2Fub25fZnVuY3Rpb247XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJzsnIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RBUlRfQkxPQ0spIHtcbiAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVORF9FWFBSIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RBUlRfRVhQUiB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVORF9CTE9DSyB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICcuJyB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkNPTU1BKSB7XG4gICAgLy8gZG8gbm90aGluZyBvbiAoKCBhbmQgKSggYW5kIF1bIGFuZCBdKCBhbmQgLihcbiAgICAvLyBUT0RPOiBDb25zaWRlciB3aGV0aGVyIGZvcmNpbmcgdGhpcyBpcyByZXF1aXJlZC4gIFJldmlldyBmYWlsaW5nIHRlc3RzIHdoZW4gcmVtb3ZlZC5cbiAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbiwgY3VycmVudF90b2tlbi5uZXdsaW5lcyk7XG4gIH1cblxuICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICB0aGlzLnNldF9tb2RlKG5leHRfbW9kZSk7XG4gIGlmICh0aGlzLl9vcHRpb25zLnNwYWNlX2luX3BhcmVuKSB7XG4gICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gIH1cblxuICAvLyBJbiBhbGwgY2FzZXMsIGlmIHdlIG5ld2xpbmUgd2hpbGUgaW5zaWRlIGFuIGV4cHJlc3Npb24gaXQgc2hvdWxkIGJlIGluZGVudGVkLlxuICB0aGlzLmluZGVudCgpO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX2VuZF9leHByID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikge1xuICAvLyBzdGF0ZW1lbnRzIGluc2lkZSBleHByZXNzaW9ucyBhcmUgbm90IHZhbGlkIHN5bnRheCwgYnV0Li4uXG4gIC8vIHN0YXRlbWVudHMgbXVzdCBhbGwgYmUgY2xvc2VkIHdoZW4gdGhlaXIgY29udGFpbmVyIGNsb3Nlc1xuICB3aGlsZSAodGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQpIHtcbiAgICB0aGlzLnJlc3RvcmVfbW9kZSgpO1xuICB9XG5cbiAgdGhpcy5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG5cbiAgaWYgKHRoaXMuX2ZsYWdzLm11bHRpbGluZV9mcmFtZSkge1xuICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuLFxuICAgICAgY3VycmVudF90b2tlbi50ZXh0ID09PSAnXScgJiYgaXNfYXJyYXkodGhpcy5fZmxhZ3MubW9kZSkgJiYgIXRoaXMuX29wdGlvbnMua2VlcF9hcnJheV9pbmRlbnRhdGlvbik7XG4gIH1cblxuICBpZiAodGhpcy5fb3B0aW9ucy5zcGFjZV9pbl9wYXJlbikge1xuICAgIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNUQVJUX0VYUFIgJiYgIXRoaXMuX29wdGlvbnMuc3BhY2VfaW5fZW1wdHlfcGFyZW4pIHtcbiAgICAgIC8vICgpIFtdIG5vIGlubmVyIHNwYWNlIGluIGVtcHR5IHBhcmVucyBsaWtlIHRoZXNlLCBldmVyLCByZWYgIzMyMFxuICAgICAgdGhpcy5fb3V0cHV0LnRyaW0oKTtcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgfVxuICB9XG4gIHRoaXMuZGVpbmRlbnQoKTtcbiAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgdGhpcy5yZXN0b3JlX21vZGUoKTtcblxuICByZW1vdmVfcmVkdW5kYW50X2luZGVudGF0aW9uKHRoaXMuX291dHB1dCwgdGhpcy5fcHJldmlvdXNfZmxhZ3MpO1xuXG4gIC8vIGRvIHt9IHdoaWxlICgpIC8vIG5vIHN0YXRlbWVudCByZXF1aXJlZCBhZnRlclxuICBpZiAodGhpcy5fZmxhZ3MuZG9fd2hpbGUgJiYgdGhpcy5fcHJldmlvdXNfZmxhZ3MubW9kZSA9PT0gTU9ERS5Db25kaXRpb25hbCkge1xuICAgIHRoaXMuX3ByZXZpb3VzX2ZsYWdzLm1vZGUgPSBNT0RFLkV4cHJlc3Npb247XG4gICAgdGhpcy5fZmxhZ3MuZG9fYmxvY2sgPSBmYWxzZTtcbiAgICB0aGlzLl9mbGFncy5kb193aGlsZSA9IGZhbHNlO1xuXG4gIH1cbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmhhbmRsZV9zdGFydF9ibG9jayA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgdGhpcy5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG5cbiAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIE9iamVjdExpdGVyYWxcbiAgdmFyIG5leHRfdG9rZW4gPSB0aGlzLl90b2tlbnMucGVlaygpO1xuICB2YXIgc2Vjb25kX3Rva2VuID0gdGhpcy5fdG9rZW5zLnBlZWsoMSk7XG4gIGlmICh0aGlzLl9mbGFncy5sYXN0X3dvcmQgPT09ICdzd2l0Y2gnICYmIHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uRU5EX0VYUFIpIHtcbiAgICB0aGlzLnNldF9tb2RlKE1PREUuQmxvY2tTdGF0ZW1lbnQpO1xuICAgIHRoaXMuX2ZsYWdzLmluX2Nhc2Vfc3RhdGVtZW50ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5jYXNlX2JvZHkpIHtcbiAgICB0aGlzLnNldF9tb2RlKE1PREUuQmxvY2tTdGF0ZW1lbnQpO1xuICB9IGVsc2UgaWYgKHNlY29uZF90b2tlbiAmJiAoXG4gICAgICAoaW5fYXJyYXkoc2Vjb25kX3Rva2VuLnRleHQsIFsnOicsICcsJ10pICYmIGluX2FycmF5KG5leHRfdG9rZW4udHlwZSwgW1RPS0VOLlNUUklORywgVE9LRU4uV09SRCwgVE9LRU4uUkVTRVJWRURdKSkgfHxcbiAgICAgIChpbl9hcnJheShuZXh0X3Rva2VuLnRleHQsIFsnZ2V0JywgJ3NldCcsICcuLi4nXSkgJiYgaW5fYXJyYXkoc2Vjb25kX3Rva2VuLnR5cGUsIFtUT0tFTi5XT1JELCBUT0tFTi5SRVNFUlZFRF0pKVxuICAgICkpIHtcbiAgICAvLyBXZSBkb24ndCBzdXBwb3J0IFR5cGVTY3JpcHQsYnV0IHdlIGRpZG4ndCBicmVhayBpdCBmb3IgYSB2ZXJ5IGxvbmcgdGltZS5cbiAgICAvLyBXZSdsbCB0cnkgdG8ga2VlcCBub3QgYnJlYWtpbmcgaXQuXG4gICAgaWYgKGluX2FycmF5KHRoaXMuX2xhc3RfbGFzdF90ZXh0LCBbJ2NsYXNzJywgJ2ludGVyZmFjZSddKSAmJiAhaW5fYXJyYXkoc2Vjb25kX3Rva2VuLnRleHQsIFsnOicsICcsJ10pKSB7XG4gICAgICB0aGlzLnNldF9tb2RlKE1PREUuQmxvY2tTdGF0ZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldF9tb2RlKE1PREUuT2JqZWN0TGl0ZXJhbCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uT1BFUkFUT1IgJiYgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnPT4nKSB7XG4gICAgLy8gYXJyb3cgZnVuY3Rpb246IChwYXJhbTEsIHBhcmFtTikgPT4geyBzdGF0ZW1lbnRzIH1cbiAgICB0aGlzLnNldF9tb2RlKE1PREUuQmxvY2tTdGF0ZW1lbnQpO1xuICB9IGVsc2UgaWYgKGluX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSwgW1RPS0VOLkVRVUFMUywgVE9LRU4uU1RBUlRfRVhQUiwgVE9LRU4uQ09NTUEsIFRPS0VOLk9QRVJBVE9SXSkgfHxcbiAgICByZXNlcnZlZF9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLCBbJ3JldHVybicsICd0aHJvdycsICdpbXBvcnQnLCAnZGVmYXVsdCddKVxuICApIHtcbiAgICAvLyBEZXRlY3Rpbmcgc2hvcnRoYW5kIGZ1bmN0aW9uIHN5bnRheCBpcyBkaWZmaWN1bHQgYnkgc2Nhbm5pbmcgZm9yd2FyZCxcbiAgICAvLyAgICAgc28gY2hlY2sgdGhlIHN1cnJvdW5kaW5nIGNvbnRleHQuXG4gICAgLy8gSWYgdGhlIGJsb2NrIGlzIGJlaW5nIHJldHVybmVkLCBpbXBvcnRlZCwgZXhwb3J0IGRlZmF1bHQsIHBhc3NlZCBhcyBhcmcsXG4gICAgLy8gICAgIGFzc2lnbmVkIHdpdGggPSBvciBhc3NpZ25lZCBpbiBhIG5lc3RlZCBvYmplY3QsIHRyZWF0IGFzIGFuIE9iamVjdExpdGVyYWwuXG4gICAgdGhpcy5zZXRfbW9kZShNT0RFLk9iamVjdExpdGVyYWwpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc2V0X21vZGUoTU9ERS5CbG9ja1N0YXRlbWVudCk7XG4gIH1cblxuICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbikge1xuICAgIGlmIChyZXNlcnZlZF9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnByZXZpb3VzLCBbJ2NsYXNzJywgJ2V4dGVuZHMnXSkpIHtcbiAgICAgIHRoaXMuX2ZsYWdzLmNsYXNzX3N0YXJ0X2Jsb2NrID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgZW1wdHlfYnJhY2VzID0gIW5leHRfdG9rZW4uY29tbWVudHNfYmVmb3JlICYmIG5leHRfdG9rZW4udGV4dCA9PT0gJ30nO1xuICB2YXIgZW1wdHlfYW5vbnltb3VzX2Z1bmN0aW9uID0gZW1wdHlfYnJhY2VzICYmIHRoaXMuX2ZsYWdzLmxhc3Rfd29yZCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uRU5EX0VYUFI7XG5cbiAgaWYgKHRoaXMuX29wdGlvbnMuYnJhY2VfcHJlc2VydmVfaW5saW5lKSAvLyBjaGVjayBmb3IgaW5saW5lLCBzZXQgaW5saW5lX2ZyYW1lIGlmIHNvXG4gIHtcbiAgICAvLyBzZWFyY2ggZm9yd2FyZCBmb3IgYSBuZXdsaW5lIHdhbnRlZCBpbnNpZGUgdGhpcyBibG9ja1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGNoZWNrX3Rva2VuID0gbnVsbDtcbiAgICB0aGlzLl9mbGFncy5pbmxpbmVfZnJhbWUgPSB0cnVlO1xuICAgIGRvIHtcbiAgICAgIGluZGV4ICs9IDE7XG4gICAgICBjaGVja190b2tlbiA9IHRoaXMuX3Rva2Vucy5wZWVrKGluZGV4IC0gMSk7XG4gICAgICBpZiAoY2hlY2tfdG9rZW4ubmV3bGluZXMpIHtcbiAgICAgICAgdGhpcy5fZmxhZ3MuaW5saW5lX2ZyYW1lID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKGNoZWNrX3Rva2VuLnR5cGUgIT09IFRPS0VOLkVPRiAmJlxuICAgICAgIShjaGVja190b2tlbi50eXBlID09PSBUT0tFTi5FTkRfQkxPQ0sgJiYgY2hlY2tfdG9rZW4ub3BlbmVkID09PSBjdXJyZW50X3Rva2VuKSk7XG4gIH1cblxuICBpZiAoKHRoaXMuX29wdGlvbnMuYnJhY2Vfc3R5bGUgPT09IFwiZXhwYW5kXCIgfHxcbiAgICAgICh0aGlzLl9vcHRpb25zLmJyYWNlX3N0eWxlID09PSBcIm5vbmVcIiAmJiBjdXJyZW50X3Rva2VuLm5ld2xpbmVzKSkgJiZcbiAgICAhdGhpcy5fZmxhZ3MuaW5saW5lX2ZyYW1lKSB7XG4gICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSAhPT0gVE9LRU4uT1BFUkFUT1IgJiZcbiAgICAgIChlbXB0eV9hbm9ueW1vdXNfZnVuY3Rpb24gfHxcbiAgICAgICAgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5FUVVBTFMgfHxcbiAgICAgICAgKHJlc2VydmVkX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4sIHNwZWNpYWxfd29yZHMpICYmIHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCAhPT0gJ2Vsc2UnKSkpIHtcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIHRydWUpO1xuICAgIH1cbiAgfSBlbHNlIHsgLy8gY29sbGFwc2UgfHwgaW5saW5lX2ZyYW1lXG4gICAgaWYgKGlzX2FycmF5KHRoaXMuX3ByZXZpb3VzX2ZsYWdzLm1vZGUpICYmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNUQVJUX0VYUFIgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5DT01NQSkpIHtcbiAgICAgIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkNPTU1BIHx8IHRoaXMuX29wdGlvbnMuc3BhY2VfaW5fcGFyZW4pIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkNPTU1BIHx8ICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNUQVJUX0VYUFIgJiYgdGhpcy5fZmxhZ3MuaW5saW5lX2ZyYW1lKSkge1xuICAgICAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbik7XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzX2ZsYWdzLm11bHRpbGluZV9mcmFtZSA9IHRoaXMuX3ByZXZpb3VzX2ZsYWdzLm11bHRpbGluZV9mcmFtZSB8fCB0aGlzLl9mbGFncy5tdWx0aWxpbmVfZnJhbWU7XG4gICAgICAgIHRoaXMuX2ZsYWdzLm11bHRpbGluZV9mcmFtZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlICE9PSBUT0tFTi5PUEVSQVRPUiAmJiB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgIT09IFRPS0VOLlNUQVJUX0VYUFIpIHtcbiAgICAgIGlmIChpbl9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUsIFtUT0tFTi5TVEFSVF9CTE9DSywgVE9LRU4uU0VNSUNPTE9OXSkgJiYgIXRoaXMuX2ZsYWdzLmlubGluZV9mcmFtZSkge1xuICAgICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICB0aGlzLmluZGVudCgpO1xuXG4gIC8vIEV4Y2VwdCBmb3Igc3BlY2lmaWMgY2FzZXMsIG9wZW4gYnJhY2VzIGFyZSBmb2xsb3dlZCBieSBhIG5ldyBsaW5lLlxuICBpZiAoIWVtcHR5X2JyYWNlcyAmJiAhKHRoaXMuX29wdGlvbnMuYnJhY2VfcHJlc2VydmVfaW5saW5lICYmIHRoaXMuX2ZsYWdzLmlubGluZV9mcmFtZSkpIHtcbiAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX2VuZF9ibG9jayA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgLy8gc3RhdGVtZW50cyBtdXN0IGFsbCBiZSBjbG9zZWQgd2hlbiB0aGVpciBjb250YWluZXIgY2xvc2VzXG4gIHRoaXMuaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4pO1xuXG4gIHdoaWxlICh0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLlN0YXRlbWVudCkge1xuICAgIHRoaXMucmVzdG9yZV9tb2RlKCk7XG4gIH1cblxuICB2YXIgZW1wdHlfYnJhY2VzID0gdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TVEFSVF9CTE9DSztcblxuICBpZiAodGhpcy5fZmxhZ3MuaW5saW5lX2ZyYW1lICYmICFlbXB0eV9icmFjZXMpIHsgLy8gdHJ5IGlubGluZV9mcmFtZSAob25seSBzZXQgaWYgdGhpcy5fb3B0aW9ucy5icmFjZXMtcHJlc2VydmUtaW5saW5lKSBmaXJzdFxuICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRoaXMuX29wdGlvbnMuYnJhY2Vfc3R5bGUgPT09IFwiZXhwYW5kXCIpIHtcbiAgICBpZiAoIWVtcHR5X2JyYWNlcykge1xuICAgICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIHNraXAge31cbiAgICBpZiAoIWVtcHR5X2JyYWNlcykge1xuICAgICAgaWYgKGlzX2FycmF5KHRoaXMuX2ZsYWdzLm1vZGUpICYmIHRoaXMuX29wdGlvbnMua2VlcF9hcnJheV9pbmRlbnRhdGlvbikge1xuICAgICAgICAvLyB3ZSBSRUFMTFkgbmVlZCBhIG5ld2xpbmUgaGVyZSwgYnV0IG5ld2xpbmVyIHdvdWxkIHNraXAgdGhhdFxuICAgICAgICB0aGlzLl9vcHRpb25zLmtlZXBfYXJyYXlfaW5kZW50YXRpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gICAgICAgIHRoaXMuX29wdGlvbnMua2VlcF9hcnJheV9pbmRlbnRhdGlvbiA9IHRydWU7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0aGlzLnJlc3RvcmVfbW9kZSgpO1xuICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX3dvcmQgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIGlmIChjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLlJFU0VSVkVEKSB7XG4gICAgaWYgKGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgWydzZXQnLCAnZ2V0J10pICYmIHRoaXMuX2ZsYWdzLm1vZGUgIT09IE1PREUuT2JqZWN0TGl0ZXJhbCkge1xuICAgICAgY3VycmVudF90b2tlbi50eXBlID0gVE9LRU4uV09SRDtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ2ltcG9ydCcgJiYgaW5fYXJyYXkodGhpcy5fdG9rZW5zLnBlZWsoKS50ZXh0LCBbJygnLCAnLiddKSkge1xuICAgICAgY3VycmVudF90b2tlbi50eXBlID0gVE9LRU4uV09SRDtcbiAgICB9IGVsc2UgaWYgKGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgWydhcycsICdmcm9tJ10pICYmICF0aGlzLl9mbGFncy5pbXBvcnRfYmxvY2spIHtcbiAgICAgIGN1cnJlbnRfdG9rZW4udHlwZSA9IFRPS0VOLldPUkQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLk9iamVjdExpdGVyYWwpIHtcbiAgICAgIHZhciBuZXh0X3Rva2VuID0gdGhpcy5fdG9rZW5zLnBlZWsoKTtcbiAgICAgIGlmIChuZXh0X3Rva2VuLnRleHQgPT09ICc6Jykge1xuICAgICAgICBjdXJyZW50X3Rva2VuLnR5cGUgPSBUT0tFTi5XT1JEO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnN0YXJ0X29mX3N0YXRlbWVudChjdXJyZW50X3Rva2VuKSkge1xuICAgIC8vIFRoZSBjb25kaXRpb25hbCBzdGFydHMgdGhlIHN0YXRlbWVudCBpZiBhcHByb3ByaWF0ZS5cbiAgICBpZiAocmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgWyd2YXInLCAnbGV0JywgJ2NvbnN0J10pICYmIGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uV09SRCkge1xuICAgICAgdGhpcy5fZmxhZ3MuZGVjbGFyYXRpb25fc3RhdGVtZW50ID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi5uZXdsaW5lcyAmJiAhaXNfZXhwcmVzc2lvbih0aGlzLl9mbGFncy5tb2RlKSAmJlxuICAgICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgIT09IFRPS0VOLk9QRVJBVE9SIHx8ICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICctLScgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnKysnKSkgJiZcbiAgICB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgIT09IFRPS0VOLkVRVUFMUyAmJlxuICAgICh0aGlzLl9vcHRpb25zLnByZXNlcnZlX25ld2xpbmVzIHx8ICFyZXNlcnZlZF9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLCBbJ3ZhcicsICdsZXQnLCAnY29uc3QnLCAnc2V0JywgJ2dldCddKSkpIHtcbiAgICB0aGlzLmhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuKTtcbiAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9mbGFncy5kb19ibG9jayAmJiAhdGhpcy5fZmxhZ3MuZG9fd2hpbGUpIHtcbiAgICBpZiAocmVzZXJ2ZWRfd29yZChjdXJyZW50X3Rva2VuLCAnd2hpbGUnKSkge1xuICAgICAgLy8gZG8ge30gIyMgd2hpbGUgKClcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgdGhpcy5fZmxhZ3MuZG9fd2hpbGUgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkbyB7fSBzaG91bGQgYWx3YXlzIGhhdmUgd2hpbGUgYXMgdGhlIG5leHQgd29yZC5cbiAgICAgIC8vIGlmIHdlIGRvbid0IHNlZSB0aGUgZXhwZWN0ZWQgd2hpbGUsIHJlY292ZXJcbiAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgICAgdGhpcy5fZmxhZ3MuZG9fYmxvY2sgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiBtYXkgYmUgZm9sbG93ZWQgYnkgZWxzZSwgb3Igbm90XG4gIC8vIEJhcmUvaW5saW5lIGlmcyBhcmUgdHJpY2t5XG4gIC8vIE5lZWQgdG8gdW53aW5kIHRoZSBtb2RlcyBjb3JyZWN0bHk6IGlmIChhKSBpZiAoYikgYygpOyBlbHNlIGQoKTsgZWxzZSBlKCk7XG4gIGlmICh0aGlzLl9mbGFncy5pZl9ibG9jaykge1xuICAgIGlmICghdGhpcy5fZmxhZ3MuZWxzZV9ibG9jayAmJiByZXNlcnZlZF93b3JkKGN1cnJlbnRfdG9rZW4sICdlbHNlJykpIHtcbiAgICAgIHRoaXMuX2ZsYWdzLmVsc2VfYmxvY2sgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAodGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQpIHtcbiAgICAgICAgdGhpcy5yZXN0b3JlX21vZGUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZsYWdzLmlmX2Jsb2NrID0gZmFsc2U7XG4gICAgICB0aGlzLl9mbGFncy5lbHNlX2Jsb2NrID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuX2ZsYWdzLmluX2Nhc2Vfc3RhdGVtZW50ICYmIHJlc2VydmVkX2FycmF5KGN1cnJlbnRfdG9rZW4sIFsnY2FzZScsICdkZWZhdWx0J10pKSB7XG4gICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gICAgaWYgKCF0aGlzLl9mbGFncy5jYXNlX2Jsb2NrICYmICh0aGlzLl9mbGFncy5jYXNlX2JvZHkgfHwgdGhpcy5fb3B0aW9ucy5qc2xpbnRfaGFwcHkpKSB7XG4gICAgICAvLyBzd2l0Y2ggY2FzZXMgZm9sbG93aW5nIG9uZSBhbm90aGVyXG4gICAgICB0aGlzLmRlaW5kZW50KCk7XG4gICAgfVxuICAgIHRoaXMuX2ZsYWdzLmNhc2VfYm9keSA9IGZhbHNlO1xuXG4gICAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgICB0aGlzLl9mbGFncy5pbl9jYXNlID0gdHJ1ZTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5DT01NQSB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNUQVJUX0VYUFIgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5FUVVBTFMgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5PUEVSQVRPUikge1xuICAgIGlmICghdGhpcy5zdGFydF9vZl9vYmplY3RfcHJvcGVydHkoKSAmJiAhKFxuICAgICAgICAvLyBzdGFydCBvZiBvYmplY3QgcHJvcGVydHkgaXMgZGlmZmVyZW50IGZvciBudW1lcmljIHZhbHVlcyB3aXRoICsvLSBwcmVmaXggb3BlcmF0b3JzXG4gICAgICAgIGluX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCwgWycrJywgJy0nXSkgJiYgdGhpcy5fbGFzdF9sYXN0X3RleHQgPT09ICc6JyAmJiB0aGlzLl9mbGFncy5wYXJlbnQubW9kZSA9PT0gTU9ERS5PYmplY3RMaXRlcmFsKSkge1xuICAgICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyZXNlcnZlZF93b3JkKGN1cnJlbnRfdG9rZW4sICdmdW5jdGlvbicpKSB7XG4gICAgaWYgKGluX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCwgWyd9JywgJzsnXSkgfHxcbiAgICAgICh0aGlzLl9vdXRwdXQuanVzdF9hZGRlZF9uZXdsaW5lKCkgJiYgIShpbl9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQsIFsnKCcsICdbJywgJ3snLCAnOicsICc9JywgJywnXSkgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5PUEVSQVRPUikpKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgdGhlcmUgaXMgYSBuaWNlIGNsZWFuIHNwYWNlIG9mIGF0IGxlYXN0IG9uZSBibGFuayBsaW5lXG4gICAgICAvLyBiZWZvcmUgYSBuZXcgZnVuY3Rpb24gZGVmaW5pdGlvblxuICAgICAgaWYgKCF0aGlzLl9vdXRwdXQuanVzdF9hZGRlZF9ibGFua2xpbmUoKSAmJiAhY3VycmVudF90b2tlbi5jb21tZW50c19iZWZvcmUpIHtcbiAgICAgICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gICAgICAgIHRoaXMucHJpbnRfbmV3bGluZSh0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uUkVTRVJWRUQgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5XT1JEKSB7XG4gICAgICBpZiAocmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgWydnZXQnLCAnc2V0JywgJ25ldycsICdleHBvcnQnXSkgfHxcbiAgICAgICAgcmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgbmV3bGluZV9yZXN0cmljdGVkX3Rva2VucykpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHJlc2VydmVkX3dvcmQodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgJ2RlZmF1bHQnKSAmJiB0aGlzLl9sYXN0X2xhc3RfdGV4dCA9PT0gJ2V4cG9ydCcpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJ2RlY2xhcmUnKSB7XG4gICAgICAgIC8vIGFjY29tb2RhdGVzIFR5cGVzY3JpcHQgZGVjbGFyZSBmdW5jdGlvbiBmb3JtYXR0aW5nXG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLk9QRVJBVE9SIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJz0nKSB7XG4gICAgICAvLyBmb28gPSBmdW5jdGlvblxuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgfSBlbHNlIGlmICghdGhpcy5fZmxhZ3MubXVsdGlsaW5lX2ZyYW1lICYmIChpc19leHByZXNzaW9uKHRoaXMuX2ZsYWdzLm1vZGUpIHx8IGlzX2FycmF5KHRoaXMuX2ZsYWdzLm1vZGUpKSkge1xuICAgICAgLy8gKGZ1bmN0aW9uXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgIH1cblxuICAgIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gICAgdGhpcy5fZmxhZ3MubGFzdF93b3JkID0gY3VycmVudF90b2tlbi50ZXh0O1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwcmVmaXggPSAnTk9ORSc7XG5cbiAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uRU5EX0JMT0NLKSB7XG5cbiAgICBpZiAodGhpcy5fcHJldmlvdXNfZmxhZ3MuaW5saW5lX2ZyYW1lKSB7XG4gICAgICBwcmVmaXggPSAnU1BBQ0UnO1xuICAgIH0gZWxzZSBpZiAoIXJlc2VydmVkX2FycmF5KGN1cnJlbnRfdG9rZW4sIFsnZWxzZScsICdjYXRjaCcsICdmaW5hbGx5JywgJ2Zyb20nXSkpIHtcbiAgICAgIHByZWZpeCA9ICdORVdMSU5FJztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuX29wdGlvbnMuYnJhY2Vfc3R5bGUgPT09IFwiZXhwYW5kXCIgfHxcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5icmFjZV9zdHlsZSA9PT0gXCJlbmQtZXhwYW5kXCIgfHxcbiAgICAgICAgKHRoaXMuX29wdGlvbnMuYnJhY2Vfc3R5bGUgPT09IFwibm9uZVwiICYmIGN1cnJlbnRfdG9rZW4ubmV3bGluZXMpKSB7XG4gICAgICAgIHByZWZpeCA9ICdORVdMSU5FJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZWZpeCA9ICdTUEFDRSc7XG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNFTUlDT0xPTiAmJiB0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLkJsb2NrU3RhdGVtZW50KSB7XG4gICAgLy8gVE9ETzogU2hvdWxkIHRoaXMgYmUgZm9yIFNUQVRFTUVOVCBhcyB3ZWxsP1xuICAgIHByZWZpeCA9ICdORVdMSU5FJztcbiAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNFTUlDT0xPTiAmJiBpc19leHByZXNzaW9uKHRoaXMuX2ZsYWdzLm1vZGUpKSB7XG4gICAgcHJlZml4ID0gJ1NQQUNFJztcbiAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNUUklORykge1xuICAgIHByZWZpeCA9ICdORVdMSU5FJztcbiAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlJFU0VSVkVEIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uV09SRCB8fFxuICAgICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICcqJyAmJlxuICAgICAgKGluX2FycmF5KHRoaXMuX2xhc3RfbGFzdF90ZXh0LCBbJ2Z1bmN0aW9uJywgJ3lpZWxkJ10pIHx8XG4gICAgICAgICh0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLk9iamVjdExpdGVyYWwgJiYgaW5fYXJyYXkodGhpcy5fbGFzdF9sYXN0X3RleHQsIFsneycsICcsJ10pKSkpKSB7XG4gICAgcHJlZml4ID0gJ1NQQUNFJztcbiAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNUQVJUX0JMT0NLKSB7XG4gICAgaWYgKHRoaXMuX2ZsYWdzLmlubGluZV9mcmFtZSkge1xuICAgICAgcHJlZml4ID0gJ1NQQUNFJztcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlZml4ID0gJ05FV0xJTkUnO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVORF9FWFBSKSB7XG4gICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgcHJlZml4ID0gJ05FV0xJTkUnO1xuICB9XG5cbiAgaWYgKHJlc2VydmVkX2FycmF5KGN1cnJlbnRfdG9rZW4sIGxpbmVfc3RhcnRlcnMpICYmIHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCAhPT0gJyknKSB7XG4gICAgaWYgKHRoaXMuX2ZsYWdzLmlubGluZV9mcmFtZSB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICdlbHNlJyB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICdleHBvcnQnKSB7XG4gICAgICBwcmVmaXggPSAnU1BBQ0UnO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmVmaXggPSAnTkVXTElORSc7XG4gICAgfVxuXG4gIH1cblxuICBpZiAocmVzZXJ2ZWRfYXJyYXkoY3VycmVudF90b2tlbiwgWydlbHNlJywgJ2NhdGNoJywgJ2ZpbmFsbHknXSkpIHtcbiAgICBpZiAoKCEodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5FTkRfQkxPQ0sgJiYgdGhpcy5fcHJldmlvdXNfZmxhZ3MubW9kZSA9PT0gTU9ERS5CbG9ja1N0YXRlbWVudCkgfHxcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5icmFjZV9zdHlsZSA9PT0gXCJleHBhbmRcIiB8fFxuICAgICAgICB0aGlzLl9vcHRpb25zLmJyYWNlX3N0eWxlID09PSBcImVuZC1leHBhbmRcIiB8fFxuICAgICAgICAodGhpcy5fb3B0aW9ucy5icmFjZV9zdHlsZSA9PT0gXCJub25lXCIgJiYgY3VycmVudF90b2tlbi5uZXdsaW5lcykpICYmXG4gICAgICAhdGhpcy5fZmxhZ3MuaW5saW5lX2ZyYW1lKSB7XG4gICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fb3V0cHV0LnRyaW0odHJ1ZSk7XG4gICAgICB2YXIgbGluZSA9IHRoaXMuX291dHB1dC5jdXJyZW50X2xpbmU7XG4gICAgICAvLyBJZiB3ZSB0cmltbWVkIGFuZCB0aGVyZSdzIHNvbWV0aGluZyBvdGhlciB0aGFuIGEgY2xvc2UgYmxvY2sgYmVmb3JlIHVzXG4gICAgICAvLyBwdXQgYSBuZXdsaW5lIGJhY2sgaW4uICBIYW5kbGVzICd9IC8vIGNvbW1lbnQnIHNjZW5hcmlvLlxuICAgICAgaWYgKGxpbmUubGFzdCgpICE9PSAnfScpIHtcbiAgICAgICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJlZml4ID09PSAnTkVXTElORScpIHtcbiAgICBpZiAocmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgc3BlY2lhbF93b3JkcykpIHtcbiAgICAgIC8vIG5vIG5ld2xpbmUgYmV0d2VlbiAncmV0dXJuIG5ubidcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnZGVjbGFyZScgJiYgcmVzZXJ2ZWRfYXJyYXkoY3VycmVudF90b2tlbiwgWyd2YXInLCAnbGV0JywgJ2NvbnN0J10pKSB7XG4gICAgICAvLyBhY2NvbW9kYXRlcyBUeXBlc2NyaXB0IGRlY2xhcmUgZm9ybWF0dGluZ1xuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgIT09IFRPS0VOLkVORF9FWFBSKSB7XG4gICAgICBpZiAoKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSAhPT0gVE9LRU4uU1RBUlRfRVhQUiB8fCAhcmVzZXJ2ZWRfYXJyYXkoY3VycmVudF90b2tlbiwgWyd2YXInLCAnbGV0JywgJ2NvbnN0J10pKSAmJiB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgIT09ICc6Jykge1xuICAgICAgICAvLyBubyBuZWVkIHRvIGZvcmNlIG5ld2xpbmUgb24gJ3Zhcic6IGZvciAodmFyIHggPSAwLi4uKVxuICAgICAgICBpZiAocmVzZXJ2ZWRfd29yZChjdXJyZW50X3Rva2VuLCAnaWYnKSAmJiByZXNlcnZlZF93b3JkKGN1cnJlbnRfdG9rZW4ucHJldmlvdXMsICdlbHNlJykpIHtcbiAgICAgICAgICAvLyBubyBuZXdsaW5lIGZvciB9IGVsc2UgaWYge1xuICAgICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZXNlcnZlZF9hcnJheShjdXJyZW50X3Rva2VuLCBsaW5lX3N0YXJ0ZXJzKSAmJiB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgIT09ICcpJykge1xuICAgICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLm11bHRpbGluZV9mcmFtZSAmJiBpc19hcnJheSh0aGlzLl9mbGFncy5tb2RlKSAmJiB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICcsJyAmJiB0aGlzLl9sYXN0X2xhc3RfdGV4dCA9PT0gJ30nKSB7XG4gICAgdGhpcy5wcmludF9uZXdsaW5lKCk7IC8vIH0sIGluIGxpc3RzIGdldCBhIG5ld2xpbmUgdHJlYXRtZW50XG4gIH0gZWxzZSBpZiAocHJlZml4ID09PSAnU1BBQ0UnKSB7XG4gICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gIH1cbiAgaWYgKGN1cnJlbnRfdG9rZW4ucHJldmlvdXMgJiYgKGN1cnJlbnRfdG9rZW4ucHJldmlvdXMudHlwZSA9PT0gVE9LRU4uV09SRCB8fCBjdXJyZW50X3Rva2VuLnByZXZpb3VzLnR5cGUgPT09IFRPS0VOLlJFU0VSVkVEKSkge1xuICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICB9XG4gIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gIHRoaXMuX2ZsYWdzLmxhc3Rfd29yZCA9IGN1cnJlbnRfdG9rZW4udGV4dDtcblxuICBpZiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5SRVNFUlZFRCkge1xuICAgIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICdkbycpIHtcbiAgICAgIHRoaXMuX2ZsYWdzLmRvX2Jsb2NrID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJ2lmJykge1xuICAgICAgdGhpcy5fZmxhZ3MuaWZfYmxvY2sgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnaW1wb3J0Jykge1xuICAgICAgdGhpcy5fZmxhZ3MuaW1wb3J0X2Jsb2NrID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLmltcG9ydF9ibG9jayAmJiByZXNlcnZlZF93b3JkKGN1cnJlbnRfdG9rZW4sICdmcm9tJykpIHtcbiAgICAgIHRoaXMuX2ZsYWdzLmltcG9ydF9ibG9jayA9IGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX3NlbWljb2xvbiA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgaWYgKHRoaXMuc3RhcnRfb2Zfc3RhdGVtZW50KGN1cnJlbnRfdG9rZW4pKSB7XG4gICAgLy8gVGhlIGNvbmRpdGlvbmFsIHN0YXJ0cyB0aGUgc3RhdGVtZW50IGlmIGFwcHJvcHJpYXRlLlxuICAgIC8vIFNlbWljb2xvbiBjYW4gYmUgdGhlIHN0YXJ0IChhbmQgZW5kKSBvZiBhIHN0YXRlbWVudFxuICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuKTtcbiAgfVxuXG4gIHZhciBuZXh0X3Rva2VuID0gdGhpcy5fdG9rZW5zLnBlZWsoKTtcbiAgd2hpbGUgKHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50ICYmXG4gICAgISh0aGlzLl9mbGFncy5pZl9ibG9jayAmJiByZXNlcnZlZF93b3JkKG5leHRfdG9rZW4sICdlbHNlJykpICYmXG4gICAgIXRoaXMuX2ZsYWdzLmRvX2Jsb2NrKSB7XG4gICAgdGhpcy5yZXN0b3JlX21vZGUoKTtcbiAgfVxuXG4gIC8vIGhhY2t5IGJ1dCBlZmZlY3RpdmUgZm9yIHRoZSBtb21lbnRcbiAgaWYgKHRoaXMuX2ZsYWdzLmltcG9ydF9ibG9jaykge1xuICAgIHRoaXMuX2ZsYWdzLmltcG9ydF9ibG9jayA9IGZhbHNlO1xuICB9XG4gIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5oYW5kbGVfc3RyaW5nID0gZnVuY3Rpb24oY3VycmVudF90b2tlbikge1xuICBpZiAoY3VycmVudF90b2tlbi50ZXh0LnN0YXJ0c1dpdGgoXCJgXCIpICYmIGN1cnJlbnRfdG9rZW4ubmV3bGluZXMgPT09IDAgJiYgY3VycmVudF90b2tlbi53aGl0ZXNwYWNlX2JlZm9yZSA9PT0gJycgJiYgKGN1cnJlbnRfdG9rZW4ucHJldmlvdXMudGV4dCA9PT0gJyknIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uV09SRCkpIHtcbiAgICAvL0NvbmRpdGlvbmFsIGZvciBkZXRlY3RpZ24gYmFja3RpY2sgc3RyaW5nc1xuICB9IGVsc2UgaWYgKHRoaXMuc3RhcnRfb2Zfc3RhdGVtZW50KGN1cnJlbnRfdG9rZW4pKSB7XG4gICAgLy8gVGhlIGNvbmRpdGlvbmFsIHN0YXJ0cyB0aGUgc3RhdGVtZW50IGlmIGFwcHJvcHJpYXRlLlxuICAgIC8vIE9uZSBkaWZmZXJlbmNlIC0gc3RyaW5ncyB3YW50IGF0IGxlYXN0IGEgc3BhY2UgYmVmb3JlXG4gICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5oYW5kbGVfd2hpdGVzcGFjZV9hbmRfY29tbWVudHMoY3VycmVudF90b2tlbik7XG4gICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uUkVTRVJWRUQgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5XT1JEIHx8IHRoaXMuX2ZsYWdzLmlubGluZV9mcmFtZSkge1xuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkNPTU1BIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RBUlRfRVhQUiB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVRVUFMUyB8fCB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLk9QRVJBVE9SKSB7XG4gICAgICBpZiAoIXRoaXMuc3RhcnRfb2Zfb2JqZWN0X3Byb3BlcnR5KCkpIHtcbiAgICAgICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKGN1cnJlbnRfdG9rZW4udGV4dC5zdGFydHNXaXRoKFwiYFwiKSAmJiB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVORF9FWFBSICYmIChjdXJyZW50X3Rva2VuLnByZXZpb3VzLnRleHQgPT09ICddJyB8fCBjdXJyZW50X3Rva2VuLnByZXZpb3VzLnRleHQgPT09ICcpJykgJiYgY3VycmVudF90b2tlbi5uZXdsaW5lcyA9PT0gMCkpIHtcbiAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmhhbmRsZV9lcXVhbHMgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIGlmICh0aGlzLnN0YXJ0X29mX3N0YXRlbWVudChjdXJyZW50X3Rva2VuKSkge1xuICAgIC8vIFRoZSBjb25kaXRpb25hbCBzdGFydHMgdGhlIHN0YXRlbWVudCBpZiBhcHByb3ByaWF0ZS5cbiAgfSBlbHNlIHtcbiAgICB0aGlzLmhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9mbGFncy5kZWNsYXJhdGlvbl9zdGF0ZW1lbnQpIHtcbiAgICAvLyBqdXN0IGdvdCBhbiAnPScgaW4gYSB2YXItbGluZSwgZGlmZmVyZW50IGZvcm1hdHRpbmcvbGluZS1icmVha2luZywgZXRjIHdpbGwgbm93IGJlIGRvbmVcbiAgICB0aGlzLl9mbGFncy5kZWNsYXJhdGlvbl9hc3NpZ25tZW50ID0gdHJ1ZTtcbiAgfVxuICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5oYW5kbGVfY29tbWEgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIHRoaXMuaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4sIHRydWUpO1xuXG4gIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICBpZiAodGhpcy5fZmxhZ3MuZGVjbGFyYXRpb25fc3RhdGVtZW50KSB7XG4gICAgaWYgKGlzX2V4cHJlc3Npb24odGhpcy5fZmxhZ3MucGFyZW50Lm1vZGUpKSB7XG4gICAgICAvLyBkbyBub3QgYnJlYWsgb24gY29tbWEsIGZvcih2YXIgYSA9IDEsIGIgPSAyKVxuICAgICAgdGhpcy5fZmxhZ3MuZGVjbGFyYXRpb25fYXNzaWdubWVudCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9mbGFncy5kZWNsYXJhdGlvbl9hc3NpZ25tZW50KSB7XG4gICAgICB0aGlzLl9mbGFncy5kZWNsYXJhdGlvbl9hc3NpZ25tZW50ID0gZmFsc2U7XG4gICAgICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3B0aW9ucy5jb21tYV9maXJzdCkge1xuICAgICAgLy8gZm9yIGNvbW1hLWZpcnN0LCB3ZSB3YW50IHRvIGFsbG93IGEgbmV3bGluZSBiZWZvcmUgdGhlIGNvbW1hXG4gICAgICAvLyB0byB0dXJuIGludG8gYSBuZXdsaW5lIGFmdGVyIHRoZSBjb21tYSwgd2hpY2ggd2Ugd2lsbCBmaXh1cCBsYXRlclxuICAgICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4pO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLk9iamVjdExpdGVyYWwgfHxcbiAgICAodGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQgJiYgdGhpcy5fZmxhZ3MucGFyZW50Lm1vZGUgPT09IE1PREUuT2JqZWN0TGl0ZXJhbCkpIHtcbiAgICBpZiAodGhpcy5fZmxhZ3MubW9kZSA9PT0gTU9ERS5TdGF0ZW1lbnQpIHtcbiAgICAgIHRoaXMucmVzdG9yZV9tb2RlKCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9mbGFncy5pbmxpbmVfZnJhbWUpIHtcbiAgICAgIHRoaXMucHJpbnRfbmV3bGluZSgpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLl9vcHRpb25zLmNvbW1hX2ZpcnN0KSB7XG4gICAgLy8gRVhQUiBvciBET19CTE9DS1xuICAgIC8vIGZvciBjb21tYS1maXJzdCwgd2Ugd2FudCB0byBhbGxvdyBhIG5ld2xpbmUgYmVmb3JlIHRoZSBjb21tYVxuICAgIC8vIHRvIHR1cm4gaW50byBhIG5ld2xpbmUgYWZ0ZXIgdGhlIGNvbW1hLCB3aGljaCB3ZSB3aWxsIGZpeHVwIGxhdGVyXG4gICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4pO1xuICB9XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5oYW5kbGVfb3BlcmF0b3IgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIHZhciBpc0dlbmVyYXRvckFzdGVyaXNrID0gY3VycmVudF90b2tlbi50ZXh0ID09PSAnKicgJiZcbiAgICAocmVzZXJ2ZWRfYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbiwgWydmdW5jdGlvbicsICd5aWVsZCddKSB8fFxuICAgICAgKGluX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSwgW1RPS0VOLlNUQVJUX0JMT0NLLCBUT0tFTi5DT01NQSwgVE9LRU4uRU5EX0JMT0NLLCBUT0tFTi5TRU1JQ09MT05dKSlcbiAgICApO1xuICB2YXIgaXNVbmFyeSA9IGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgWyctJywgJysnXSkgJiYgKFxuICAgIGluX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSwgW1RPS0VOLlNUQVJUX0JMT0NLLCBUT0tFTi5TVEFSVF9FWFBSLCBUT0tFTi5FUVVBTFMsIFRPS0VOLk9QRVJBVE9SXSkgfHxcbiAgICBpbl9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQsIGxpbmVfc3RhcnRlcnMpIHx8XG4gICAgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0ID09PSAnLCdcbiAgKTtcblxuICBpZiAodGhpcy5zdGFydF9vZl9zdGF0ZW1lbnQoY3VycmVudF90b2tlbikpIHtcbiAgICAvLyBUaGUgY29uZGl0aW9uYWwgc3RhcnRzIHRoZSBzdGF0ZW1lbnQgaWYgYXBwcm9wcmlhdGUuXG4gIH0gZWxzZSB7XG4gICAgdmFyIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyA9ICFpc0dlbmVyYXRvckFzdGVyaXNrO1xuICAgIHRoaXMuaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzKGN1cnJlbnRfdG9rZW4sIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gIH1cblxuICAvLyBoYWNrIGZvciBhY3Rpb25zY3JpcHQncyBpbXBvcnQgLio7XG4gIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICcqJyAmJiB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkRPVCkge1xuICAgIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJzo6Jykge1xuICAgIC8vIG5vIHNwYWNlcyBhcm91bmQgZXhvdGljIG5hbWVzcGFjaW5nIHN5bnRheCBvcGVyYXRvclxuICAgIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgWyctJywgJysnXSkgJiYgdGhpcy5zdGFydF9vZl9vYmplY3RfcHJvcGVydHkoKSkge1xuICAgIC8vIG51bWVyaWMgdmFsdWUgd2l0aCArLy0gc3ltYm9sIGluIGZyb250IGFzIGEgcHJvcGVydHlcbiAgICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEFsbG93IGxpbmUgd3JhcHBpbmcgYmV0d2VlbiBvcGVyYXRvcnMgd2hlbiBvcGVyYXRvcl9wb3NpdGlvbiBpc1xuICAvLyAgIHNldCB0byBiZWZvcmUgb3IgcHJlc2VydmVcbiAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uT1BFUkFUT1IgJiYgaW5fYXJyYXkodGhpcy5fb3B0aW9ucy5vcGVyYXRvcl9wb3NpdGlvbiwgT1BFUkFUT1JfUE9TSVRJT05fQkVGT1JFX09SX1BSRVNFUlZFKSkge1xuICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuKTtcbiAgfVxuXG4gIGlmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICc6JyAmJiB0aGlzLl9mbGFncy5pbl9jYXNlKSB7XG4gICAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcblxuICAgIHRoaXMuX2ZsYWdzLmluX2Nhc2UgPSBmYWxzZTtcbiAgICB0aGlzLl9mbGFncy5jYXNlX2JvZHkgPSB0cnVlO1xuICAgIGlmICh0aGlzLl90b2tlbnMucGVlaygpLnR5cGUgIT09IFRPS0VOLlNUQVJUX0JMT0NLKSB7XG4gICAgICB0aGlzLmluZGVudCgpO1xuICAgICAgdGhpcy5wcmludF9uZXdsaW5lKCk7XG4gICAgICB0aGlzLl9mbGFncy5jYXNlX2Jsb2NrID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2ZsYWdzLmNhc2VfYmxvY2sgPSB0cnVlO1xuICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzcGFjZV9iZWZvcmUgPSB0cnVlO1xuICB2YXIgc3BhY2VfYWZ0ZXIgPSB0cnVlO1xuICB2YXIgaW5fdGVybmFyeSA9IGZhbHNlO1xuICBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnOicpIHtcbiAgICBpZiAodGhpcy5fZmxhZ3MudGVybmFyeV9kZXB0aCA9PT0gMCkge1xuICAgICAgLy8gQ29sb24gaXMgaW52YWxpZCBqYXZhc2NyaXB0IG91dHNpZGUgb2YgdGVybmFyeSBhbmQgb2JqZWN0LCBidXQgZG8gb3VyIGJlc3QgdG8gZ3Vlc3Mgd2hhdCB3YXMgbWVhbnQuXG4gICAgICBzcGFjZV9iZWZvcmUgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZmxhZ3MudGVybmFyeV9kZXB0aCAtPSAxO1xuICAgICAgaW5fdGVybmFyeSA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJz8nKSB7XG4gICAgdGhpcy5fZmxhZ3MudGVybmFyeV9kZXB0aCArPSAxO1xuICB9XG5cbiAgLy8gbGV0J3MgaGFuZGxlIHRoZSBvcGVyYXRvcl9wb3NpdGlvbiBvcHRpb24gcHJpb3IgdG8gYW55IGNvbmZsaWN0aW5nIGxvZ2ljXG4gIGlmICghaXNVbmFyeSAmJiAhaXNHZW5lcmF0b3JBc3RlcmlzayAmJiB0aGlzLl9vcHRpb25zLnByZXNlcnZlX25ld2xpbmVzICYmIGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgcG9zaXRpb25hYmxlX29wZXJhdG9ycykpIHtcbiAgICB2YXIgaXNDb2xvbiA9IGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJzonO1xuICAgIHZhciBpc1Rlcm5hcnlDb2xvbiA9IChpc0NvbG9uICYmIGluX3Rlcm5hcnkpO1xuICAgIHZhciBpc090aGVyQ29sb24gPSAoaXNDb2xvbiAmJiAhaW5fdGVybmFyeSk7XG5cbiAgICBzd2l0Y2ggKHRoaXMuX29wdGlvbnMub3BlcmF0b3JfcG9zaXRpb24pIHtcbiAgICAgIGNhc2UgT1BFUkFUT1JfUE9TSVRJT04uYmVmb3JlX25ld2xpbmU6XG4gICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IHRva2VuIGlzIDogYW5kIGl0J3Mgbm90IGEgdGVybmFyeSBzdGF0ZW1lbnQgdGhlbiB3ZSBzZXQgc3BhY2VfYmVmb3JlIHRvIGZhbHNlXG4gICAgICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSAhaXNPdGhlckNvbG9uO1xuXG4gICAgICAgIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG5cbiAgICAgICAgaWYgKCFpc0NvbG9uIHx8IGlzVGVybmFyeUNvbG9uKSB7XG4gICAgICAgICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBPUEVSQVRPUl9QT1NJVElPTi5hZnRlcl9uZXdsaW5lOlxuICAgICAgICAvLyBpZiB0aGUgY3VycmVudCB0b2tlbiBpcyBhbnl0aGluZyBidXQgY29sb24sIG9yICh2aWEgZGVkdWN0aW9uKSBpdCdzIGEgY29sb24gYW5kIGluIGEgdGVybmFyeSBzdGF0ZW1lbnQsXG4gICAgICAgIC8vICAgdGhlbiBwcmludCBhIG5ld2xpbmUuXG5cbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG5cbiAgICAgICAgaWYgKCFpc0NvbG9uIHx8IGlzVGVybmFyeUNvbG9uKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3Rva2Vucy5wZWVrKCkubmV3bGluZXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcblxuICAgICAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIE9QRVJBVE9SX1BPU0lUSU9OLnByZXNlcnZlX25ld2xpbmU6XG4gICAgICAgIGlmICghaXNPdGhlckNvbG9uKSB7XG4gICAgICAgICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgd2UganVzdCBhZGRlZCBhIG5ld2xpbmUsIG9yIHRoZSBjdXJyZW50IHRva2VuIGlzIDogYW5kIGl0J3Mgbm90IGEgdGVybmFyeSBzdGF0ZW1lbnQsXG4gICAgICAgIC8vICAgdGhlbiB3ZSBzZXQgc3BhY2VfYmVmb3JlIHRvIGZhbHNlXG4gICAgICAgIHNwYWNlX2JlZm9yZSA9ICEodGhpcy5fb3V0cHV0Lmp1c3RfYWRkZWRfbmV3bGluZSgpIHx8IGlzT3RoZXJDb2xvbik7XG5cbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHNwYWNlX2JlZm9yZTtcbiAgICAgICAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgICAgICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNHZW5lcmF0b3JBc3Rlcmlzaykge1xuICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuKTtcbiAgICBzcGFjZV9iZWZvcmUgPSBmYWxzZTtcbiAgICB2YXIgbmV4dF90b2tlbiA9IHRoaXMuX3Rva2Vucy5wZWVrKCk7XG4gICAgc3BhY2VfYWZ0ZXIgPSBuZXh0X3Rva2VuICYmIGluX2FycmF5KG5leHRfdG9rZW4udHlwZSwgW1RPS0VOLldPUkQsIFRPS0VOLlJFU0VSVkVEXSk7XG4gIH0gZWxzZSBpZiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnLi4uJykge1xuICAgIHRoaXMuYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZShjdXJyZW50X3Rva2VuKTtcbiAgICBzcGFjZV9iZWZvcmUgPSB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNUQVJUX0JMT0NLO1xuICAgIHNwYWNlX2FmdGVyID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaW5fYXJyYXkoY3VycmVudF90b2tlbi50ZXh0LCBbJy0tJywgJysrJywgJyEnLCAnfiddKSB8fCBpc1VuYXJ5KSB7XG4gICAgLy8gdW5hcnkgb3BlcmF0b3JzIChhbmQgYmluYXJ5ICsvLSBwcmV0ZW5kaW5nIHRvIGJlIHVuYXJ5KSBzcGVjaWFsIGNhc2VzXG4gICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uQ09NTUEgfHwgdGhpcy5fZmxhZ3MubGFzdF90b2tlbi50eXBlID09PSBUT0tFTi5TVEFSVF9FWFBSKSB7XG4gICAgICB0aGlzLmFsbG93X3dyYXBfb3JfcHJlc2VydmVkX25ld2xpbmUoY3VycmVudF90b2tlbik7XG4gICAgfVxuXG4gICAgc3BhY2VfYmVmb3JlID0gZmFsc2U7XG4gICAgc3BhY2VfYWZ0ZXIgPSBmYWxzZTtcblxuICAgIC8vIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi81LjEvI3NlYy03LjkuMVxuICAgIC8vIGlmIHRoZXJlIGlzIGEgbmV3bGluZSBiZXR3ZWVuIC0tIG9yICsrIGFuZCBhbnl0aGluZyBlbHNlIHdlIHNob3VsZCBwcmVzZXJ2ZSBpdC5cbiAgICBpZiAoY3VycmVudF90b2tlbi5uZXdsaW5lcyAmJiAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnLS0nIHx8IGN1cnJlbnRfdG9rZW4udGV4dCA9PT0gJysrJyB8fCBjdXJyZW50X3Rva2VuLnRleHQgPT09ICd+JykpIHtcbiAgICAgIHZhciBuZXdfbGluZV9uZWVkZWQgPSByZXNlcnZlZF9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLCBzcGVjaWFsX3dvcmRzKSAmJiBjdXJyZW50X3Rva2VuLm5ld2xpbmVzO1xuICAgICAgaWYgKG5ld19saW5lX25lZWRlZCAmJiAodGhpcy5fcHJldmlvdXNfZmxhZ3MuaWZfYmxvY2sgfHwgdGhpcy5fcHJldmlvdXNfZmxhZ3MuZWxzZV9ibG9jaykpIHtcbiAgICAgICAgdGhpcy5yZXN0b3JlX21vZGUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJpbnRfbmV3bGluZShuZXdfbGluZV9uZWVkZWQsIHRydWUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICc7JyAmJiBpc19leHByZXNzaW9uKHRoaXMuX2ZsYWdzLm1vZGUpKSB7XG4gICAgICAvLyBmb3IgKDs7ICsraSlcbiAgICAgIC8vICAgICAgICBeXl5cbiAgICAgIHNwYWNlX2JlZm9yZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udHlwZSA9PT0gVE9LRU4uUkVTRVJWRUQpIHtcbiAgICAgIHNwYWNlX2JlZm9yZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLkVORF9FWFBSKSB7XG4gICAgICBzcGFjZV9iZWZvcmUgPSAhKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJ10nICYmIChjdXJyZW50X3Rva2VuLnRleHQgPT09ICctLScgfHwgY3VycmVudF90b2tlbi50ZXh0ID09PSAnKysnKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnR5cGUgPT09IFRPS0VOLk9QRVJBVE9SKSB7XG4gICAgICAvLyBhKysgKyArK2I7XG4gICAgICAvLyBhIC0gLWJcbiAgICAgIHNwYWNlX2JlZm9yZSA9IGluX2FycmF5KGN1cnJlbnRfdG9rZW4udGV4dCwgWyctLScsICctJywgJysrJywgJysnXSkgJiYgaW5fYXJyYXkodGhpcy5fZmxhZ3MubGFzdF90b2tlbi50ZXh0LCBbJy0tJywgJy0nLCAnKysnLCAnKyddKTtcbiAgICAgIC8vICsgYW5kIC0gYXJlIG5vdCB1bmFyeSB3aGVuIHByZWNlZWRlZCBieSAtLSBvciArKyBvcGVyYXRvclxuICAgICAgLy8gYS0tICsgYlxuICAgICAgLy8gYSAqICtiXG4gICAgICAvLyBhIC0gLWJcbiAgICAgIGlmIChpbl9hcnJheShjdXJyZW50X3Rva2VuLnRleHQsIFsnKycsICctJ10pICYmIGluX2FycmF5KHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCwgWyctLScsICcrKyddKSkge1xuICAgICAgICBzcGFjZV9hZnRlciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG5cbiAgICBpZiAoKCh0aGlzLl9mbGFncy5tb2RlID09PSBNT0RFLkJsb2NrU3RhdGVtZW50ICYmICF0aGlzLl9mbGFncy5pbmxpbmVfZnJhbWUpIHx8IHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50KSAmJlxuICAgICAgKHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJ3snIHx8IHRoaXMuX2ZsYWdzLmxhc3RfdG9rZW4udGV4dCA9PT0gJzsnKSkge1xuICAgICAgLy8geyBmb287IC0taSB9XG4gICAgICAvLyBmb28oKTsgLS1iYXI7XG4gICAgICB0aGlzLnByaW50X25ld2xpbmUoKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiB8fCBzcGFjZV9iZWZvcmU7XG4gIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBzcGFjZV9hZnRlcjtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmhhbmRsZV9ibG9ja19jb21tZW50ID0gZnVuY3Rpb24oY3VycmVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKSB7XG4gIGlmICh0aGlzLl9vdXRwdXQucmF3KSB7XG4gICAgdGhpcy5fb3V0cHV0LmFkZF9yYXdfdG9rZW4oY3VycmVudF90b2tlbik7XG4gICAgaWYgKGN1cnJlbnRfdG9rZW4uZGlyZWN0aXZlcyAmJiBjdXJyZW50X3Rva2VuLmRpcmVjdGl2ZXMucHJlc2VydmUgPT09ICdlbmQnKSB7XG4gICAgICAvLyBJZiB3ZSdyZSB0ZXN0aW5nIHRoZSByYXcgb3V0cHV0IGJlaGF2aW9yLCBkbyBub3QgYWxsb3cgYSBkaXJlY3RpdmUgdG8gdHVybiBpdCBvZmYuXG4gICAgICB0aGlzLl9vdXRwdXQucmF3ID0gdGhpcy5fb3B0aW9ucy50ZXN0X291dHB1dF9yYXc7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjdXJyZW50X3Rva2VuLmRpcmVjdGl2ZXMpIHtcbiAgICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG4gICAgdGhpcy5wcmludF90b2tlbihjdXJyZW50X3Rva2VuKTtcbiAgICBpZiAoY3VycmVudF90b2tlbi5kaXJlY3RpdmVzLnByZXNlcnZlID09PSAnc3RhcnQnKSB7XG4gICAgICB0aGlzLl9vdXRwdXQucmF3ID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5wcmludF9uZXdsaW5lKGZhbHNlLCB0cnVlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBpbmxpbmUgYmxvY2tcbiAgaWYgKCFhY29ybi5uZXdsaW5lLnRlc3QoY3VycmVudF90b2tlbi50ZXh0KSAmJiAhY3VycmVudF90b2tlbi5uZXdsaW5lcykge1xuICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSB0cnVlO1xuICAgIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gICAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gICAgcmV0dXJuO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucHJpbnRfYmxvY2tfY29tbW1lbnQoY3VycmVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUucHJpbnRfYmxvY2tfY29tbW1lbnQgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpIHtcbiAgdmFyIGxpbmVzID0gc3BsaXRfbGluZWJyZWFrcyhjdXJyZW50X3Rva2VuLnRleHQpO1xuICB2YXIgajsgLy8gaXRlcmF0b3IgZm9yIHRoaXMgY2FzZVxuICB2YXIgamF2YWRvYyA9IGZhbHNlO1xuICB2YXIgc3Rhcmxlc3MgPSBmYWxzZTtcbiAgdmFyIGxhc3RJbmRlbnQgPSBjdXJyZW50X3Rva2VuLndoaXRlc3BhY2VfYmVmb3JlO1xuICB2YXIgbGFzdEluZGVudExlbmd0aCA9IGxhc3RJbmRlbnQubGVuZ3RoO1xuXG4gIC8vIGJsb2NrIGNvbW1lbnQgc3RhcnRzIHdpdGggYSBuZXcgbGluZVxuICB0aGlzLnByaW50X25ld2xpbmUoZmFsc2UsIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncyk7XG5cbiAgLy8gZmlyc3QgbGluZSBhbHdheXMgaW5kZW50ZWRcbiAgdGhpcy5wcmludF90b2tlbl9saW5lX2luZGVudGF0aW9uKGN1cnJlbnRfdG9rZW4pO1xuICB0aGlzLl9vdXRwdXQuYWRkX3Rva2VuKGxpbmVzWzBdKTtcbiAgdGhpcy5wcmludF9uZXdsaW5lKGZhbHNlLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuXG5cbiAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICBsaW5lcyA9IGxpbmVzLnNsaWNlKDEpO1xuICAgIGphdmFkb2MgPSBhbGxfbGluZXNfc3RhcnRfd2l0aChsaW5lcywgJyonKTtcbiAgICBzdGFybGVzcyA9IGVhY2hfbGluZV9tYXRjaGVzX2luZGVudChsaW5lcywgbGFzdEluZGVudCk7XG5cbiAgICBpZiAoamF2YWRvYykge1xuICAgICAgdGhpcy5fZmxhZ3MuYWxpZ25tZW50ID0gMTtcbiAgICB9XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgbGluZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChqYXZhZG9jKSB7XG4gICAgICAgIC8vIGphdmFkb2M6IHJlZm9ybWF0IGFuZCByZS1pbmRlbnRcbiAgICAgICAgdGhpcy5wcmludF90b2tlbl9saW5lX2luZGVudGF0aW9uKGN1cnJlbnRfdG9rZW4pO1xuICAgICAgICB0aGlzLl9vdXRwdXQuYWRkX3Rva2VuKGx0cmltKGxpbmVzW2pdKSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJsZXNzICYmIGxpbmVzW2pdKSB7XG4gICAgICAgIC8vIHN0YXJsZXNzOiByZS1pbmRlbnQgbm9uLWVtcHR5IGNvbnRlbnQsIGF2b2lkaW5nIHRyaW1cbiAgICAgICAgdGhpcy5wcmludF90b2tlbl9saW5lX2luZGVudGF0aW9uKGN1cnJlbnRfdG9rZW4pO1xuICAgICAgICB0aGlzLl9vdXRwdXQuYWRkX3Rva2VuKGxpbmVzW2pdLnN1YnN0cmluZyhsYXN0SW5kZW50TGVuZ3RoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBub3JtYWwgY29tbWVudHMgb3V0cHV0IHJhd1xuICAgICAgICB0aGlzLl9vdXRwdXQuY3VycmVudF9saW5lLnNldF9pbmRlbnQoLTEpO1xuICAgICAgICB0aGlzLl9vdXRwdXQuYWRkX3Rva2VuKGxpbmVzW2pdKTtcbiAgICAgIH1cblxuICAgICAgLy8gZm9yIGNvbW1lbnRzIG9uIHRoZWlyIG93biBsaW5lIG9yICBtb3JlIHRoYW4gb25lIGxpbmUsIG1ha2Ugc3VyZSB0aGVyZSdzIGEgbmV3IGxpbmUgYWZ0ZXJcbiAgICAgIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgICB9XG5cbiAgICB0aGlzLl9mbGFncy5hbGlnbm1lbnQgPSAwO1xuICB9XG59O1xuXG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmhhbmRsZV9jb21tZW50ID0gZnVuY3Rpb24oY3VycmVudF90b2tlbiwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKSB7XG4gIGlmIChjdXJyZW50X3Rva2VuLm5ld2xpbmVzKSB7XG4gICAgdGhpcy5wcmludF9uZXdsaW5lKGZhbHNlLCBwcmVzZXJ2ZV9zdGF0ZW1lbnRfZmxhZ3MpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX291dHB1dC50cmltKHRydWUpO1xuICB9XG5cbiAgdGhpcy5fb3V0cHV0LnNwYWNlX2JlZm9yZV90b2tlbiA9IHRydWU7XG4gIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG4gIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbn07XG5cbkJlYXV0aWZpZXIucHJvdG90eXBlLmhhbmRsZV9kb3QgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIGlmICh0aGlzLnN0YXJ0X29mX3N0YXRlbWVudChjdXJyZW50X3Rva2VuKSkge1xuICAgIC8vIFRoZSBjb25kaXRpb25hbCBzdGFydHMgdGhlIHN0YXRlbWVudCBpZiBhcHByb3ByaWF0ZS5cbiAgfSBlbHNlIHtcbiAgICB0aGlzLmhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuLCB0cnVlKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQubWF0Y2goJ15bMC05XSskJykpIHtcbiAgICB0aGlzLl9vdXRwdXQuc3BhY2VfYmVmb3JlX3Rva2VuID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChyZXNlcnZlZF9hcnJheSh0aGlzLl9mbGFncy5sYXN0X3Rva2VuLCBzcGVjaWFsX3dvcmRzKSkge1xuICAgIHRoaXMuX291dHB1dC5zcGFjZV9iZWZvcmVfdG9rZW4gPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBhbGxvdyBwcmVzZXJ2ZWQgbmV3bGluZXMgYmVmb3JlIGRvdHMgaW4gZ2VuZXJhbFxuICAgIC8vIGZvcmNlIG5ld2xpbmVzIG9uIGRvdHMgYWZ0ZXIgY2xvc2UgcGFyZW4gd2hlbiBicmVha19jaGFpbmVkIC0gZm9yIGJhcigpLmJheigpXG4gICAgdGhpcy5hbGxvd193cmFwX29yX3ByZXNlcnZlZF9uZXdsaW5lKGN1cnJlbnRfdG9rZW4sXG4gICAgICB0aGlzLl9mbGFncy5sYXN0X3Rva2VuLnRleHQgPT09ICcpJyAmJiB0aGlzLl9vcHRpb25zLmJyZWFrX2NoYWluZWRfbWV0aG9kcyk7XG4gIH1cblxuICAvLyBPbmx5IHVuaW5kZW50IGNoYWluZWQgbWV0aG9kIGRvdCBpZiB0aGlzIGRvdCBzdGFydHMgYSBuZXcgbGluZS5cbiAgLy8gT3RoZXJ3aXNlIHRoZSBhdXRvbWF0aWMgZXh0cmEgaW5kZW50YXRpb24gcmVtb3ZhbCB3aWxsIGhhbmRsZSB0aGUgb3ZlciBpbmRlbnRcbiAgaWYgKHRoaXMuX29wdGlvbnMudW5pbmRlbnRfY2hhaW5lZF9tZXRob2RzICYmIHRoaXMuX291dHB1dC5qdXN0X2FkZGVkX25ld2xpbmUoKSkge1xuICAgIHRoaXMuZGVpbmRlbnQoKTtcbiAgfVxuXG4gIHRoaXMucHJpbnRfdG9rZW4oY3VycmVudF90b2tlbik7XG59O1xuXG5CZWF1dGlmaWVyLnByb3RvdHlwZS5oYW5kbGVfdW5rbm93biA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4sIHByZXNlcnZlX3N0YXRlbWVudF9mbGFncykge1xuICB0aGlzLnByaW50X3Rva2VuKGN1cnJlbnRfdG9rZW4pO1xuXG4gIGlmIChjdXJyZW50X3Rva2VuLnRleHRbY3VycmVudF90b2tlbi50ZXh0Lmxlbmd0aCAtIDFdID09PSAnXFxuJykge1xuICAgIHRoaXMucHJpbnRfbmV3bGluZShmYWxzZSwgcHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzKTtcbiAgfVxufTtcblxuQmVhdXRpZmllci5wcm90b3R5cGUuaGFuZGxlX2VvZiA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHtcbiAgLy8gVW53aW5kIGFueSBvcGVuIHN0YXRlbWVudHNcbiAgd2hpbGUgKHRoaXMuX2ZsYWdzLm1vZGUgPT09IE1PREUuU3RhdGVtZW50KSB7XG4gICAgdGhpcy5yZXN0b3JlX21vZGUoKTtcbiAgfVxuICB0aGlzLmhhbmRsZV93aGl0ZXNwYWNlX2FuZF9jb21tZW50cyhjdXJyZW50X3Rva2VuKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLkJlYXV0aWZpZXIgPSBCZWF1dGlmaWVyO1xuXG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG5mdW5jdGlvbiBPdXRwdXRMaW5lKHBhcmVudCkge1xuICB0aGlzLl9fcGFyZW50ID0gcGFyZW50O1xuICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50ID0gMDtcbiAgLy8gdXNlIGluZGVudF9jb3VudCBhcyBhIG1hcmtlciBmb3IgdGhpcy5fX2xpbmVzIHRoYXQgaGF2ZSBwcmVzZXJ2ZWQgaW5kZW50YXRpb25cbiAgdGhpcy5fX2luZGVudF9jb3VudCA9IC0xO1xuICB0aGlzLl9fYWxpZ25tZW50X2NvdW50ID0gMDtcbiAgdGhpcy5fX3dyYXBfcG9pbnRfaW5kZXggPSAwO1xuICB0aGlzLl9fd3JhcF9wb2ludF9jaGFyYWN0ZXJfY291bnQgPSAwO1xuICB0aGlzLl9fd3JhcF9wb2ludF9pbmRlbnRfY291bnQgPSAtMTtcbiAgdGhpcy5fX3dyYXBfcG9pbnRfYWxpZ25tZW50X2NvdW50ID0gMDtcblxuICB0aGlzLl9faXRlbXMgPSBbXTtcbn1cblxuT3V0cHV0TGluZS5wcm90b3R5cGUuY2xvbmVfZW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGxpbmUgPSBuZXcgT3V0cHV0TGluZSh0aGlzLl9fcGFyZW50KTtcbiAgbGluZS5zZXRfaW5kZW50KHRoaXMuX19pbmRlbnRfY291bnQsIHRoaXMuX19hbGlnbm1lbnRfY291bnQpO1xuICByZXR1cm4gbGluZTtcbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLml0ZW0gPSBmdW5jdGlvbihpbmRleCkge1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX19pdGVtc1t0aGlzLl9faXRlbXMubGVuZ3RoICsgaW5kZXhdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLl9faXRlbXNbaW5kZXhdO1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5oYXNfbWF0Y2ggPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIGZvciAodmFyIGxhc3RDaGVja2VkT3V0cHV0ID0gdGhpcy5fX2l0ZW1zLmxlbmd0aCAtIDE7IGxhc3RDaGVja2VkT3V0cHV0ID49IDA7IGxhc3RDaGVja2VkT3V0cHV0LS0pIHtcbiAgICBpZiAodGhpcy5fX2l0ZW1zW2xhc3RDaGVja2VkT3V0cHV0XS5tYXRjaChwYXR0ZXJuKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLnNldF9pbmRlbnQgPSBmdW5jdGlvbihpbmRlbnQsIGFsaWdubWVudCkge1xuICBpZiAodGhpcy5pc19lbXB0eSgpKSB7XG4gICAgdGhpcy5fX2luZGVudF9jb3VudCA9IGluZGVudCB8fCAwO1xuICAgIHRoaXMuX19hbGlnbm1lbnRfY291bnQgPSBhbGlnbm1lbnQgfHwgMDtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50ID0gdGhpcy5fX3BhcmVudC5nZXRfaW5kZW50X3NpemUodGhpcy5fX2luZGVudF9jb3VudCwgdGhpcy5fX2FsaWdubWVudF9jb3VudCk7XG4gIH1cbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLl9zZXRfd3JhcF9wb2ludCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fX3BhcmVudC53cmFwX2xpbmVfbGVuZ3RoKSB7XG4gICAgdGhpcy5fX3dyYXBfcG9pbnRfaW5kZXggPSB0aGlzLl9faXRlbXMubGVuZ3RoO1xuICAgIHRoaXMuX193cmFwX3BvaW50X2NoYXJhY3Rlcl9jb3VudCA9IHRoaXMuX19jaGFyYWN0ZXJfY291bnQ7XG4gICAgdGhpcy5fX3dyYXBfcG9pbnRfaW5kZW50X2NvdW50ID0gdGhpcy5fX3BhcmVudC5uZXh0X2xpbmUuX19pbmRlbnRfY291bnQ7XG4gICAgdGhpcy5fX3dyYXBfcG9pbnRfYWxpZ25tZW50X2NvdW50ID0gdGhpcy5fX3BhcmVudC5uZXh0X2xpbmUuX19hbGlnbm1lbnRfY291bnQ7XG4gIH1cbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLl9zaG91bGRfd3JhcCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fX3dyYXBfcG9pbnRfaW5kZXggJiZcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50ID4gdGhpcy5fX3BhcmVudC53cmFwX2xpbmVfbGVuZ3RoICYmXG4gICAgdGhpcy5fX3dyYXBfcG9pbnRfY2hhcmFjdGVyX2NvdW50ID4gdGhpcy5fX3BhcmVudC5uZXh0X2xpbmUuX19jaGFyYWN0ZXJfY291bnQ7XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5fYWxsb3dfd3JhcCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fc2hvdWxkX3dyYXAoKSkge1xuICAgIHRoaXMuX19wYXJlbnQuYWRkX25ld19saW5lKCk7XG4gICAgdmFyIG5leHQgPSB0aGlzLl9fcGFyZW50LmN1cnJlbnRfbGluZTtcbiAgICBuZXh0LnNldF9pbmRlbnQodGhpcy5fX3dyYXBfcG9pbnRfaW5kZW50X2NvdW50LCB0aGlzLl9fd3JhcF9wb2ludF9hbGlnbm1lbnRfY291bnQpO1xuICAgIG5leHQuX19pdGVtcyA9IHRoaXMuX19pdGVtcy5zbGljZSh0aGlzLl9fd3JhcF9wb2ludF9pbmRleCk7XG4gICAgdGhpcy5fX2l0ZW1zID0gdGhpcy5fX2l0ZW1zLnNsaWNlKDAsIHRoaXMuX193cmFwX3BvaW50X2luZGV4KTtcblxuICAgIG5leHQuX19jaGFyYWN0ZXJfY291bnQgKz0gdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCAtIHRoaXMuX193cmFwX3BvaW50X2NoYXJhY3Rlcl9jb3VudDtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50ID0gdGhpcy5fX3dyYXBfcG9pbnRfY2hhcmFjdGVyX2NvdW50O1xuXG4gICAgaWYgKG5leHQuX19pdGVtc1swXSA9PT0gXCIgXCIpIHtcbiAgICAgIG5leHQuX19pdGVtcy5zcGxpY2UoMCwgMSk7XG4gICAgICBuZXh0Ll9fY2hhcmFjdGVyX2NvdW50IC09IDE7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLmlzX2VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9faXRlbXMubGVuZ3RoID09PSAwO1xufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuaXNfZW1wdHkoKSkge1xuICAgIHJldHVybiB0aGlzLl9faXRlbXNbdGhpcy5fX2l0ZW1zLmxlbmd0aCAtIDFdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oaXRlbSkge1xuICB0aGlzLl9faXRlbXMucHVzaChpdGVtKTtcbiAgdmFyIGxhc3RfbmV3bGluZV9pbmRleCA9IGl0ZW0ubGFzdEluZGV4T2YoJ1xcbicpO1xuICBpZiAobGFzdF9uZXdsaW5lX2luZGV4ICE9PSAtMSkge1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgPSBpdGVtLmxlbmd0aCAtIGxhc3RfbmV3bGluZV9pbmRleDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50ICs9IGl0ZW0ubGVuZ3RoO1xuICB9XG59O1xuXG5PdXRwdXRMaW5lLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGl0ZW0gPSBudWxsO1xuICBpZiAoIXRoaXMuaXNfZW1wdHkoKSkge1xuICAgIGl0ZW0gPSB0aGlzLl9faXRlbXMucG9wKCk7XG4gICAgdGhpcy5fX2NoYXJhY3Rlcl9jb3VudCAtPSBpdGVtLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gaXRlbTtcbn07XG5cblxuT3V0cHV0TGluZS5wcm90b3R5cGUuX3JlbW92ZV9pbmRlbnQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX19pbmRlbnRfY291bnQgPiAwKSB7XG4gICAgdGhpcy5fX2luZGVudF9jb3VudCAtPSAxO1xuICAgIHRoaXMuX19jaGFyYWN0ZXJfY291bnQgLT0gdGhpcy5fX3BhcmVudC5pbmRlbnRfc2l6ZTtcbiAgfVxufTtcblxuT3V0cHV0TGluZS5wcm90b3R5cGUuX3JlbW92ZV93cmFwX2luZGVudCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fX3dyYXBfcG9pbnRfaW5kZW50X2NvdW50ID4gMCkge1xuICAgIHRoaXMuX193cmFwX3BvaW50X2luZGVudF9jb3VudCAtPSAxO1xuICB9XG59O1xuT3V0cHV0TGluZS5wcm90b3R5cGUudHJpbSA9IGZ1bmN0aW9uKCkge1xuICB3aGlsZSAodGhpcy5sYXN0KCkgPT09ICcgJykge1xuICAgIHRoaXMuX19pdGVtcy5wb3AoKTtcbiAgICB0aGlzLl9fY2hhcmFjdGVyX2NvdW50IC09IDE7XG4gIH1cbn07XG5cbk91dHB1dExpbmUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHRoaXMuaXNfZW1wdHkoKSkge1xuICAgIGlmICh0aGlzLl9fcGFyZW50LmluZGVudF9lbXB0eV9saW5lcykge1xuICAgICAgcmVzdWx0ID0gdGhpcy5fX3BhcmVudC5nZXRfaW5kZW50X3N0cmluZyh0aGlzLl9faW5kZW50X2NvdW50KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gdGhpcy5fX3BhcmVudC5nZXRfaW5kZW50X3N0cmluZyh0aGlzLl9faW5kZW50X2NvdW50LCB0aGlzLl9fYWxpZ25tZW50X2NvdW50KTtcbiAgICByZXN1bHQgKz0gdGhpcy5fX2l0ZW1zLmpvaW4oJycpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiBJbmRlbnRTdHJpbmdDYWNoZShvcHRpb25zLCBiYXNlSW5kZW50U3RyaW5nKSB7XG4gIHRoaXMuX19jYWNoZSA9IFsnJ107XG4gIHRoaXMuX19pbmRlbnRfc2l6ZSA9IG9wdGlvbnMuaW5kZW50X3NpemU7XG4gIHRoaXMuX19pbmRlbnRfc3RyaW5nID0gb3B0aW9ucy5pbmRlbnRfY2hhcjtcbiAgaWYgKCFvcHRpb25zLmluZGVudF93aXRoX3RhYnMpIHtcbiAgICB0aGlzLl9faW5kZW50X3N0cmluZyA9IG5ldyBBcnJheShvcHRpb25zLmluZGVudF9zaXplICsgMSkuam9pbihvcHRpb25zLmluZGVudF9jaGFyKTtcbiAgfVxuXG4gIC8vIFNldCB0byBudWxsIHRvIGNvbnRpbnVlIHN1cHBvcnQgZm9yIGF1dG8gZGV0ZWN0aW9uIG9mIGJhc2UgaW5kZW50XG4gIGJhc2VJbmRlbnRTdHJpbmcgPSBiYXNlSW5kZW50U3RyaW5nIHx8ICcnO1xuICBpZiAob3B0aW9ucy5pbmRlbnRfbGV2ZWwgPiAwKSB7XG4gICAgYmFzZUluZGVudFN0cmluZyA9IG5ldyBBcnJheShvcHRpb25zLmluZGVudF9sZXZlbCArIDEpLmpvaW4odGhpcy5fX2luZGVudF9zdHJpbmcpO1xuICB9XG5cbiAgdGhpcy5fX2Jhc2Vfc3RyaW5nID0gYmFzZUluZGVudFN0cmluZztcbiAgdGhpcy5fX2Jhc2Vfc3RyaW5nX2xlbmd0aCA9IGJhc2VJbmRlbnRTdHJpbmcubGVuZ3RoO1xufVxuXG5JbmRlbnRTdHJpbmdDYWNoZS5wcm90b3R5cGUuZ2V0X2luZGVudF9zaXplID0gZnVuY3Rpb24oaW5kZW50LCBjb2x1bW4pIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX19iYXNlX3N0cmluZ19sZW5ndGg7XG4gIGNvbHVtbiA9IGNvbHVtbiB8fCAwO1xuICBpZiAoaW5kZW50IDwgMCkge1xuICAgIHJlc3VsdCA9IDA7XG4gIH1cbiAgcmVzdWx0ICs9IGluZGVudCAqIHRoaXMuX19pbmRlbnRfc2l6ZTtcbiAgcmVzdWx0ICs9IGNvbHVtbjtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkluZGVudFN0cmluZ0NhY2hlLnByb3RvdHlwZS5nZXRfaW5kZW50X3N0cmluZyA9IGZ1bmN0aW9uKGluZGVudF9sZXZlbCwgY29sdW1uKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9fYmFzZV9zdHJpbmc7XG4gIGNvbHVtbiA9IGNvbHVtbiB8fCAwO1xuICBpZiAoaW5kZW50X2xldmVsIDwgMCkge1xuICAgIGluZGVudF9sZXZlbCA9IDA7XG4gICAgcmVzdWx0ID0gJyc7XG4gIH1cbiAgY29sdW1uICs9IGluZGVudF9sZXZlbCAqIHRoaXMuX19pbmRlbnRfc2l6ZTtcbiAgdGhpcy5fX2Vuc3VyZV9jYWNoZShjb2x1bW4pO1xuICByZXN1bHQgKz0gdGhpcy5fX2NhY2hlW2NvbHVtbl07XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5JbmRlbnRTdHJpbmdDYWNoZS5wcm90b3R5cGUuX19lbnN1cmVfY2FjaGUgPSBmdW5jdGlvbihjb2x1bW4pIHtcbiAgd2hpbGUgKGNvbHVtbiA+PSB0aGlzLl9fY2FjaGUubGVuZ3RoKSB7XG4gICAgdGhpcy5fX2FkZF9jb2x1bW4oKTtcbiAgfVxufTtcblxuSW5kZW50U3RyaW5nQ2FjaGUucHJvdG90eXBlLl9fYWRkX2NvbHVtbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29sdW1uID0gdGhpcy5fX2NhY2hlLmxlbmd0aDtcbiAgdmFyIGluZGVudCA9IDA7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKHRoaXMuX19pbmRlbnRfc2l6ZSAmJiBjb2x1bW4gPj0gdGhpcy5fX2luZGVudF9zaXplKSB7XG4gICAgaW5kZW50ID0gTWF0aC5mbG9vcihjb2x1bW4gLyB0aGlzLl9faW5kZW50X3NpemUpO1xuICAgIGNvbHVtbiAtPSBpbmRlbnQgKiB0aGlzLl9faW5kZW50X3NpemU7XG4gICAgcmVzdWx0ID0gbmV3IEFycmF5KGluZGVudCArIDEpLmpvaW4odGhpcy5fX2luZGVudF9zdHJpbmcpO1xuICB9XG4gIGlmIChjb2x1bW4pIHtcbiAgICByZXN1bHQgKz0gbmV3IEFycmF5KGNvbHVtbiArIDEpLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHRoaXMuX19jYWNoZS5wdXNoKHJlc3VsdCk7XG59O1xuXG5mdW5jdGlvbiBPdXRwdXQob3B0aW9ucywgYmFzZUluZGVudFN0cmluZykge1xuICB0aGlzLl9faW5kZW50X2NhY2hlID0gbmV3IEluZGVudFN0cmluZ0NhY2hlKG9wdGlvbnMsIGJhc2VJbmRlbnRTdHJpbmcpO1xuICB0aGlzLnJhdyA9IGZhbHNlO1xuICB0aGlzLl9lbmRfd2l0aF9uZXdsaW5lID0gb3B0aW9ucy5lbmRfd2l0aF9uZXdsaW5lO1xuICB0aGlzLmluZGVudF9zaXplID0gb3B0aW9ucy5pbmRlbnRfc2l6ZTtcbiAgdGhpcy53cmFwX2xpbmVfbGVuZ3RoID0gb3B0aW9ucy53cmFwX2xpbmVfbGVuZ3RoO1xuICB0aGlzLmluZGVudF9lbXB0eV9saW5lcyA9IG9wdGlvbnMuaW5kZW50X2VtcHR5X2xpbmVzO1xuICB0aGlzLl9fbGluZXMgPSBbXTtcbiAgdGhpcy5wcmV2aW91c19saW5lID0gbnVsbDtcbiAgdGhpcy5jdXJyZW50X2xpbmUgPSBudWxsO1xuICB0aGlzLm5leHRfbGluZSA9IG5ldyBPdXRwdXRMaW5lKHRoaXMpO1xuICB0aGlzLnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICB0aGlzLm5vbl9icmVha2luZ19zcGFjZSA9IGZhbHNlO1xuICB0aGlzLnByZXZpb3VzX3Rva2VuX3dyYXBwZWQgPSBmYWxzZTtcbiAgLy8gaW5pdGlhbGl6ZVxuICB0aGlzLl9fYWRkX291dHB1dGxpbmUoKTtcbn1cblxuT3V0cHV0LnByb3RvdHlwZS5fX2FkZF9vdXRwdXRsaW5lID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucHJldmlvdXNfbGluZSA9IHRoaXMuY3VycmVudF9saW5lO1xuICB0aGlzLmN1cnJlbnRfbGluZSA9IHRoaXMubmV4dF9saW5lLmNsb25lX2VtcHR5KCk7XG4gIHRoaXMuX19saW5lcy5wdXNoKHRoaXMuY3VycmVudF9saW5lKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuZ2V0X2xpbmVfbnVtYmVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9fbGluZXMubGVuZ3RoO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5nZXRfaW5kZW50X3N0cmluZyA9IGZ1bmN0aW9uKGluZGVudCwgY29sdW1uKSB7XG4gIHJldHVybiB0aGlzLl9faW5kZW50X2NhY2hlLmdldF9pbmRlbnRfc3RyaW5nKGluZGVudCwgY29sdW1uKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuZ2V0X2luZGVudF9zaXplID0gZnVuY3Rpb24oaW5kZW50LCBjb2x1bW4pIHtcbiAgcmV0dXJuIHRoaXMuX19pbmRlbnRfY2FjaGUuZ2V0X2luZGVudF9zaXplKGluZGVudCwgY29sdW1uKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuaXNfZW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICF0aGlzLnByZXZpb3VzX2xpbmUgJiYgdGhpcy5jdXJyZW50X2xpbmUuaXNfZW1wdHkoKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuYWRkX25ld19saW5lID0gZnVuY3Rpb24oZm9yY2VfbmV3bGluZSkge1xuICAvLyBuZXZlciBuZXdsaW5lIGF0IHRoZSBzdGFydCBvZiBmaWxlXG4gIC8vIG90aGVyd2lzZSwgbmV3bGluZSBvbmx5IGlmIHdlIGRpZG4ndCBqdXN0IGFkZCBvbmUgb3Igd2UncmUgZm9yY2VkXG4gIGlmICh0aGlzLmlzX2VtcHR5KCkgfHxcbiAgICAoIWZvcmNlX25ld2xpbmUgJiYgdGhpcy5qdXN0X2FkZGVkX25ld2xpbmUoKSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBpZiByYXcgb3V0cHV0IGlzIGVuYWJsZWQsIGRvbid0IHByaW50IGFkZGl0aW9uYWwgbmV3bGluZXMsXG4gIC8vIGJ1dCBzdGlsbCByZXR1cm4gVHJ1ZSBhcyB0aG91Z2ggeW91IGhhZFxuICBpZiAoIXRoaXMucmF3KSB7XG4gICAgdGhpcy5fX2FkZF9vdXRwdXRsaW5lKCk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmdldF9jb2RlID0gZnVuY3Rpb24oZW9sKSB7XG4gIHRoaXMudHJpbSh0cnVlKTtcblxuICAvLyBoYW5kbGUgc29tZSBlZGdlIGNhc2VzIHdoZXJlIHRoZSBsYXN0IHRva2Vuc1xuICAvLyBoYXMgdGV4dCB0aGF0IGVuZHMgd2l0aCBuZXdsaW5lKHMpXG4gIHZhciBsYXN0X2l0ZW0gPSB0aGlzLmN1cnJlbnRfbGluZS5wb3AoKTtcbiAgaWYgKGxhc3RfaXRlbSkge1xuICAgIGlmIChsYXN0X2l0ZW1bbGFzdF9pdGVtLmxlbmd0aCAtIDFdID09PSAnXFxuJykge1xuICAgICAgbGFzdF9pdGVtID0gbGFzdF9pdGVtLnJlcGxhY2UoL1xcbiskL2csICcnKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50X2xpbmUucHVzaChsYXN0X2l0ZW0pO1xuICB9XG5cbiAgaWYgKHRoaXMuX2VuZF93aXRoX25ld2xpbmUpIHtcbiAgICB0aGlzLl9fYWRkX291dHB1dGxpbmUoKTtcbiAgfVxuXG4gIHZhciBzd2VldF9jb2RlID0gdGhpcy5fX2xpbmVzLmpvaW4oJ1xcbicpO1xuXG4gIGlmIChlb2wgIT09ICdcXG4nKSB7XG4gICAgc3dlZXRfY29kZSA9IHN3ZWV0X2NvZGUucmVwbGFjZSgvW1xcbl0vZywgZW9sKTtcbiAgfVxuICByZXR1cm4gc3dlZXRfY29kZTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuc2V0X3dyYXBfcG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jdXJyZW50X2xpbmUuX3NldF93cmFwX3BvaW50KCk7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLnNldF9pbmRlbnQgPSBmdW5jdGlvbihpbmRlbnQsIGFsaWdubWVudCkge1xuICBpbmRlbnQgPSBpbmRlbnQgfHwgMDtcbiAgYWxpZ25tZW50ID0gYWxpZ25tZW50IHx8IDA7XG5cbiAgLy8gTmV4dCBsaW5lIHN0b3JlcyBhbGlnbm1lbnQgdmFsdWVzXG4gIHRoaXMubmV4dF9saW5lLnNldF9pbmRlbnQoaW5kZW50LCBhbGlnbm1lbnQpO1xuXG4gIC8vIE5ldmVyIGluZGVudCB5b3VyIGZpcnN0IG91dHB1dCBpbmRlbnQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBmaWxlXG4gIGlmICh0aGlzLl9fbGluZXMubGVuZ3RoID4gMSkge1xuICAgIHRoaXMuY3VycmVudF9saW5lLnNldF9pbmRlbnQoaW5kZW50LCBhbGlnbm1lbnQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdGhpcy5jdXJyZW50X2xpbmUuc2V0X2luZGVudCgpO1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmFkZF9yYXdfdG9rZW4gPSBmdW5jdGlvbih0b2tlbikge1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IHRva2VuLm5ld2xpbmVzOyB4KyspIHtcbiAgICB0aGlzLl9fYWRkX291dHB1dGxpbmUoKTtcbiAgfVxuICB0aGlzLmN1cnJlbnRfbGluZS5zZXRfaW5kZW50KC0xKTtcbiAgdGhpcy5jdXJyZW50X2xpbmUucHVzaCh0b2tlbi53aGl0ZXNwYWNlX2JlZm9yZSk7XG4gIHRoaXMuY3VycmVudF9saW5lLnB1c2godG9rZW4udGV4dCk7XG4gIHRoaXMuc3BhY2VfYmVmb3JlX3Rva2VuID0gZmFsc2U7XG4gIHRoaXMubm9uX2JyZWFraW5nX3NwYWNlID0gZmFsc2U7XG4gIHRoaXMucHJldmlvdXNfdG9rZW5fd3JhcHBlZCA9IGZhbHNlO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5hZGRfdG9rZW4gPSBmdW5jdGlvbihwcmludGFibGVfdG9rZW4pIHtcbiAgdGhpcy5fX2FkZF9zcGFjZV9iZWZvcmVfdG9rZW4oKTtcbiAgdGhpcy5jdXJyZW50X2xpbmUucHVzaChwcmludGFibGVfdG9rZW4pO1xuICB0aGlzLnNwYWNlX2JlZm9yZV90b2tlbiA9IGZhbHNlO1xuICB0aGlzLm5vbl9icmVha2luZ19zcGFjZSA9IGZhbHNlO1xuICB0aGlzLnByZXZpb3VzX3Rva2VuX3dyYXBwZWQgPSB0aGlzLmN1cnJlbnRfbGluZS5fYWxsb3dfd3JhcCgpO1xufTtcblxuT3V0cHV0LnByb3RvdHlwZS5fX2FkZF9zcGFjZV9iZWZvcmVfdG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuc3BhY2VfYmVmb3JlX3Rva2VuICYmICF0aGlzLmp1c3RfYWRkZWRfbmV3bGluZSgpKSB7XG4gICAgaWYgKCF0aGlzLm5vbl9icmVha2luZ19zcGFjZSkge1xuICAgICAgdGhpcy5zZXRfd3JhcF9wb2ludCgpO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRfbGluZS5wdXNoKCcgJyk7XG4gIH1cbn07XG5cbk91dHB1dC5wcm90b3R5cGUucmVtb3ZlX2luZGVudCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gIHZhciBvdXRwdXRfbGVuZ3RoID0gdGhpcy5fX2xpbmVzLmxlbmd0aDtcbiAgd2hpbGUgKGluZGV4IDwgb3V0cHV0X2xlbmd0aCkge1xuICAgIHRoaXMuX19saW5lc1tpbmRleF0uX3JlbW92ZV9pbmRlbnQoKTtcbiAgICBpbmRleCsrO1xuICB9XG4gIHRoaXMuY3VycmVudF9saW5lLl9yZW1vdmVfd3JhcF9pbmRlbnQoKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUudHJpbSA9IGZ1bmN0aW9uKGVhdF9uZXdsaW5lcykge1xuICBlYXRfbmV3bGluZXMgPSAoZWF0X25ld2xpbmVzID09PSB1bmRlZmluZWQpID8gZmFsc2UgOiBlYXRfbmV3bGluZXM7XG5cbiAgdGhpcy5jdXJyZW50X2xpbmUudHJpbSgpO1xuXG4gIHdoaWxlIChlYXRfbmV3bGluZXMgJiYgdGhpcy5fX2xpbmVzLmxlbmd0aCA+IDEgJiZcbiAgICB0aGlzLmN1cnJlbnRfbGluZS5pc19lbXB0eSgpKSB7XG4gICAgdGhpcy5fX2xpbmVzLnBvcCgpO1xuICAgIHRoaXMuY3VycmVudF9saW5lID0gdGhpcy5fX2xpbmVzW3RoaXMuX19saW5lcy5sZW5ndGggLSAxXTtcbiAgICB0aGlzLmN1cnJlbnRfbGluZS50cmltKCk7XG4gIH1cblxuICB0aGlzLnByZXZpb3VzX2xpbmUgPSB0aGlzLl9fbGluZXMubGVuZ3RoID4gMSA/XG4gICAgdGhpcy5fX2xpbmVzW3RoaXMuX19saW5lcy5sZW5ndGggLSAyXSA6IG51bGw7XG59O1xuXG5PdXRwdXQucHJvdG90eXBlLmp1c3RfYWRkZWRfbmV3bGluZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jdXJyZW50X2xpbmUuaXNfZW1wdHkoKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuanVzdF9hZGRlZF9ibGFua2xpbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuaXNfZW1wdHkoKSB8fFxuICAgICh0aGlzLmN1cnJlbnRfbGluZS5pc19lbXB0eSgpICYmIHRoaXMucHJldmlvdXNfbGluZS5pc19lbXB0eSgpKTtcbn07XG5cbk91dHB1dC5wcm90b3R5cGUuZW5zdXJlX2VtcHR5X2xpbmVfYWJvdmUgPSBmdW5jdGlvbihzdGFydHNfd2l0aCwgZW5kc193aXRoKSB7XG4gIHZhciBpbmRleCA9IHRoaXMuX19saW5lcy5sZW5ndGggLSAyO1xuICB3aGlsZSAoaW5kZXggPj0gMCkge1xuICAgIHZhciBwb3RlbnRpYWxFbXB0eUxpbmUgPSB0aGlzLl9fbGluZXNbaW5kZXhdO1xuICAgIGlmIChwb3RlbnRpYWxFbXB0eUxpbmUuaXNfZW1wdHkoKSkge1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmIChwb3RlbnRpYWxFbXB0eUxpbmUuaXRlbSgwKS5pbmRleE9mKHN0YXJ0c193aXRoKSAhPT0gMCAmJlxuICAgICAgcG90ZW50aWFsRW1wdHlMaW5lLml0ZW0oLTEpICE9PSBlbmRzX3dpdGgpIHtcbiAgICAgIHRoaXMuX19saW5lcy5zcGxpY2UoaW5kZXggKyAxLCAwLCBuZXcgT3V0cHV0TGluZSh0aGlzKSk7XG4gICAgICB0aGlzLnByZXZpb3VzX2xpbmUgPSB0aGlzLl9fbGluZXNbdGhpcy5fX2xpbmVzLmxlbmd0aCAtIDJdO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGluZGV4LS07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLk91dHB1dCA9IE91dHB1dDtcblxuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG5mdW5jdGlvbiBUb2tlbih0eXBlLCB0ZXh0LCBuZXdsaW5lcywgd2hpdGVzcGFjZV9iZWZvcmUpIHtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy50ZXh0ID0gdGV4dDtcblxuICAvLyBjb21tZW50c19iZWZvcmUgYXJlXG4gIC8vIGNvbW1lbnRzIHRoYXQgaGF2ZSBhIG5ldyBsaW5lIGJlZm9yZSB0aGVtXG4gIC8vIGFuZCBtYXkgb3IgbWF5IG5vdCBoYXZlIGEgbmV3bGluZSBhZnRlclxuICAvLyB0aGlzIGlzIGEgc2V0IG9mIGNvbW1lbnRzIGJlZm9yZVxuICB0aGlzLmNvbW1lbnRzX2JlZm9yZSA9IG51bGw7IC8qIGlubGluZSBjb21tZW50Ki9cblxuXG4gIC8vIHRoaXMuY29tbWVudHNfYWZ0ZXIgPSAgbmV3IFRva2VuU3RyZWFtKCk7IC8vIG5vIG5ldyBsaW5lIGJlZm9yZSBhbmQgbmV3bGluZSBhZnRlclxuICB0aGlzLm5ld2xpbmVzID0gbmV3bGluZXMgfHwgMDtcbiAgdGhpcy53aGl0ZXNwYWNlX2JlZm9yZSA9IHdoaXRlc3BhY2VfYmVmb3JlIHx8ICcnO1xuICB0aGlzLnBhcmVudCA9IG51bGw7XG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMucHJldmlvdXMgPSBudWxsO1xuICB0aGlzLm9wZW5lZCA9IG51bGw7XG4gIHRoaXMuY2xvc2VkID0gbnVsbDtcbiAgdGhpcy5kaXJlY3RpdmVzID0gbnVsbDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cy5Ub2tlbiA9IFRva2VuO1xuXG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qIGpzaGludCBub2RlOiB0cnVlLCBjdXJseTogZmFsc2UgKi9cbi8vIFBhcnRzIG9mIHRoaXMgc2VjdGlvbiBvZiBjb2RlIGlzIHRha2VuIGZyb20gYWNvcm4uXG4vL1xuLy8gQWNvcm4gd2FzIHdyaXR0ZW4gYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgcmVsZWFzZWQgdW5kZXIgYW4gTUlUXG4vLyBsaWNlbnNlLiBUaGUgVW5pY29kZSByZWdleHBzIChmb3IgaWRlbnRpZmllcnMgYW5kIHdoaXRlc3BhY2UpIHdlcmVcbi8vIHRha2VuIGZyb20gW0VzcHJpbWFdKGh0dHA6Ly9lc3ByaW1hLm9yZykgYnkgQXJpeWEgSGlkYXlhdC5cbi8vXG4vLyBHaXQgcmVwb3NpdG9yaWVzIGZvciBBY29ybiBhcmUgYXZhaWxhYmxlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly9tYXJpam5oYXZlcmJla2UubmwvZ2l0L2Fjb3JuXG4vLyAgICAgaHR0cHM6Ly9naXRodWIuY29tL21hcmlqbmgvYWNvcm4uZ2l0XG5cbi8vICMjIENoYXJhY3RlciBjYXRlZ29yaWVzXG5cblxuXG5cbi8vIGFjb3JuIHVzZWQgY2hhciBjb2RlcyB0byBzcXVlZXplIHRoZSBsYXN0IGJpdCBvZiBwZXJmb3JtYW5jZSBvdXRcbi8vIEJlYXV0aWZpZXIgaXMgb2theSB3aXRob3V0IHRoYXQsIHNvIHdlJ3JlIHVzaW5nIHJlZ2V4XG4vLyBwZXJtaXQgIyAoMjMpLCAkICgzNiksIGFuZCBAICg2NCkuIEAgaXMgdXNlZCBpbiBFUzcgZGVjb3JhdG9ycy5cbi8vIDY1IHRocm91Z2ggOTEgYXJlIHVwcGVyY2FzZSBsZXR0ZXJzLlxuLy8gcGVybWl0IF8gKDk1KS5cbi8vIDk3IHRocm91Z2ggMTIzIGFyZSBsb3dlcmNhc2UgbGV0dGVycy5cbnZhciBiYXNlQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IFwiXFxcXHgyM1xcXFx4MjRcXFxceDQwXFxcXHg0MS1cXFxceDVhXFxcXHg1ZlxcXFx4NjEtXFxcXHg3YVwiO1xuXG4vLyBpbnNpZGUgYW4gaWRlbnRpZmllciBAIGlzIG5vdCBhbGxvd2VkIGJ1dCAwLTkgYXJlLlxudmFyIGJhc2VBU0NJSWlkZW50aWZpZXJDaGFycyA9IFwiXFxcXHgyNFxcXFx4MzAtXFxcXHgzOVxcXFx4NDEtXFxcXHg1YVxcXFx4NWZcXFxceDYxLVxcXFx4N2FcIjtcblxuLy8gQmlnIHVnbHkgcmVndWxhciBleHByZXNzaW9ucyB0aGF0IG1hdGNoIGNoYXJhY3RlcnMgaW4gdGhlXG4vLyB3aGl0ZXNwYWNlLCBpZGVudGlmaWVyLCBhbmQgaWRlbnRpZmllci1zdGFydCBjYXRlZ29yaWVzLiBUaGVzZVxuLy8gYXJlIG9ubHkgYXBwbGllZCB3aGVuIGEgY2hhcmFjdGVyIGlzIGZvdW5kIHRvIGFjdHVhbGx5IGhhdmUgYVxuLy8gY29kZSBwb2ludCBhYm92ZSAxMjguXG52YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IFwiXFxcXHhhYVxcXFx4YjVcXFxceGJhXFxcXHhjMC1cXFxceGQ2XFxcXHhkOC1cXFxceGY2XFxcXHhmOC1cXFxcdTAyYzFcXFxcdTAyYzYtXFxcXHUwMmQxXFxcXHUwMmUwLVxcXFx1MDJlNFxcXFx1MDJlY1xcXFx1MDJlZVxcXFx1MDM3MC1cXFxcdTAzNzRcXFxcdTAzNzZcXFxcdTAzNzdcXFxcdTAzN2EtXFxcXHUwMzdkXFxcXHUwMzg2XFxcXHUwMzg4LVxcXFx1MDM4YVxcXFx1MDM4Y1xcXFx1MDM4ZS1cXFxcdTAzYTFcXFxcdTAzYTMtXFxcXHUwM2Y1XFxcXHUwM2Y3LVxcXFx1MDQ4MVxcXFx1MDQ4YS1cXFxcdTA1MjdcXFxcdTA1MzEtXFxcXHUwNTU2XFxcXHUwNTU5XFxcXHUwNTYxLVxcXFx1MDU4N1xcXFx1MDVkMC1cXFxcdTA1ZWFcXFxcdTA1ZjAtXFxcXHUwNWYyXFxcXHUwNjIwLVxcXFx1MDY0YVxcXFx1MDY2ZVxcXFx1MDY2ZlxcXFx1MDY3MS1cXFxcdTA2ZDNcXFxcdTA2ZDVcXFxcdTA2ZTVcXFxcdTA2ZTZcXFxcdTA2ZWVcXFxcdTA2ZWZcXFxcdTA2ZmEtXFxcXHUwNmZjXFxcXHUwNmZmXFxcXHUwNzEwXFxcXHUwNzEyLVxcXFx1MDcyZlxcXFx1MDc0ZC1cXFxcdTA3YTVcXFxcdTA3YjFcXFxcdTA3Y2EtXFxcXHUwN2VhXFxcXHUwN2Y0XFxcXHUwN2Y1XFxcXHUwN2ZhXFxcXHUwODAwLVxcXFx1MDgxNVxcXFx1MDgxYVxcXFx1MDgyNFxcXFx1MDgyOFxcXFx1MDg0MC1cXFxcdTA4NThcXFxcdTA4YTBcXFxcdTA4YTItXFxcXHUwOGFjXFxcXHUwOTA0LVxcXFx1MDkzOVxcXFx1MDkzZFxcXFx1MDk1MFxcXFx1MDk1OC1cXFxcdTA5NjFcXFxcdTA5NzEtXFxcXHUwOTc3XFxcXHUwOTc5LVxcXFx1MDk3ZlxcXFx1MDk4NS1cXFxcdTA5OGNcXFxcdTA5OGZcXFxcdTA5OTBcXFxcdTA5OTMtXFxcXHUwOWE4XFxcXHUwOWFhLVxcXFx1MDliMFxcXFx1MDliMlxcXFx1MDliNi1cXFxcdTA5YjlcXFxcdTA5YmRcXFxcdTA5Y2VcXFxcdTA5ZGNcXFxcdTA5ZGRcXFxcdTA5ZGYtXFxcXHUwOWUxXFxcXHUwOWYwXFxcXHUwOWYxXFxcXHUwYTA1LVxcXFx1MGEwYVxcXFx1MGEwZlxcXFx1MGExMFxcXFx1MGExMy1cXFxcdTBhMjhcXFxcdTBhMmEtXFxcXHUwYTMwXFxcXHUwYTMyXFxcXHUwYTMzXFxcXHUwYTM1XFxcXHUwYTM2XFxcXHUwYTM4XFxcXHUwYTM5XFxcXHUwYTU5LVxcXFx1MGE1Y1xcXFx1MGE1ZVxcXFx1MGE3Mi1cXFxcdTBhNzRcXFxcdTBhODUtXFxcXHUwYThkXFxcXHUwYThmLVxcXFx1MGE5MVxcXFx1MGE5My1cXFxcdTBhYThcXFxcdTBhYWEtXFxcXHUwYWIwXFxcXHUwYWIyXFxcXHUwYWIzXFxcXHUwYWI1LVxcXFx1MGFiOVxcXFx1MGFiZFxcXFx1MGFkMFxcXFx1MGFlMFxcXFx1MGFlMVxcXFx1MGIwNS1cXFxcdTBiMGNcXFxcdTBiMGZcXFxcdTBiMTBcXFxcdTBiMTMtXFxcXHUwYjI4XFxcXHUwYjJhLVxcXFx1MGIzMFxcXFx1MGIzMlxcXFx1MGIzM1xcXFx1MGIzNS1cXFxcdTBiMzlcXFxcdTBiM2RcXFxcdTBiNWNcXFxcdTBiNWRcXFxcdTBiNWYtXFxcXHUwYjYxXFxcXHUwYjcxXFxcXHUwYjgzXFxcXHUwYjg1LVxcXFx1MGI4YVxcXFx1MGI4ZS1cXFxcdTBiOTBcXFxcdTBiOTItXFxcXHUwYjk1XFxcXHUwYjk5XFxcXHUwYjlhXFxcXHUwYjljXFxcXHUwYjllXFxcXHUwYjlmXFxcXHUwYmEzXFxcXHUwYmE0XFxcXHUwYmE4LVxcXFx1MGJhYVxcXFx1MGJhZS1cXFxcdTBiYjlcXFxcdTBiZDBcXFxcdTBjMDUtXFxcXHUwYzBjXFxcXHUwYzBlLVxcXFx1MGMxMFxcXFx1MGMxMi1cXFxcdTBjMjhcXFxcdTBjMmEtXFxcXHUwYzMzXFxcXHUwYzM1LVxcXFx1MGMzOVxcXFx1MGMzZFxcXFx1MGM1OFxcXFx1MGM1OVxcXFx1MGM2MFxcXFx1MGM2MVxcXFx1MGM4NS1cXFxcdTBjOGNcXFxcdTBjOGUtXFxcXHUwYzkwXFxcXHUwYzkyLVxcXFx1MGNhOFxcXFx1MGNhYS1cXFxcdTBjYjNcXFxcdTBjYjUtXFxcXHUwY2I5XFxcXHUwY2JkXFxcXHUwY2RlXFxcXHUwY2UwXFxcXHUwY2UxXFxcXHUwY2YxXFxcXHUwY2YyXFxcXHUwZDA1LVxcXFx1MGQwY1xcXFx1MGQwZS1cXFxcdTBkMTBcXFxcdTBkMTItXFxcXHUwZDNhXFxcXHUwZDNkXFxcXHUwZDRlXFxcXHUwZDYwXFxcXHUwZDYxXFxcXHUwZDdhLVxcXFx1MGQ3ZlxcXFx1MGQ4NS1cXFxcdTBkOTZcXFxcdTBkOWEtXFxcXHUwZGIxXFxcXHUwZGIzLVxcXFx1MGRiYlxcXFx1MGRiZFxcXFx1MGRjMC1cXFxcdTBkYzZcXFxcdTBlMDEtXFxcXHUwZTMwXFxcXHUwZTMyXFxcXHUwZTMzXFxcXHUwZTQwLVxcXFx1MGU0NlxcXFx1MGU4MVxcXFx1MGU4MlxcXFx1MGU4NFxcXFx1MGU4N1xcXFx1MGU4OFxcXFx1MGU4YVxcXFx1MGU4ZFxcXFx1MGU5NC1cXFxcdTBlOTdcXFxcdTBlOTktXFxcXHUwZTlmXFxcXHUwZWExLVxcXFx1MGVhM1xcXFx1MGVhNVxcXFx1MGVhN1xcXFx1MGVhYVxcXFx1MGVhYlxcXFx1MGVhZC1cXFxcdTBlYjBcXFxcdTBlYjJcXFxcdTBlYjNcXFxcdTBlYmRcXFxcdTBlYzAtXFxcXHUwZWM0XFxcXHUwZWM2XFxcXHUwZWRjLVxcXFx1MGVkZlxcXFx1MGYwMFxcXFx1MGY0MC1cXFxcdTBmNDdcXFxcdTBmNDktXFxcXHUwZjZjXFxcXHUwZjg4LVxcXFx1MGY4Y1xcXFx1MTAwMC1cXFxcdTEwMmFcXFxcdTEwM2ZcXFxcdTEwNTAtXFxcXHUxMDU1XFxcXHUxMDVhLVxcXFx1MTA1ZFxcXFx1MTA2MVxcXFx1MTA2NVxcXFx1MTA2NlxcXFx1MTA2ZS1cXFxcdTEwNzBcXFxcdTEwNzUtXFxcXHUxMDgxXFxcXHUxMDhlXFxcXHUxMGEwLVxcXFx1MTBjNVxcXFx1MTBjN1xcXFx1MTBjZFxcXFx1MTBkMC1cXFxcdTEwZmFcXFxcdTEwZmMtXFxcXHUxMjQ4XFxcXHUxMjRhLVxcXFx1MTI0ZFxcXFx1MTI1MC1cXFxcdTEyNTZcXFxcdTEyNThcXFxcdTEyNWEtXFxcXHUxMjVkXFxcXHUxMjYwLVxcXFx1MTI4OFxcXFx1MTI4YS1cXFxcdTEyOGRcXFxcdTEyOTAtXFxcXHUxMmIwXFxcXHUxMmIyLVxcXFx1MTJiNVxcXFx1MTJiOC1cXFxcdTEyYmVcXFxcdTEyYzBcXFxcdTEyYzItXFxcXHUxMmM1XFxcXHUxMmM4LVxcXFx1MTJkNlxcXFx1MTJkOC1cXFxcdTEzMTBcXFxcdTEzMTItXFxcXHUxMzE1XFxcXHUxMzE4LVxcXFx1MTM1YVxcXFx1MTM4MC1cXFxcdTEzOGZcXFxcdTEzYTAtXFxcXHUxM2Y0XFxcXHUxNDAxLVxcXFx1MTY2Y1xcXFx1MTY2Zi1cXFxcdTE2N2ZcXFxcdTE2ODEtXFxcXHUxNjlhXFxcXHUxNmEwLVxcXFx1MTZlYVxcXFx1MTZlZS1cXFxcdTE2ZjBcXFxcdTE3MDAtXFxcXHUxNzBjXFxcXHUxNzBlLVxcXFx1MTcxMVxcXFx1MTcyMC1cXFxcdTE3MzFcXFxcdTE3NDAtXFxcXHUxNzUxXFxcXHUxNzYwLVxcXFx1MTc2Y1xcXFx1MTc2ZS1cXFxcdTE3NzBcXFxcdTE3ODAtXFxcXHUxN2IzXFxcXHUxN2Q3XFxcXHUxN2RjXFxcXHUxODIwLVxcXFx1MTg3N1xcXFx1MTg4MC1cXFxcdTE4YThcXFxcdTE4YWFcXFxcdTE4YjAtXFxcXHUxOGY1XFxcXHUxOTAwLVxcXFx1MTkxY1xcXFx1MTk1MC1cXFxcdTE5NmRcXFxcdTE5NzAtXFxcXHUxOTc0XFxcXHUxOTgwLVxcXFx1MTlhYlxcXFx1MTljMS1cXFxcdTE5YzdcXFxcdTFhMDAtXFxcXHUxYTE2XFxcXHUxYTIwLVxcXFx1MWE1NFxcXFx1MWFhN1xcXFx1MWIwNS1cXFxcdTFiMzNcXFxcdTFiNDUtXFxcXHUxYjRiXFxcXHUxYjgzLVxcXFx1MWJhMFxcXFx1MWJhZVxcXFx1MWJhZlxcXFx1MWJiYS1cXFxcdTFiZTVcXFxcdTFjMDAtXFxcXHUxYzIzXFxcXHUxYzRkLVxcXFx1MWM0ZlxcXFx1MWM1YS1cXFxcdTFjN2RcXFxcdTFjZTktXFxcXHUxY2VjXFxcXHUxY2VlLVxcXFx1MWNmMVxcXFx1MWNmNVxcXFx1MWNmNlxcXFx1MWQwMC1cXFxcdTFkYmZcXFxcdTFlMDAtXFxcXHUxZjE1XFxcXHUxZjE4LVxcXFx1MWYxZFxcXFx1MWYyMC1cXFxcdTFmNDVcXFxcdTFmNDgtXFxcXHUxZjRkXFxcXHUxZjUwLVxcXFx1MWY1N1xcXFx1MWY1OVxcXFx1MWY1YlxcXFx1MWY1ZFxcXFx1MWY1Zi1cXFxcdTFmN2RcXFxcdTFmODAtXFxcXHUxZmI0XFxcXHUxZmI2LVxcXFx1MWZiY1xcXFx1MWZiZVxcXFx1MWZjMi1cXFxcdTFmYzRcXFxcdTFmYzYtXFxcXHUxZmNjXFxcXHUxZmQwLVxcXFx1MWZkM1xcXFx1MWZkNi1cXFxcdTFmZGJcXFxcdTFmZTAtXFxcXHUxZmVjXFxcXHUxZmYyLVxcXFx1MWZmNFxcXFx1MWZmNi1cXFxcdTFmZmNcXFxcdTIwNzFcXFxcdTIwN2ZcXFxcdTIwOTAtXFxcXHUyMDljXFxcXHUyMTAyXFxcXHUyMTA3XFxcXHUyMTBhLVxcXFx1MjExM1xcXFx1MjExNVxcXFx1MjExOS1cXFxcdTIxMWRcXFxcdTIxMjRcXFxcdTIxMjZcXFxcdTIxMjhcXFxcdTIxMmEtXFxcXHUyMTJkXFxcXHUyMTJmLVxcXFx1MjEzOVxcXFx1MjEzYy1cXFxcdTIxM2ZcXFxcdTIxNDUtXFxcXHUyMTQ5XFxcXHUyMTRlXFxcXHUyMTYwLVxcXFx1MjE4OFxcXFx1MmMwMC1cXFxcdTJjMmVcXFxcdTJjMzAtXFxcXHUyYzVlXFxcXHUyYzYwLVxcXFx1MmNlNFxcXFx1MmNlYi1cXFxcdTJjZWVcXFxcdTJjZjJcXFxcdTJjZjNcXFxcdTJkMDAtXFxcXHUyZDI1XFxcXHUyZDI3XFxcXHUyZDJkXFxcXHUyZDMwLVxcXFx1MmQ2N1xcXFx1MmQ2ZlxcXFx1MmQ4MC1cXFxcdTJkOTZcXFxcdTJkYTAtXFxcXHUyZGE2XFxcXHUyZGE4LVxcXFx1MmRhZVxcXFx1MmRiMC1cXFxcdTJkYjZcXFxcdTJkYjgtXFxcXHUyZGJlXFxcXHUyZGMwLVxcXFx1MmRjNlxcXFx1MmRjOC1cXFxcdTJkY2VcXFxcdTJkZDAtXFxcXHUyZGQ2XFxcXHUyZGQ4LVxcXFx1MmRkZVxcXFx1MmUyZlxcXFx1MzAwNS1cXFxcdTMwMDdcXFxcdTMwMjEtXFxcXHUzMDI5XFxcXHUzMDMxLVxcXFx1MzAzNVxcXFx1MzAzOC1cXFxcdTMwM2NcXFxcdTMwNDEtXFxcXHUzMDk2XFxcXHUzMDlkLVxcXFx1MzA5ZlxcXFx1MzBhMS1cXFxcdTMwZmFcXFxcdTMwZmMtXFxcXHUzMGZmXFxcXHUzMTA1LVxcXFx1MzEyZFxcXFx1MzEzMS1cXFxcdTMxOGVcXFxcdTMxYTAtXFxcXHUzMWJhXFxcXHUzMWYwLVxcXFx1MzFmZlxcXFx1MzQwMC1cXFxcdTRkYjVcXFxcdTRlMDAtXFxcXHU5ZmNjXFxcXHVhMDAwLVxcXFx1YTQ4Y1xcXFx1YTRkMC1cXFxcdWE0ZmRcXFxcdWE1MDAtXFxcXHVhNjBjXFxcXHVhNjEwLVxcXFx1YTYxZlxcXFx1YTYyYVxcXFx1YTYyYlxcXFx1YTY0MC1cXFxcdWE2NmVcXFxcdWE2N2YtXFxcXHVhNjk3XFxcXHVhNmEwLVxcXFx1YTZlZlxcXFx1YTcxNy1cXFxcdWE3MWZcXFxcdWE3MjItXFxcXHVhNzg4XFxcXHVhNzhiLVxcXFx1YTc4ZVxcXFx1YTc5MC1cXFxcdWE3OTNcXFxcdWE3YTAtXFxcXHVhN2FhXFxcXHVhN2Y4LVxcXFx1YTgwMVxcXFx1YTgwMy1cXFxcdWE4MDVcXFxcdWE4MDctXFxcXHVhODBhXFxcXHVhODBjLVxcXFx1YTgyMlxcXFx1YTg0MC1cXFxcdWE4NzNcXFxcdWE4ODItXFxcXHVhOGIzXFxcXHVhOGYyLVxcXFx1YThmN1xcXFx1YThmYlxcXFx1YTkwYS1cXFxcdWE5MjVcXFxcdWE5MzAtXFxcXHVhOTQ2XFxcXHVhOTYwLVxcXFx1YTk3Y1xcXFx1YTk4NC1cXFxcdWE5YjJcXFxcdWE5Y2ZcXFxcdWFhMDAtXFxcXHVhYTI4XFxcXHVhYTQwLVxcXFx1YWE0MlxcXFx1YWE0NC1cXFxcdWFhNGJcXFxcdWFhNjAtXFxcXHVhYTc2XFxcXHVhYTdhXFxcXHVhYTgwLVxcXFx1YWFhZlxcXFx1YWFiMVxcXFx1YWFiNVxcXFx1YWFiNlxcXFx1YWFiOS1cXFxcdWFhYmRcXFxcdWFhYzBcXFxcdWFhYzJcXFxcdWFhZGItXFxcXHVhYWRkXFxcXHVhYWUwLVxcXFx1YWFlYVxcXFx1YWFmMi1cXFxcdWFhZjRcXFxcdWFiMDEtXFxcXHVhYjA2XFxcXHVhYjA5LVxcXFx1YWIwZVxcXFx1YWIxMS1cXFxcdWFiMTZcXFxcdWFiMjAtXFxcXHVhYjI2XFxcXHVhYjI4LVxcXFx1YWIyZVxcXFx1YWJjMC1cXFxcdWFiZTJcXFxcdWFjMDAtXFxcXHVkN2EzXFxcXHVkN2IwLVxcXFx1ZDdjNlxcXFx1ZDdjYi1cXFxcdWQ3ZmJcXFxcdWY5MDAtXFxcXHVmYTZkXFxcXHVmYTcwLVxcXFx1ZmFkOVxcXFx1ZmIwMC1cXFxcdWZiMDZcXFxcdWZiMTMtXFxcXHVmYjE3XFxcXHVmYjFkXFxcXHVmYjFmLVxcXFx1ZmIyOFxcXFx1ZmIyYS1cXFxcdWZiMzZcXFxcdWZiMzgtXFxcXHVmYjNjXFxcXHVmYjNlXFxcXHVmYjQwXFxcXHVmYjQxXFxcXHVmYjQzXFxcXHVmYjQ0XFxcXHVmYjQ2LVxcXFx1ZmJiMVxcXFx1ZmJkMy1cXFxcdWZkM2RcXFxcdWZkNTAtXFxcXHVmZDhmXFxcXHVmZDkyLVxcXFx1ZmRjN1xcXFx1ZmRmMC1cXFxcdWZkZmJcXFxcdWZlNzAtXFxcXHVmZTc0XFxcXHVmZTc2LVxcXFx1ZmVmY1xcXFx1ZmYyMS1cXFxcdWZmM2FcXFxcdWZmNDEtXFxcXHVmZjVhXFxcXHVmZjY2LVxcXFx1ZmZiZVxcXFx1ZmZjMi1cXFxcdWZmYzdcXFxcdWZmY2EtXFxcXHVmZmNmXFxcXHVmZmQyLVxcXFx1ZmZkN1xcXFx1ZmZkYS1cXFxcdWZmZGNcIjtcbnZhciBub25BU0NJSWlkZW50aWZpZXJDaGFycyA9IFwiXFxcXHUwMzAwLVxcXFx1MDM2ZlxcXFx1MDQ4My1cXFxcdTA0ODdcXFxcdTA1OTEtXFxcXHUwNWJkXFxcXHUwNWJmXFxcXHUwNWMxXFxcXHUwNWMyXFxcXHUwNWM0XFxcXHUwNWM1XFxcXHUwNWM3XFxcXHUwNjEwLVxcXFx1MDYxYVxcXFx1MDYyMC1cXFxcdTA2NDlcXFxcdTA2NzItXFxcXHUwNmQzXFxcXHUwNmU3LVxcXFx1MDZlOFxcXFx1MDZmYi1cXFxcdTA2ZmNcXFxcdTA3MzAtXFxcXHUwNzRhXFxcXHUwODAwLVxcXFx1MDgxNFxcXFx1MDgxYi1cXFxcdTA4MjNcXFxcdTA4MjUtXFxcXHUwODI3XFxcXHUwODI5LVxcXFx1MDgyZFxcXFx1MDg0MC1cXFxcdTA4NTdcXFxcdTA4ZTQtXFxcXHUwOGZlXFxcXHUwOTAwLVxcXFx1MDkwM1xcXFx1MDkzYS1cXFxcdTA5M2NcXFxcdTA5M2UtXFxcXHUwOTRmXFxcXHUwOTUxLVxcXFx1MDk1N1xcXFx1MDk2Mi1cXFxcdTA5NjNcXFxcdTA5NjYtXFxcXHUwOTZmXFxcXHUwOTgxLVxcXFx1MDk4M1xcXFx1MDliY1xcXFx1MDliZS1cXFxcdTA5YzRcXFxcdTA5YzdcXFxcdTA5YzhcXFxcdTA5ZDdcXFxcdTA5ZGYtXFxcXHUwOWUwXFxcXHUwYTAxLVxcXFx1MGEwM1xcXFx1MGEzY1xcXFx1MGEzZS1cXFxcdTBhNDJcXFxcdTBhNDdcXFxcdTBhNDhcXFxcdTBhNGItXFxcXHUwYTRkXFxcXHUwYTUxXFxcXHUwYTY2LVxcXFx1MGE3MVxcXFx1MGE3NVxcXFx1MGE4MS1cXFxcdTBhODNcXFxcdTBhYmNcXFxcdTBhYmUtXFxcXHUwYWM1XFxcXHUwYWM3LVxcXFx1MGFjOVxcXFx1MGFjYi1cXFxcdTBhY2RcXFxcdTBhZTItXFxcXHUwYWUzXFxcXHUwYWU2LVxcXFx1MGFlZlxcXFx1MGIwMS1cXFxcdTBiMDNcXFxcdTBiM2NcXFxcdTBiM2UtXFxcXHUwYjQ0XFxcXHUwYjQ3XFxcXHUwYjQ4XFxcXHUwYjRiLVxcXFx1MGI0ZFxcXFx1MGI1NlxcXFx1MGI1N1xcXFx1MGI1Zi1cXFxcdTBiNjBcXFxcdTBiNjYtXFxcXHUwYjZmXFxcXHUwYjgyXFxcXHUwYmJlLVxcXFx1MGJjMlxcXFx1MGJjNi1cXFxcdTBiYzhcXFxcdTBiY2EtXFxcXHUwYmNkXFxcXHUwYmQ3XFxcXHUwYmU2LVxcXFx1MGJlZlxcXFx1MGMwMS1cXFxcdTBjMDNcXFxcdTBjNDYtXFxcXHUwYzQ4XFxcXHUwYzRhLVxcXFx1MGM0ZFxcXFx1MGM1NVxcXFx1MGM1NlxcXFx1MGM2Mi1cXFxcdTBjNjNcXFxcdTBjNjYtXFxcXHUwYzZmXFxcXHUwYzgyXFxcXHUwYzgzXFxcXHUwY2JjXFxcXHUwY2JlLVxcXFx1MGNjNFxcXFx1MGNjNi1cXFxcdTBjYzhcXFxcdTBjY2EtXFxcXHUwY2NkXFxcXHUwY2Q1XFxcXHUwY2Q2XFxcXHUwY2UyLVxcXFx1MGNlM1xcXFx1MGNlNi1cXFxcdTBjZWZcXFxcdTBkMDJcXFxcdTBkMDNcXFxcdTBkNDYtXFxcXHUwZDQ4XFxcXHUwZDU3XFxcXHUwZDYyLVxcXFx1MGQ2M1xcXFx1MGQ2Ni1cXFxcdTBkNmZcXFxcdTBkODJcXFxcdTBkODNcXFxcdTBkY2FcXFxcdTBkY2YtXFxcXHUwZGQ0XFxcXHUwZGQ2XFxcXHUwZGQ4LVxcXFx1MGRkZlxcXFx1MGRmMlxcXFx1MGRmM1xcXFx1MGUzNC1cXFxcdTBlM2FcXFxcdTBlNDAtXFxcXHUwZTQ1XFxcXHUwZTUwLVxcXFx1MGU1OVxcXFx1MGViNC1cXFxcdTBlYjlcXFxcdTBlYzgtXFxcXHUwZWNkXFxcXHUwZWQwLVxcXFx1MGVkOVxcXFx1MGYxOFxcXFx1MGYxOVxcXFx1MGYyMC1cXFxcdTBmMjlcXFxcdTBmMzVcXFxcdTBmMzdcXFxcdTBmMzlcXFxcdTBmNDEtXFxcXHUwZjQ3XFxcXHUwZjcxLVxcXFx1MGY4NFxcXFx1MGY4Ni1cXFxcdTBmODdcXFxcdTBmOGQtXFxcXHUwZjk3XFxcXHUwZjk5LVxcXFx1MGZiY1xcXFx1MGZjNlxcXFx1MTAwMC1cXFxcdTEwMjlcXFxcdTEwNDAtXFxcXHUxMDQ5XFxcXHUxMDY3LVxcXFx1MTA2ZFxcXFx1MTA3MS1cXFxcdTEwNzRcXFxcdTEwODItXFxcXHUxMDhkXFxcXHUxMDhmLVxcXFx1MTA5ZFxcXFx1MTM1ZC1cXFxcdTEzNWZcXFxcdTE3MGUtXFxcXHUxNzEwXFxcXHUxNzIwLVxcXFx1MTczMFxcXFx1MTc0MC1cXFxcdTE3NTBcXFxcdTE3NzJcXFxcdTE3NzNcXFxcdTE3ODAtXFxcXHUxN2IyXFxcXHUxN2RkXFxcXHUxN2UwLVxcXFx1MTdlOVxcXFx1MTgwYi1cXFxcdTE4MGRcXFxcdTE4MTAtXFxcXHUxODE5XFxcXHUxOTIwLVxcXFx1MTkyYlxcXFx1MTkzMC1cXFxcdTE5M2JcXFxcdTE5NTEtXFxcXHUxOTZkXFxcXHUxOWIwLVxcXFx1MTljMFxcXFx1MTljOC1cXFxcdTE5YzlcXFxcdTE5ZDAtXFxcXHUxOWQ5XFxcXHUxYTAwLVxcXFx1MWExNVxcXFx1MWEyMC1cXFxcdTFhNTNcXFxcdTFhNjAtXFxcXHUxYTdjXFxcXHUxYTdmLVxcXFx1MWE4OVxcXFx1MWE5MC1cXFxcdTFhOTlcXFxcdTFiNDYtXFxcXHUxYjRiXFxcXHUxYjUwLVxcXFx1MWI1OVxcXFx1MWI2Yi1cXFxcdTFiNzNcXFxcdTFiYjAtXFxcXHUxYmI5XFxcXHUxYmU2LVxcXFx1MWJmM1xcXFx1MWMwMC1cXFxcdTFjMjJcXFxcdTFjNDAtXFxcXHUxYzQ5XFxcXHUxYzViLVxcXFx1MWM3ZFxcXFx1MWNkMC1cXFxcdTFjZDJcXFxcdTFkMDAtXFxcXHUxZGJlXFxcXHUxZTAxLVxcXFx1MWYxNVxcXFx1MjAwY1xcXFx1MjAwZFxcXFx1MjAzZlxcXFx1MjA0MFxcXFx1MjA1NFxcXFx1MjBkMC1cXFxcdTIwZGNcXFxcdTIwZTFcXFxcdTIwZTUtXFxcXHUyMGYwXFxcXHUyZDgxLVxcXFx1MmQ5NlxcXFx1MmRlMC1cXFxcdTJkZmZcXFxcdTMwMjEtXFxcXHUzMDI4XFxcXHUzMDk5XFxcXHUzMDlhXFxcXHVhNjQwLVxcXFx1YTY2ZFxcXFx1YTY3NC1cXFxcdWE2N2RcXFxcdWE2OWZcXFxcdWE2ZjAtXFxcXHVhNmYxXFxcXHVhN2Y4LVxcXFx1YTgwMFxcXFx1YTgwNlxcXFx1YTgwYlxcXFx1YTgyMy1cXFxcdWE4MjdcXFxcdWE4ODAtXFxcXHVhODgxXFxcXHVhOGI0LVxcXFx1YThjNFxcXFx1YThkMC1cXFxcdWE4ZDlcXFxcdWE4ZjMtXFxcXHVhOGY3XFxcXHVhOTAwLVxcXFx1YTkwOVxcXFx1YTkyNi1cXFxcdWE5MmRcXFxcdWE5MzAtXFxcXHVhOTQ1XFxcXHVhOTgwLVxcXFx1YTk4M1xcXFx1YTliMy1cXFxcdWE5YzBcXFxcdWFhMDAtXFxcXHVhYTI3XFxcXHVhYTQwLVxcXFx1YWE0MVxcXFx1YWE0Yy1cXFxcdWFhNGRcXFxcdWFhNTAtXFxcXHVhYTU5XFxcXHVhYTdiXFxcXHVhYWUwLVxcXFx1YWFlOVxcXFx1YWFmMi1cXFxcdWFhZjNcXFxcdWFiYzAtXFxcXHVhYmUxXFxcXHVhYmVjXFxcXHVhYmVkXFxcXHVhYmYwLVxcXFx1YWJmOVxcXFx1ZmIyMC1cXFxcdWZiMjhcXFxcdWZlMDAtXFxcXHVmZTBmXFxcXHVmZTIwLVxcXFx1ZmUyNlxcXFx1ZmUzM1xcXFx1ZmUzNFxcXFx1ZmU0ZC1cXFxcdWZlNGZcXFxcdWZmMTAtXFxcXHVmZjE5XFxcXHVmZjNmXCI7XG4vL3ZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydCA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgXCJdXCIpO1xuLy92YXIgbm9uQVNDSUlpZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJDaGFycyArIFwiXVwiKTtcblxudmFyIHVuaWNvZGVFc2NhcGVPckNvZGVQb2ludCA9IFwiXFxcXFxcXFx1WzAtOWEtZkEtRl17NH18XFxcXFxcXFx1XFxcXHtbMC05YS1mQS1GXStcXFxcfVwiO1xudmFyIGlkZW50aWZpZXJTdGFydCA9IFwiKD86XCIgKyB1bmljb2RlRXNjYXBlT3JDb2RlUG9pbnQgKyBcInxbXCIgKyBiYXNlQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl0pXCI7XG52YXIgaWRlbnRpZmllckNoYXJzID0gXCIoPzpcIiArIHVuaWNvZGVFc2NhcGVPckNvZGVQb2ludCArIFwifFtcIiArIGJhc2VBU0NJSWlkZW50aWZpZXJDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJDaGFycyArIFwiXSkqXCI7XG5cbmV4cG9ydHMuaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoaWRlbnRpZmllclN0YXJ0ICsgaWRlbnRpZmllckNoYXJzLCAnZycpO1xuZXhwb3J0cy5pZGVudGlmaWVyU3RhcnQgPSBuZXcgUmVnRXhwKGlkZW50aWZpZXJTdGFydCk7XG5leHBvcnRzLmlkZW50aWZpZXJNYXRjaCA9IG5ldyBSZWdFeHAoXCIoPzpcIiArIHVuaWNvZGVFc2NhcGVPckNvZGVQb2ludCArIFwifFtcIiArIGJhc2VBU0NJSWlkZW50aWZpZXJDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJDaGFycyArIFwiXSkrXCIpO1xuXG52YXIgbm9uQVNDSUl3aGl0ZXNwYWNlID0gL1tcXHUxNjgwXFx1MTgwZVxcdTIwMDAtXFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdWZlZmZdLzsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbi8vIFdoZXRoZXIgYSBzaW5nbGUgY2hhcmFjdGVyIGRlbm90ZXMgYSBuZXdsaW5lLlxuXG5leHBvcnRzLm5ld2xpbmUgPSAvW1xcblxcclxcdTIwMjhcXHUyMDI5XS87XG5cbi8vIE1hdGNoZXMgYSB3aG9sZSBsaW5lIGJyZWFrICh3aGVyZSBDUkxGIGlzIGNvbnNpZGVyZWQgYSBzaW5nbGVcbi8vIGxpbmUgYnJlYWspLiBVc2VkIHRvIGNvdW50IGxpbmVzLlxuXG4vLyBpbiBqYXZhc2NyaXB0LCB0aGVzZSB0d28gZGlmZmVyXG4vLyBpbiBweXRob24gdGhleSBhcmUgdGhlIHNhbWUsIGRpZmZlcmVudCBtZXRob2RzIGFyZSBjYWxsZWQgb24gdGhlbVxuZXhwb3J0cy5saW5lQnJlYWsgPSBuZXcgUmVnRXhwKCdcXHJcXG58JyArIGV4cG9ydHMubmV3bGluZS5zb3VyY2UpO1xuZXhwb3J0cy5hbGxMaW5lQnJlYWtzID0gbmV3IFJlZ0V4cChleHBvcnRzLmxpbmVCcmVhay5zb3VyY2UsICdnJyk7XG5cblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG52YXIgQmFzZU9wdGlvbnMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXyg2KS5PcHRpb25zKTtcblxudmFyIHZhbGlkUG9zaXRpb25WYWx1ZXMgPSBbJ2JlZm9yZS1uZXdsaW5lJywgJ2FmdGVyLW5ld2xpbmUnLCAncHJlc2VydmUtbmV3bGluZSddO1xuXG5mdW5jdGlvbiBPcHRpb25zKG9wdGlvbnMpIHtcbiAgQmFzZU9wdGlvbnMuY2FsbCh0aGlzLCBvcHRpb25zLCAnanMnKTtcblxuICAvLyBjb21wYXRpYmlsaXR5LCByZVxuICB2YXIgcmF3X2JyYWNlX3N0eWxlID0gdGhpcy5yYXdfb3B0aW9ucy5icmFjZV9zdHlsZSB8fCBudWxsO1xuICBpZiAocmF3X2JyYWNlX3N0eWxlID09PSBcImV4cGFuZC1zdHJpY3RcIikgeyAvL2dyYWNlZnVsIGhhbmRsaW5nIG9mIGRlcHJlY2F0ZWQgb3B0aW9uXG4gICAgdGhpcy5yYXdfb3B0aW9ucy5icmFjZV9zdHlsZSA9IFwiZXhwYW5kXCI7XG4gIH0gZWxzZSBpZiAocmF3X2JyYWNlX3N0eWxlID09PSBcImNvbGxhcHNlLXByZXNlcnZlLWlubGluZVwiKSB7IC8vZ3JhY2VmdWwgaGFuZGxpbmcgb2YgZGVwcmVjYXRlZCBvcHRpb25cbiAgICB0aGlzLnJhd19vcHRpb25zLmJyYWNlX3N0eWxlID0gXCJjb2xsYXBzZSxwcmVzZXJ2ZS1pbmxpbmVcIjtcbiAgfSBlbHNlIGlmICh0aGlzLnJhd19vcHRpb25zLmJyYWNlc19vbl9vd25fbGluZSAhPT0gdW5kZWZpbmVkKSB7IC8vZ3JhY2VmdWwgaGFuZGxpbmcgb2YgZGVwcmVjYXRlZCBvcHRpb25cbiAgICB0aGlzLnJhd19vcHRpb25zLmJyYWNlX3N0eWxlID0gdGhpcy5yYXdfb3B0aW9ucy5icmFjZXNfb25fb3duX2xpbmUgPyBcImV4cGFuZFwiIDogXCJjb2xsYXBzZVwiO1xuICAgIC8vIH0gZWxzZSBpZiAoIXJhd19icmFjZV9zdHlsZSkgeyAvL05vdGhpbmcgZXhpc3RzIHRvIHNldCBpdFxuICAgIC8vICAgcmF3X2JyYWNlX3N0eWxlID0gXCJjb2xsYXBzZVwiO1xuICB9XG5cbiAgLy9wcmVzZXJ2ZS1pbmxpbmUgaW4gZGVsaW1pdGVkIHN0cmluZyB3aWxsIHRyaWdnZXIgYnJhY2VfcHJlc2VydmVfaW5saW5lLCBldmVyeXRoaW5nXG4gIC8vZWxzZSBpcyBjb25zaWRlcmVkIGEgYnJhY2Vfc3R5bGUgYW5kIHRoZSBsYXN0IG9uZSBvbmx5IHdpbGwgaGF2ZSBhbiBlZmZlY3RcblxuICB2YXIgYnJhY2Vfc3R5bGVfc3BsaXQgPSB0aGlzLl9nZXRfc2VsZWN0aW9uX2xpc3QoJ2JyYWNlX3N0eWxlJywgWydjb2xsYXBzZScsICdleHBhbmQnLCAnZW5kLWV4cGFuZCcsICdub25lJywgJ3ByZXNlcnZlLWlubGluZSddKTtcblxuICB0aGlzLmJyYWNlX3ByZXNlcnZlX2lubGluZSA9IGZhbHNlOyAvL0RlZmF1bHRzIGluIGNhc2Ugb25lIG9yIG90aGVyIHdhcyBub3Qgc3BlY2lmaWVkIGluIG1ldGEtb3B0aW9uXG4gIHRoaXMuYnJhY2Vfc3R5bGUgPSBcImNvbGxhcHNlXCI7XG5cbiAgZm9yICh2YXIgYnMgPSAwOyBicyA8IGJyYWNlX3N0eWxlX3NwbGl0Lmxlbmd0aDsgYnMrKykge1xuICAgIGlmIChicmFjZV9zdHlsZV9zcGxpdFtic10gPT09IFwicHJlc2VydmUtaW5saW5lXCIpIHtcbiAgICAgIHRoaXMuYnJhY2VfcHJlc2VydmVfaW5saW5lID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5icmFjZV9zdHlsZSA9IGJyYWNlX3N0eWxlX3NwbGl0W2JzXTtcbiAgICB9XG4gIH1cblxuICB0aGlzLnVuaW5kZW50X2NoYWluZWRfbWV0aG9kcyA9IHRoaXMuX2dldF9ib29sZWFuKCd1bmluZGVudF9jaGFpbmVkX21ldGhvZHMnKTtcbiAgdGhpcy5icmVha19jaGFpbmVkX21ldGhvZHMgPSB0aGlzLl9nZXRfYm9vbGVhbignYnJlYWtfY2hhaW5lZF9tZXRob2RzJyk7XG4gIHRoaXMuc3BhY2VfaW5fcGFyZW4gPSB0aGlzLl9nZXRfYm9vbGVhbignc3BhY2VfaW5fcGFyZW4nKTtcbiAgdGhpcy5zcGFjZV9pbl9lbXB0eV9wYXJlbiA9IHRoaXMuX2dldF9ib29sZWFuKCdzcGFjZV9pbl9lbXB0eV9wYXJlbicpO1xuICB0aGlzLmpzbGludF9oYXBweSA9IHRoaXMuX2dldF9ib29sZWFuKCdqc2xpbnRfaGFwcHknKTtcbiAgdGhpcy5zcGFjZV9hZnRlcl9hbm9uX2Z1bmN0aW9uID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ3NwYWNlX2FmdGVyX2Fub25fZnVuY3Rpb24nKTtcbiAgdGhpcy5zcGFjZV9hZnRlcl9uYW1lZF9mdW5jdGlvbiA9IHRoaXMuX2dldF9ib29sZWFuKCdzcGFjZV9hZnRlcl9uYW1lZF9mdW5jdGlvbicpO1xuICB0aGlzLmtlZXBfYXJyYXlfaW5kZW50YXRpb24gPSB0aGlzLl9nZXRfYm9vbGVhbigna2VlcF9hcnJheV9pbmRlbnRhdGlvbicpO1xuICB0aGlzLnNwYWNlX2JlZm9yZV9jb25kaXRpb25hbCA9IHRoaXMuX2dldF9ib29sZWFuKCdzcGFjZV9iZWZvcmVfY29uZGl0aW9uYWwnLCB0cnVlKTtcbiAgdGhpcy51bmVzY2FwZV9zdHJpbmdzID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ3VuZXNjYXBlX3N0cmluZ3MnKTtcbiAgdGhpcy5lNHggPSB0aGlzLl9nZXRfYm9vbGVhbignZTR4Jyk7XG4gIHRoaXMuY29tbWFfZmlyc3QgPSB0aGlzLl9nZXRfYm9vbGVhbignY29tbWFfZmlyc3QnKTtcbiAgdGhpcy5vcGVyYXRvcl9wb3NpdGlvbiA9IHRoaXMuX2dldF9zZWxlY3Rpb24oJ29wZXJhdG9yX3Bvc2l0aW9uJywgdmFsaWRQb3NpdGlvblZhbHVlcyk7XG5cbiAgLy8gRm9yIHRlc3Rpbmcgb2YgYmVhdXRpZnkgcHJlc2VydmU6c3RhcnQgZGlyZWN0aXZlXG4gIHRoaXMudGVzdF9vdXRwdXRfcmF3ID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ3Rlc3Rfb3V0cHV0X3JhdycpO1xuXG4gIC8vIGZvcmNlIHRoaXMuX29wdGlvbnMuc3BhY2VfYWZ0ZXJfYW5vbl9mdW5jdGlvbiB0byB0cnVlIGlmIHRoaXMuX29wdGlvbnMuanNsaW50X2hhcHB5XG4gIGlmICh0aGlzLmpzbGludF9oYXBweSkge1xuICAgIHRoaXMuc3BhY2VfYWZ0ZXJfYW5vbl9mdW5jdGlvbiA9IHRydWU7XG4gIH1cblxufVxuT3B0aW9ucy5wcm90b3R5cGUgPSBuZXcgQmFzZU9wdGlvbnMoKTtcblxuXG5cbm1vZHVsZS5leHBvcnRzLk9wdGlvbnMgPSBPcHRpb25zO1xuXG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbmZ1bmN0aW9uIE9wdGlvbnMob3B0aW9ucywgbWVyZ2VfY2hpbGRfZmllbGQpIHtcbiAgdGhpcy5yYXdfb3B0aW9ucyA9IF9tZXJnZU9wdHMob3B0aW9ucywgbWVyZ2VfY2hpbGRfZmllbGQpO1xuXG4gIC8vIFN1cHBvcnQgcGFzc2luZyB0aGUgc291cmNlIHRleHQgYmFjayB3aXRoIG5vIGNoYW5nZVxuICB0aGlzLmRpc2FibGVkID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ2Rpc2FibGVkJyk7XG5cbiAgdGhpcy5lb2wgPSB0aGlzLl9nZXRfY2hhcmFjdGVycygnZW9sJywgJ2F1dG8nKTtcbiAgdGhpcy5lbmRfd2l0aF9uZXdsaW5lID0gdGhpcy5fZ2V0X2Jvb2xlYW4oJ2VuZF93aXRoX25ld2xpbmUnKTtcbiAgdGhpcy5pbmRlbnRfc2l6ZSA9IHRoaXMuX2dldF9udW1iZXIoJ2luZGVudF9zaXplJywgNCk7XG4gIHRoaXMuaW5kZW50X2NoYXIgPSB0aGlzLl9nZXRfY2hhcmFjdGVycygnaW5kZW50X2NoYXInLCAnICcpO1xuICB0aGlzLmluZGVudF9sZXZlbCA9IHRoaXMuX2dldF9udW1iZXIoJ2luZGVudF9sZXZlbCcpO1xuXG4gIHRoaXMucHJlc2VydmVfbmV3bGluZXMgPSB0aGlzLl9nZXRfYm9vbGVhbigncHJlc2VydmVfbmV3bGluZXMnLCB0cnVlKTtcbiAgdGhpcy5tYXhfcHJlc2VydmVfbmV3bGluZXMgPSB0aGlzLl9nZXRfbnVtYmVyKCdtYXhfcHJlc2VydmVfbmV3bGluZXMnLCAzMjc4Nik7XG4gIGlmICghdGhpcy5wcmVzZXJ2ZV9uZXdsaW5lcykge1xuICAgIHRoaXMubWF4X3ByZXNlcnZlX25ld2xpbmVzID0gMDtcbiAgfVxuXG4gIHRoaXMuaW5kZW50X3dpdGhfdGFicyA9IHRoaXMuX2dldF9ib29sZWFuKCdpbmRlbnRfd2l0aF90YWJzJywgdGhpcy5pbmRlbnRfY2hhciA9PT0gJ1xcdCcpO1xuICBpZiAodGhpcy5pbmRlbnRfd2l0aF90YWJzKSB7XG4gICAgdGhpcy5pbmRlbnRfY2hhciA9ICdcXHQnO1xuXG4gICAgLy8gaW5kZW50X3NpemUgYmVoYXZpb3IgY2hhbmdlZCBhZnRlciAxLjguNlxuICAgIC8vIEl0IHVzZWQgdG8gYmUgdGhhdCBpbmRlbnRfc2l6ZSB3b3VsZCBiZVxuICAgIC8vIHNldCB0byAxIGZvciBpbmRlbnRfd2l0aF90YWJzLiBUaGF0IGlzIG5vIGxvbmdlciBuZWVkZWQgYW5kXG4gICAgLy8gYWN0dWFsbHkgZG9lc24ndCBtYWtlIHNlbnNlIC0gd2h5IG5vdCB1c2Ugc3BhY2VzPyBGdXJ0aGVyLFxuICAgIC8vIHRoYXQgbWlnaHQgcHJvZHVjZSB1bmV4cGVjdGVkIGJlaGF2aW9yIC0gdGFicyBiZWluZyB1c2VkXG4gICAgLy8gZm9yIHNpbmdsZS1jb2x1bW4gYWxpZ25tZW50LiBTbywgd2hlbiBpbmRlbnRfd2l0aF90YWJzIGlzIHRydWVcbiAgICAvLyBhbmQgaW5kZW50X3NpemUgaXMgMSwgcmVzZXQgaW5kZW50X3NpemUgdG8gNC5cbiAgICBpZiAodGhpcy5pbmRlbnRfc2l6ZSA9PT0gMSkge1xuICAgICAgdGhpcy5pbmRlbnRfc2l6ZSA9IDQ7XG4gICAgfVxuICB9XG5cbiAgLy8gQmFja3dhcmRzIGNvbXBhdCB3aXRoIDEuMy54XG4gIHRoaXMud3JhcF9saW5lX2xlbmd0aCA9IHRoaXMuX2dldF9udW1iZXIoJ3dyYXBfbGluZV9sZW5ndGgnLCB0aGlzLl9nZXRfbnVtYmVyKCdtYXhfY2hhcicpKTtcblxuICB0aGlzLmluZGVudF9lbXB0eV9saW5lcyA9IHRoaXMuX2dldF9ib29sZWFuKCdpbmRlbnRfZW1wdHlfbGluZXMnKTtcblxuICAvLyB2YWxpZCB0ZW1wbGF0aW5nIGxhbmd1YWdlcyBbJ2RqYW5nbycsICdlcmInLCAnaGFuZGxlYmFycycsICdwaHAnLCAnc21hcnR5J11cbiAgLy8gRm9yIG5vdywgJ2F1dG8nID0gYWxsIG9mZiBmb3IgamF2YXNjcmlwdCwgYWxsIG9uIGZvciBodG1sIChhbmQgaW5saW5lIGphdmFzY3JpcHQpLlxuICAvLyBvdGhlciB2YWx1ZXMgaWdub3JlZFxuICB0aGlzLnRlbXBsYXRpbmcgPSB0aGlzLl9nZXRfc2VsZWN0aW9uX2xpc3QoJ3RlbXBsYXRpbmcnLCBbJ2F1dG8nLCAnbm9uZScsICdkamFuZ28nLCAnZXJiJywgJ2hhbmRsZWJhcnMnLCAncGhwJywgJ3NtYXJ0eSddLCBbJ2F1dG8nXSk7XG59XG5cbk9wdGlvbnMucHJvdG90eXBlLl9nZXRfYXJyYXkgPSBmdW5jdGlvbihuYW1lLCBkZWZhdWx0X3ZhbHVlKSB7XG4gIHZhciBvcHRpb25fdmFsdWUgPSB0aGlzLnJhd19vcHRpb25zW25hbWVdO1xuICB2YXIgcmVzdWx0ID0gZGVmYXVsdF92YWx1ZSB8fCBbXTtcbiAgaWYgKHR5cGVvZiBvcHRpb25fdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKG9wdGlvbl92YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2Ygb3B0aW9uX3ZhbHVlLmNvbmNhdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVzdWx0ID0gb3B0aW9uX3ZhbHVlLmNvbmNhdCgpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9uX3ZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJlc3VsdCA9IG9wdGlvbl92YWx1ZS5zcGxpdCgvW15hLXpBLVowLTlfXFwvXFwtXSsvKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuT3B0aW9ucy5wcm90b3R5cGUuX2dldF9ib29sZWFuID0gZnVuY3Rpb24obmFtZSwgZGVmYXVsdF92YWx1ZSkge1xuICB2YXIgb3B0aW9uX3ZhbHVlID0gdGhpcy5yYXdfb3B0aW9uc1tuYW1lXTtcbiAgdmFyIHJlc3VsdCA9IG9wdGlvbl92YWx1ZSA9PT0gdW5kZWZpbmVkID8gISFkZWZhdWx0X3ZhbHVlIDogISFvcHRpb25fdmFsdWU7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5PcHRpb25zLnByb3RvdHlwZS5fZ2V0X2NoYXJhY3RlcnMgPSBmdW5jdGlvbihuYW1lLCBkZWZhdWx0X3ZhbHVlKSB7XG4gIHZhciBvcHRpb25fdmFsdWUgPSB0aGlzLnJhd19vcHRpb25zW25hbWVdO1xuICB2YXIgcmVzdWx0ID0gZGVmYXVsdF92YWx1ZSB8fCAnJztcbiAgaWYgKHR5cGVvZiBvcHRpb25fdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmVzdWx0ID0gb3B0aW9uX3ZhbHVlLnJlcGxhY2UoL1xcXFxyLywgJ1xccicpLnJlcGxhY2UoL1xcXFxuLywgJ1xcbicpLnJlcGxhY2UoL1xcXFx0LywgJ1xcdCcpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5PcHRpb25zLnByb3RvdHlwZS5fZ2V0X251bWJlciA9IGZ1bmN0aW9uKG5hbWUsIGRlZmF1bHRfdmFsdWUpIHtcbiAgdmFyIG9wdGlvbl92YWx1ZSA9IHRoaXMucmF3X29wdGlvbnNbbmFtZV07XG4gIGRlZmF1bHRfdmFsdWUgPSBwYXJzZUludChkZWZhdWx0X3ZhbHVlLCAxMCk7XG4gIGlmIChpc05hTihkZWZhdWx0X3ZhbHVlKSkge1xuICAgIGRlZmF1bHRfdmFsdWUgPSAwO1xuICB9XG4gIHZhciByZXN1bHQgPSBwYXJzZUludChvcHRpb25fdmFsdWUsIDEwKTtcbiAgaWYgKGlzTmFOKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBkZWZhdWx0X3ZhbHVlO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5PcHRpb25zLnByb3RvdHlwZS5fZ2V0X3NlbGVjdGlvbiA9IGZ1bmN0aW9uKG5hbWUsIHNlbGVjdGlvbl9saXN0LCBkZWZhdWx0X3ZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9nZXRfc2VsZWN0aW9uX2xpc3QobmFtZSwgc2VsZWN0aW9uX2xpc3QsIGRlZmF1bHRfdmFsdWUpO1xuICBpZiAocmVzdWx0Lmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiSW52YWxpZCBPcHRpb24gVmFsdWU6IFRoZSBvcHRpb24gJ1wiICsgbmFtZSArIFwiJyBjYW4gb25seSBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XFxuXCIgK1xuICAgICAgc2VsZWN0aW9uX2xpc3QgKyBcIlxcbllvdSBwYXNzZWQgaW46ICdcIiArIHRoaXMucmF3X29wdGlvbnNbbmFtZV0gKyBcIidcIik7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0WzBdO1xufTtcblxuXG5PcHRpb25zLnByb3RvdHlwZS5fZ2V0X3NlbGVjdGlvbl9saXN0ID0gZnVuY3Rpb24obmFtZSwgc2VsZWN0aW9uX2xpc3QsIGRlZmF1bHRfdmFsdWUpIHtcbiAgaWYgKCFzZWxlY3Rpb25fbGlzdCB8fCBzZWxlY3Rpb25fbGlzdC5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWxlY3Rpb24gbGlzdCBjYW5ub3QgYmUgZW1wdHkuXCIpO1xuICB9XG5cbiAgZGVmYXVsdF92YWx1ZSA9IGRlZmF1bHRfdmFsdWUgfHwgW3NlbGVjdGlvbl9saXN0WzBdXTtcbiAgaWYgKCF0aGlzLl9pc192YWxpZF9zZWxlY3Rpb24oZGVmYXVsdF92YWx1ZSwgc2VsZWN0aW9uX2xpc3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBEZWZhdWx0IFZhbHVlIVwiKTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSB0aGlzLl9nZXRfYXJyYXkobmFtZSwgZGVmYXVsdF92YWx1ZSk7XG4gIGlmICghdGhpcy5faXNfdmFsaWRfc2VsZWN0aW9uKHJlc3VsdCwgc2VsZWN0aW9uX2xpc3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJJbnZhbGlkIE9wdGlvbiBWYWx1ZTogVGhlIG9wdGlvbiAnXCIgKyBuYW1lICsgXCInIGNhbiBjb250YWluIG9ubHkgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XFxuXCIgK1xuICAgICAgc2VsZWN0aW9uX2xpc3QgKyBcIlxcbllvdSBwYXNzZWQgaW46ICdcIiArIHRoaXMucmF3X29wdGlvbnNbbmFtZV0gKyBcIidcIik7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuT3B0aW9ucy5wcm90b3R5cGUuX2lzX3ZhbGlkX3NlbGVjdGlvbiA9IGZ1bmN0aW9uKHJlc3VsdCwgc2VsZWN0aW9uX2xpc3QpIHtcbiAgcmV0dXJuIHJlc3VsdC5sZW5ndGggJiYgc2VsZWN0aW9uX2xpc3QubGVuZ3RoICYmXG4gICAgIXJlc3VsdC5zb21lKGZ1bmN0aW9uKGl0ZW0pIHsgcmV0dXJuIHNlbGVjdGlvbl9saXN0LmluZGV4T2YoaXRlbSkgPT09IC0xOyB9KTtcbn07XG5cblxuLy8gbWVyZ2VzIGNoaWxkIG9wdGlvbnMgdXAgd2l0aCB0aGUgcGFyZW50IG9wdGlvbnMgb2JqZWN0XG4vLyBFeGFtcGxlOiBvYmogPSB7YTogMSwgYjoge2E6IDJ9fVxuLy8gICAgICAgICAgbWVyZ2VPcHRzKG9iaiwgJ2InKVxuLy9cbi8vICAgICAgICAgIFJldHVybnM6IHthOiAyfVxuZnVuY3Rpb24gX21lcmdlT3B0cyhhbGxPcHRpb25zLCBjaGlsZEZpZWxkTmFtZSkge1xuICB2YXIgZmluYWxPcHRzID0ge307XG4gIGFsbE9wdGlvbnMgPSBfbm9ybWFsaXplT3B0cyhhbGxPcHRpb25zKTtcbiAgdmFyIG5hbWU7XG5cbiAgZm9yIChuYW1lIGluIGFsbE9wdGlvbnMpIHtcbiAgICBpZiAobmFtZSAhPT0gY2hpbGRGaWVsZE5hbWUpIHtcbiAgICAgIGZpbmFsT3B0c1tuYW1lXSA9IGFsbE9wdGlvbnNbbmFtZV07XG4gICAgfVxuICB9XG5cbiAgLy9tZXJnZSBpbiB0aGUgcGVyIHR5cGUgc2V0dGluZ3MgZm9yIHRoZSBjaGlsZEZpZWxkTmFtZVxuICBpZiAoY2hpbGRGaWVsZE5hbWUgJiYgYWxsT3B0aW9uc1tjaGlsZEZpZWxkTmFtZV0pIHtcbiAgICBmb3IgKG5hbWUgaW4gYWxsT3B0aW9uc1tjaGlsZEZpZWxkTmFtZV0pIHtcbiAgICAgIGZpbmFsT3B0c1tuYW1lXSA9IGFsbE9wdGlvbnNbY2hpbGRGaWVsZE5hbWVdW25hbWVdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmluYWxPcHRzO1xufVxuXG5mdW5jdGlvbiBfbm9ybWFsaXplT3B0cyhvcHRpb25zKSB7XG4gIHZhciBjb252ZXJ0ZWRPcHRzID0ge307XG4gIHZhciBrZXk7XG5cbiAgZm9yIChrZXkgaW4gb3B0aW9ucykge1xuICAgIHZhciBuZXdLZXkgPSBrZXkucmVwbGFjZSgvLS9nLCBcIl9cIik7XG4gICAgY29udmVydGVkT3B0c1tuZXdLZXldID0gb3B0aW9uc1trZXldO1xuICB9XG4gIHJldHVybiBjb252ZXJ0ZWRPcHRzO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5PcHRpb25zID0gT3B0aW9ucztcbm1vZHVsZS5leHBvcnRzLm5vcm1hbGl6ZU9wdHMgPSBfbm9ybWFsaXplT3B0cztcbm1vZHVsZS5leHBvcnRzLm1lcmdlT3B0cyA9IF9tZXJnZU9wdHM7XG5cblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG52YXIgSW5wdXRTY2FubmVyID0gKF9fd2VicGFja19yZXF1aXJlX18oOCkuSW5wdXRTY2FubmVyKTtcbnZhciBCYXNlVG9rZW5pemVyID0gKF9fd2VicGFja19yZXF1aXJlX18oOSkuVG9rZW5pemVyKTtcbnZhciBCQVNFVE9LRU4gPSAoX193ZWJwYWNrX3JlcXVpcmVfXyg5KS5UT0tFTik7XG52YXIgRGlyZWN0aXZlcyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKS5EaXJlY3RpdmVzKTtcbnZhciBhY29ybiA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG52YXIgUGF0dGVybiA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKS5QYXR0ZXJuKTtcbnZhciBUZW1wbGF0YWJsZVBhdHRlcm4gPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxNCkuVGVtcGxhdGFibGVQYXR0ZXJuKTtcblxuXG5mdW5jdGlvbiBpbl9hcnJheSh3aGF0LCBhcnIpIHtcbiAgcmV0dXJuIGFyci5pbmRleE9mKHdoYXQpICE9PSAtMTtcbn1cblxuXG52YXIgVE9LRU4gPSB7XG4gIFNUQVJUX0VYUFI6ICdUS19TVEFSVF9FWFBSJyxcbiAgRU5EX0VYUFI6ICdUS19FTkRfRVhQUicsXG4gIFNUQVJUX0JMT0NLOiAnVEtfU1RBUlRfQkxPQ0snLFxuICBFTkRfQkxPQ0s6ICdUS19FTkRfQkxPQ0snLFxuICBXT1JEOiAnVEtfV09SRCcsXG4gIFJFU0VSVkVEOiAnVEtfUkVTRVJWRUQnLFxuICBTRU1JQ09MT046ICdUS19TRU1JQ09MT04nLFxuICBTVFJJTkc6ICdUS19TVFJJTkcnLFxuICBFUVVBTFM6ICdUS19FUVVBTFMnLFxuICBPUEVSQVRPUjogJ1RLX09QRVJBVE9SJyxcbiAgQ09NTUE6ICdUS19DT01NQScsXG4gIEJMT0NLX0NPTU1FTlQ6ICdUS19CTE9DS19DT01NRU5UJyxcbiAgQ09NTUVOVDogJ1RLX0NPTU1FTlQnLFxuICBET1Q6ICdUS19ET1QnLFxuICBVTktOT1dOOiAnVEtfVU5LTk9XTicsXG4gIFNUQVJUOiBCQVNFVE9LRU4uU1RBUlQsXG4gIFJBVzogQkFTRVRPS0VOLlJBVyxcbiAgRU9GOiBCQVNFVE9LRU4uRU9GXG59O1xuXG5cbnZhciBkaXJlY3RpdmVzX2NvcmUgPSBuZXcgRGlyZWN0aXZlcygvXFwvXFwqLywgL1xcKlxcLy8pO1xuXG52YXIgbnVtYmVyX3BhdHRlcm4gPSAvMFt4WF1bMDEyMzQ1Njc4OWFiY2RlZkFCQ0RFRl9dKm4/fDBbb09dWzAxMjM0NTY3X10qbj98MFtiQl1bMDFfXSpuP3xcXGRbXFxkX10qbnwoPzpcXC5cXGRbXFxkX10qfFxcZFtcXGRfXSpcXC4/W1xcZF9dKikoPzpbZUVdWystXT9bXFxkX10rKT8vO1xuXG52YXIgZGlnaXQgPSAvWzAtOV0vO1xuXG4vLyBEb3QgXCIuXCIgbXVzdCBiZSBkaXN0aW5ndWlzaGVkIGZyb20gXCIuLi5cIiBhbmQgZGVjaW1hbFxudmFyIGRvdF9wYXR0ZXJuID0gL1teXFxkXFwuXS87XG5cbnZhciBwb3NpdGlvbmFibGVfb3BlcmF0b3JzID0gKFxuICBcIj4+PiA9PT0gIT09ICYmPSA/Pz0gfHw9IFwiICtcbiAgXCI8PCAmJiA+PSAqKiAhPSA9PSA8PSA+PiB8fCA/PyB8PiBcIiArXG4gIFwiPCAvIC0gKyA+IDogJiAlID8gXiB8ICpcIikuc3BsaXQoJyAnKTtcblxuLy8gSU1QT1JUQU5UOiB0aGlzIG11c3QgYmUgc29ydGVkIGxvbmdlc3QgdG8gc2hvcnRlc3Qgb3IgdG9rZW5pemluZyBtYW55IG5vdCB3b3JrLlxuLy8gQWxzbywgeW91IG11c3QgdXBkYXRlIHBvc3NpdGlvbmFibGUgb3BlcmF0b3JzIHNlcGFyYXRlbHkgZnJvbSBwdW5jdFxudmFyIHB1bmN0ID1cbiAgXCI+Pj49IFwiICtcbiAgXCIuLi4gPj49IDw8PSA9PT0gPj4+ICE9PSAqKj0gJiY9ID8/PSB8fD0gXCIgK1xuICBcIj0+IF49IDo6IC89IDw8IDw9ID09ICYmIC09ID49ID4+ICE9IC0tICs9ICoqIHx8ID8/ICsrICU9ICY9ICo9IHw9IHw+IFwiICtcbiAgXCI9ICEgPyA+IDwgOiAvIF4gLSArICogJiAlIH4gfFwiO1xuXG5wdW5jdCA9IHB1bmN0LnJlcGxhY2UoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXS9nLCBcIlxcXFwkJlwiKTtcbi8vID8uIGJ1dCBub3QgaWYgZm9sbG93ZWQgYnkgYSBudW1iZXIgXG5wdW5jdCA9ICdcXFxcP1xcXFwuKD8hXFxcXGQpICcgKyBwdW5jdDtcbnB1bmN0ID0gcHVuY3QucmVwbGFjZSgvIC9nLCAnfCcpO1xuXG52YXIgcHVuY3RfcGF0dGVybiA9IG5ldyBSZWdFeHAocHVuY3QpO1xuXG4vLyB3b3JkcyB3aGljaCBzaG91bGQgYWx3YXlzIHN0YXJ0IG9uIG5ldyBsaW5lLlxudmFyIGxpbmVfc3RhcnRlcnMgPSAnY29udGludWUsdHJ5LHRocm93LHJldHVybix2YXIsbGV0LGNvbnN0LGlmLHN3aXRjaCxjYXNlLGRlZmF1bHQsZm9yLHdoaWxlLGJyZWFrLGZ1bmN0aW9uLGltcG9ydCxleHBvcnQnLnNwbGl0KCcsJyk7XG52YXIgcmVzZXJ2ZWRfd29yZHMgPSBsaW5lX3N0YXJ0ZXJzLmNvbmNhdChbJ2RvJywgJ2luJywgJ29mJywgJ2Vsc2UnLCAnZ2V0JywgJ3NldCcsICduZXcnLCAnY2F0Y2gnLCAnZmluYWxseScsICd0eXBlb2YnLCAneWllbGQnLCAnYXN5bmMnLCAnYXdhaXQnLCAnZnJvbScsICdhcycsICdjbGFzcycsICdleHRlbmRzJ10pO1xudmFyIHJlc2VydmVkX3dvcmRfcGF0dGVybiA9IG5ldyBSZWdFeHAoJ14oPzonICsgcmVzZXJ2ZWRfd29yZHMuam9pbignfCcpICsgJykkJyk7XG5cbi8vIHZhciB0ZW1wbGF0ZV9wYXR0ZXJuID0gLyg/Oig/OjxcXD9waHB8PFxcPz0pW1xcc1xcU10qP1xcPz4pfCg/OjwlW1xcc1xcU10qPyU+KS9nO1xuXG52YXIgaW5faHRtbF9jb21tZW50O1xuXG52YXIgVG9rZW5pemVyID0gZnVuY3Rpb24oaW5wdXRfc3RyaW5nLCBvcHRpb25zKSB7XG4gIEJhc2VUb2tlbml6ZXIuY2FsbCh0aGlzLCBpbnB1dF9zdHJpbmcsIG9wdGlvbnMpO1xuXG4gIHRoaXMuX3BhdHRlcm5zLndoaXRlc3BhY2UgPSB0aGlzLl9wYXR0ZXJucy53aGl0ZXNwYWNlLm1hdGNoaW5nKFxuICAgIC9cXHUwMEEwXFx1MTY4MFxcdTE4MGVcXHUyMDAwLVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmLy5zb3VyY2UsXG4gICAgL1xcdTIwMjhcXHUyMDI5Ly5zb3VyY2UpO1xuXG4gIHZhciBwYXR0ZXJuX3JlYWRlciA9IG5ldyBQYXR0ZXJuKHRoaXMuX2lucHV0KTtcbiAgdmFyIHRlbXBsYXRhYmxlID0gbmV3IFRlbXBsYXRhYmxlUGF0dGVybih0aGlzLl9pbnB1dClcbiAgICAucmVhZF9vcHRpb25zKHRoaXMuX29wdGlvbnMpO1xuXG4gIHRoaXMuX19wYXR0ZXJucyA9IHtcbiAgICB0ZW1wbGF0ZTogdGVtcGxhdGFibGUsXG4gICAgaWRlbnRpZmllcjogdGVtcGxhdGFibGUuc3RhcnRpbmdfd2l0aChhY29ybi5pZGVudGlmaWVyKS5tYXRjaGluZyhhY29ybi5pZGVudGlmaWVyTWF0Y2gpLFxuICAgIG51bWJlcjogcGF0dGVybl9yZWFkZXIubWF0Y2hpbmcobnVtYmVyX3BhdHRlcm4pLFxuICAgIHB1bmN0OiBwYXR0ZXJuX3JlYWRlci5tYXRjaGluZyhwdW5jdF9wYXR0ZXJuKSxcbiAgICAvLyBjb21tZW50IGVuZHMganVzdCBiZWZvcmUgbmVhcmVzdCBsaW5lZmVlZCBvciBlbmQgb2YgZmlsZVxuICAgIGNvbW1lbnQ6IHBhdHRlcm5fcmVhZGVyLnN0YXJ0aW5nX3dpdGgoL1xcL1xcLy8pLnVudGlsKC9bXFxuXFxyXFx1MjAyOFxcdTIwMjldLyksXG4gICAgLy8gIC8qIC4uLiAqLyBjb21tZW50IGVuZHMgd2l0aCBuZWFyZXN0ICovIG9yIGVuZCBvZiBmaWxlXG4gICAgYmxvY2tfY29tbWVudDogcGF0dGVybl9yZWFkZXIuc3RhcnRpbmdfd2l0aCgvXFwvXFwqLykudW50aWxfYWZ0ZXIoL1xcKlxcLy8pLFxuICAgIGh0bWxfY29tbWVudF9zdGFydDogcGF0dGVybl9yZWFkZXIubWF0Y2hpbmcoLzwhLS0vKSxcbiAgICBodG1sX2NvbW1lbnRfZW5kOiBwYXR0ZXJuX3JlYWRlci5tYXRjaGluZygvLS0+LyksXG4gICAgaW5jbHVkZTogcGF0dGVybl9yZWFkZXIuc3RhcnRpbmdfd2l0aCgvI2luY2x1ZGUvKS51bnRpbF9hZnRlcihhY29ybi5saW5lQnJlYWspLFxuICAgIHNoZWJhbmc6IHBhdHRlcm5fcmVhZGVyLnN0YXJ0aW5nX3dpdGgoLyMhLykudW50aWxfYWZ0ZXIoYWNvcm4ubGluZUJyZWFrKSxcbiAgICB4bWw6IHBhdHRlcm5fcmVhZGVyLm1hdGNoaW5nKC9bXFxzXFxTXSo/PChcXC8/KShbLWEtekEtWjowLTlfLl0rfHtbXn1dKz99fCFcXFtDREFUQVxcW1teXFxdXSo/XFxdXFxdfCkoXFxzKntbXn1dKz99fFxccytbLWEtekEtWjowLTlfLl0rfFxccytbLWEtekEtWjowLTlfLl0rXFxzKj1cXHMqKCdbXiddKid8XCJbXlwiXSpcInx7KFtee31dfHtbXn1dKz99KSs/fSkpKlxccyooXFwvPylcXHMqPi8pLFxuICAgIHNpbmdsZV9xdW90ZTogdGVtcGxhdGFibGUudW50aWwoL1snXFxcXFxcblxcclxcdTIwMjhcXHUyMDI5XS8pLFxuICAgIGRvdWJsZV9xdW90ZTogdGVtcGxhdGFibGUudW50aWwoL1tcIlxcXFxcXG5cXHJcXHUyMDI4XFx1MjAyOV0vKSxcbiAgICB0ZW1wbGF0ZV90ZXh0OiB0ZW1wbGF0YWJsZS51bnRpbCgvW2BcXFxcJF0vKSxcbiAgICB0ZW1wbGF0ZV9leHByZXNzaW9uOiB0ZW1wbGF0YWJsZS51bnRpbCgvW2B9XFxcXF0vKVxuICB9O1xuXG59O1xuVG9rZW5pemVyLnByb3RvdHlwZSA9IG5ldyBCYXNlVG9rZW5pemVyKCk7XG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX2NvbW1lbnQgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIHJldHVybiBjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLkNPTU1FTlQgfHwgY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5CTE9DS19DT01NRU5UIHx8IGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uVU5LTk9XTjtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX29wZW5pbmcgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7XG4gIHJldHVybiBjdXJyZW50X3Rva2VuLnR5cGUgPT09IFRPS0VOLlNUQVJUX0JMT0NLIHx8IGN1cnJlbnRfdG9rZW4udHlwZSA9PT0gVE9LRU4uU1RBUlRfRVhQUjtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX2Nsb3NpbmcgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuLCBvcGVuX3Rva2VuKSB7XG4gIHJldHVybiAoY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5FTkRfQkxPQ0sgfHwgY3VycmVudF90b2tlbi50eXBlID09PSBUT0tFTi5FTkRfRVhQUikgJiZcbiAgICAob3Blbl90b2tlbiAmJiAoXG4gICAgICAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnXScgJiYgb3Blbl90b2tlbi50ZXh0ID09PSAnWycpIHx8XG4gICAgICAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnKScgJiYgb3Blbl90b2tlbi50ZXh0ID09PSAnKCcpIHx8XG4gICAgICAoY3VycmVudF90b2tlbi50ZXh0ID09PSAnfScgJiYgb3Blbl90b2tlbi50ZXh0ID09PSAneycpKSk7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uKCkge1xuICBpbl9odG1sX2NvbW1lbnQgPSBmYWxzZTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2dldF9uZXh0X3Rva2VuID0gZnVuY3Rpb24ocHJldmlvdXNfdG9rZW4sIG9wZW5fdG9rZW4pIHsgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuICB2YXIgdG9rZW4gPSBudWxsO1xuICB0aGlzLl9yZWFkV2hpdGVzcGFjZSgpO1xuICB2YXIgYyA9IHRoaXMuX2lucHV0LnBlZWsoKTtcblxuICBpZiAoYyA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uRU9GLCAnJyk7XG4gIH1cblxuICB0b2tlbiA9IHRva2VuIHx8IHRoaXMuX3JlYWRfbm9uX2phdmFzY3JpcHQoYyk7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9zdHJpbmcoYyk7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9wYWlyKGMsIHRoaXMuX2lucHV0LnBlZWsoMSkpOyAvLyBJc3N1ZSAjMjA2MiBoYWNrIGZvciByZWNvcmQgdHlwZSAnI3snXG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF93b3JkKHByZXZpb3VzX3Rva2VuKTtcbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9yZWFkX3NpbmdsZXMoYyk7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9jb21tZW50KGMpO1xuICB0b2tlbiA9IHRva2VuIHx8IHRoaXMuX3JlYWRfcmVnZXhwKGMsIHByZXZpb3VzX3Rva2VuKTtcbiAgdG9rZW4gPSB0b2tlbiB8fCB0aGlzLl9yZWFkX3htbChjLCBwcmV2aW91c190b2tlbik7XG4gIHRva2VuID0gdG9rZW4gfHwgdGhpcy5fcmVhZF9wdW5jdHVhdGlvbigpO1xuICB0b2tlbiA9IHRva2VuIHx8IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5VTktOT1dOLCB0aGlzLl9pbnB1dC5uZXh0KCkpO1xuXG4gIHJldHVybiB0b2tlbjtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfd29yZCA9IGZ1bmN0aW9uKHByZXZpb3VzX3Rva2VuKSB7XG4gIHZhciByZXN1bHRpbmdfc3RyaW5nO1xuICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5fX3BhdHRlcm5zLmlkZW50aWZpZXIucmVhZCgpO1xuICBpZiAocmVzdWx0aW5nX3N0cmluZyAhPT0gJycpIHtcbiAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZy5yZXBsYWNlKGFjb3JuLmFsbExpbmVCcmVha3MsICdcXG4nKTtcbiAgICBpZiAoIShwcmV2aW91c190b2tlbi50eXBlID09PSBUT0tFTi5ET1QgfHxcbiAgICAgICAgKHByZXZpb3VzX3Rva2VuLnR5cGUgPT09IFRPS0VOLlJFU0VSVkVEICYmIChwcmV2aW91c190b2tlbi50ZXh0ID09PSAnc2V0JyB8fCBwcmV2aW91c190b2tlbi50ZXh0ID09PSAnZ2V0JykpKSAmJlxuICAgICAgcmVzZXJ2ZWRfd29yZF9wYXR0ZXJuLnRlc3QocmVzdWx0aW5nX3N0cmluZykpIHtcbiAgICAgIGlmICgocmVzdWx0aW5nX3N0cmluZyA9PT0gJ2luJyB8fCByZXN1bHRpbmdfc3RyaW5nID09PSAnb2YnKSAmJlxuICAgICAgICAocHJldmlvdXNfdG9rZW4udHlwZSA9PT0gVE9LRU4uV09SRCB8fCBwcmV2aW91c190b2tlbi50eXBlID09PSBUT0tFTi5TVFJJTkcpKSB7IC8vIGhhY2sgZm9yICdpbicgYW5kICdvZicgb3BlcmF0b3JzXG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uT1BFUkFUT1IsIHJlc3VsdGluZ19zdHJpbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5SRVNFUlZFRCwgcmVzdWx0aW5nX3N0cmluZyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uV09SRCwgcmVzdWx0aW5nX3N0cmluZyk7XG4gIH1cblxuICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5fX3BhdHRlcm5zLm51bWJlci5yZWFkKCk7XG4gIGlmIChyZXN1bHRpbmdfc3RyaW5nICE9PSAnJykge1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uV09SRCwgcmVzdWx0aW5nX3N0cmluZyk7XG4gIH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfc2luZ2xlcyA9IGZ1bmN0aW9uKGMpIHtcbiAgdmFyIHRva2VuID0gbnVsbDtcbiAgaWYgKGMgPT09ICcoJyB8fCBjID09PSAnWycpIHtcbiAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5TVEFSVF9FWFBSLCBjKTtcbiAgfSBlbHNlIGlmIChjID09PSAnKScgfHwgYyA9PT0gJ10nKSB7XG4gICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uRU5EX0VYUFIsIGMpO1xuICB9IGVsc2UgaWYgKGMgPT09ICd7Jykge1xuICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlNUQVJUX0JMT0NLLCBjKTtcbiAgfSBlbHNlIGlmIChjID09PSAnfScpIHtcbiAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5FTkRfQkxPQ0ssIGMpO1xuICB9IGVsc2UgaWYgKGMgPT09ICc7Jykge1xuICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlNFTUlDT0xPTiwgYyk7XG4gIH0gZWxzZSBpZiAoYyA9PT0gJy4nICYmIGRvdF9wYXR0ZXJuLnRlc3QodGhpcy5faW5wdXQucGVlaygxKSkpIHtcbiAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5ET1QsIGMpO1xuICB9IGVsc2UgaWYgKGMgPT09ICcsJykge1xuICAgIHRva2VuID0gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLkNPTU1BLCBjKTtcbiAgfVxuXG4gIGlmICh0b2tlbikge1xuICAgIHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgfVxuICByZXR1cm4gdG9rZW47XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX3BhaXIgPSBmdW5jdGlvbihjLCBkKSB7XG4gIHZhciB0b2tlbiA9IG51bGw7XG4gIGlmIChjID09PSAnIycgJiYgZCA9PT0gJ3snKSB7XG4gICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uU1RBUlRfQkxPQ0ssIGMgKyBkKTtcbiAgfVxuXG4gIGlmICh0b2tlbikge1xuICAgIHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gIH1cbiAgcmV0dXJuIHRva2VuO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZF9wdW5jdHVhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzdWx0aW5nX3N0cmluZyA9IHRoaXMuX19wYXR0ZXJucy5wdW5jdC5yZWFkKCk7XG5cbiAgaWYgKHJlc3VsdGluZ19zdHJpbmcgIT09ICcnKSB7XG4gICAgaWYgKHJlc3VsdGluZ19zdHJpbmcgPT09ICc9Jykge1xuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5FUVVBTFMsIHJlc3VsdGluZ19zdHJpbmcpO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0aW5nX3N0cmluZyA9PT0gJz8uJykge1xuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5ET1QsIHJlc3VsdGluZ19zdHJpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLk9QRVJBVE9SLCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICB9XG4gIH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfbm9uX2phdmFzY3JpcHQgPSBmdW5jdGlvbihjKSB7XG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gJyc7XG5cbiAgaWYgKGMgPT09ICcjJykge1xuICAgIGlmICh0aGlzLl9pc19maXJzdF90b2tlbigpKSB7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5fX3BhdHRlcm5zLnNoZWJhbmcucmVhZCgpO1xuXG4gICAgICBpZiAocmVzdWx0aW5nX3N0cmluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlVOS05PV04sIHJlc3VsdGluZ19zdHJpbmcudHJpbSgpICsgJ1xcbicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGhhbmRsZXMgZXh0ZW5kc2NyaXB0ICNpbmNsdWRlc1xuICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMuaW5jbHVkZS5yZWFkKCk7XG5cbiAgICBpZiAocmVzdWx0aW5nX3N0cmluZykge1xuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5VTktOT1dOLCByZXN1bHRpbmdfc3RyaW5nLnRyaW0oKSArICdcXG4nKTtcbiAgICB9XG5cbiAgICBjID0gdGhpcy5faW5wdXQubmV4dCgpO1xuXG4gICAgLy8gU3BpZGVybW9ua2V5LXNwZWNpZmljIHNoYXJwIHZhcmlhYmxlcyBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcy4gQ29uc2lkZXJlZCBvYnNvbGV0ZS5cbiAgICB2YXIgc2hhcnAgPSAnIyc7XG4gICAgaWYgKHRoaXMuX2lucHV0Lmhhc05leHQoKSAmJiB0aGlzLl9pbnB1dC50ZXN0Q2hhcihkaWdpdCkpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgYyA9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICAgICAgc2hhcnAgKz0gYztcbiAgICAgIH0gd2hpbGUgKHRoaXMuX2lucHV0Lmhhc05leHQoKSAmJiBjICE9PSAnIycgJiYgYyAhPT0gJz0nKTtcbiAgICAgIGlmIChjID09PSAnIycpIHtcbiAgICAgICAgLy9cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5faW5wdXQucGVlaygpID09PSAnWycgJiYgdGhpcy5faW5wdXQucGVlaygxKSA9PT0gJ10nKSB7XG4gICAgICAgIHNoYXJwICs9ICdbXSc7XG4gICAgICAgIHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICAgICAgdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9pbnB1dC5wZWVrKCkgPT09ICd7JyAmJiB0aGlzLl9pbnB1dC5wZWVrKDEpID09PSAnfScpIHtcbiAgICAgICAgc2hhcnAgKz0gJ3t9JztcbiAgICAgICAgdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgICB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLldPUkQsIHNoYXJwKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pbnB1dC5iYWNrKCk7XG5cbiAgfSBlbHNlIGlmIChjID09PSAnPCcgJiYgdGhpcy5faXNfZmlyc3RfdG9rZW4oKSkge1xuICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMuaHRtbF9jb21tZW50X3N0YXJ0LnJlYWQoKTtcbiAgICBpZiAocmVzdWx0aW5nX3N0cmluZykge1xuICAgICAgd2hpbGUgKHRoaXMuX2lucHV0Lmhhc05leHQoKSAmJiAhdGhpcy5faW5wdXQudGVzdENoYXIoYWNvcm4ubmV3bGluZSkpIHtcbiAgICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICB9XG4gICAgICBpbl9odG1sX2NvbW1lbnQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5DT01NRU5ULCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaW5faHRtbF9jb21tZW50ICYmIGMgPT09ICctJykge1xuICAgIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9fcGF0dGVybnMuaHRtbF9jb21tZW50X2VuZC5yZWFkKCk7XG4gICAgaWYgKHJlc3VsdGluZ19zdHJpbmcpIHtcbiAgICAgIGluX2h0bWxfY29tbWVudCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5DT01NRU5ULCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfY29tbWVudCA9IGZ1bmN0aW9uKGMpIHtcbiAgdmFyIHRva2VuID0gbnVsbDtcbiAgaWYgKGMgPT09ICcvJykge1xuICAgIHZhciBjb21tZW50ID0gJyc7XG4gICAgaWYgKHRoaXMuX2lucHV0LnBlZWsoMSkgPT09ICcqJykge1xuICAgICAgLy8gcGVlayBmb3IgY29tbWVudCAvKiAuLi4gKi9cbiAgICAgIGNvbW1lbnQgPSB0aGlzLl9fcGF0dGVybnMuYmxvY2tfY29tbWVudC5yZWFkKCk7XG4gICAgICB2YXIgZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXNfY29yZS5nZXRfZGlyZWN0aXZlcyhjb21tZW50KTtcbiAgICAgIGlmIChkaXJlY3RpdmVzICYmIGRpcmVjdGl2ZXMuaWdub3JlID09PSAnc3RhcnQnKSB7XG4gICAgICAgIGNvbW1lbnQgKz0gZGlyZWN0aXZlc19jb3JlLnJlYWRJZ25vcmVkKHRoaXMuX2lucHV0KTtcbiAgICAgIH1cbiAgICAgIGNvbW1lbnQgPSBjb21tZW50LnJlcGxhY2UoYWNvcm4uYWxsTGluZUJyZWFrcywgJ1xcbicpO1xuICAgICAgdG9rZW4gPSB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uQkxPQ0tfQ09NTUVOVCwgY29tbWVudCk7XG4gICAgICB0b2tlbi5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2lucHV0LnBlZWsoMSkgPT09ICcvJykge1xuICAgICAgLy8gcGVlayBmb3IgY29tbWVudCAvLyAuLi5cbiAgICAgIGNvbW1lbnQgPSB0aGlzLl9fcGF0dGVybnMuY29tbWVudC5yZWFkKCk7XG4gICAgICB0b2tlbiA9IHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5DT01NRU5ULCBjb21tZW50KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRva2VuO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZF9zdHJpbmcgPSBmdW5jdGlvbihjKSB7XG4gIGlmIChjID09PSAnYCcgfHwgYyA9PT0gXCInXCIgfHwgYyA9PT0gJ1wiJykge1xuICAgIHZhciByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgIHRoaXMuaGFzX2NoYXJfZXNjYXBlcyA9IGZhbHNlO1xuXG4gICAgaWYgKGMgPT09ICdgJykge1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSB0aGlzLl9yZWFkX3N0cmluZ19yZWN1cnNpdmUoJ2AnLCB0cnVlLCAnJHsnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSB0aGlzLl9yZWFkX3N0cmluZ19yZWN1cnNpdmUoYyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzX2NoYXJfZXNjYXBlcyAmJiB0aGlzLl9vcHRpb25zLnVuZXNjYXBlX3N0cmluZ3MpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSB1bmVzY2FwZV9zdHJpbmcocmVzdWx0aW5nX3N0cmluZyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gYykge1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgfVxuXG4gICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcucmVwbGFjZShhY29ybi5hbGxMaW5lQnJlYWtzLCAnXFxuJyk7XG5cbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlNUUklORywgcmVzdWx0aW5nX3N0cmluZyk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2FsbG93X3JlZ2V4cF9vcl94bWwgPSBmdW5jdGlvbihwcmV2aW91c190b2tlbikge1xuICAvLyByZWdleCBhbmQgeG1sIGNhbiBvbmx5IGFwcGVhciBpbiBzcGVjaWZpYyBsb2NhdGlvbnMgZHVyaW5nIHBhcnNpbmdcbiAgcmV0dXJuIChwcmV2aW91c190b2tlbi50eXBlID09PSBUT0tFTi5SRVNFUlZFRCAmJiBpbl9hcnJheShwcmV2aW91c190b2tlbi50ZXh0LCBbJ3JldHVybicsICdjYXNlJywgJ3Rocm93JywgJ2Vsc2UnLCAnZG8nLCAndHlwZW9mJywgJ3lpZWxkJ10pKSB8fFxuICAgIChwcmV2aW91c190b2tlbi50eXBlID09PSBUT0tFTi5FTkRfRVhQUiAmJiBwcmV2aW91c190b2tlbi50ZXh0ID09PSAnKScgJiZcbiAgICAgIHByZXZpb3VzX3Rva2VuLm9wZW5lZC5wcmV2aW91cy50eXBlID09PSBUT0tFTi5SRVNFUlZFRCAmJiBpbl9hcnJheShwcmV2aW91c190b2tlbi5vcGVuZWQucHJldmlvdXMudGV4dCwgWydpZicsICd3aGlsZScsICdmb3InXSkpIHx8XG4gICAgKGluX2FycmF5KHByZXZpb3VzX3Rva2VuLnR5cGUsIFtUT0tFTi5DT01NRU5ULCBUT0tFTi5TVEFSVF9FWFBSLCBUT0tFTi5TVEFSVF9CTE9DSywgVE9LRU4uU1RBUlQsXG4gICAgICBUT0tFTi5FTkRfQkxPQ0ssIFRPS0VOLk9QRVJBVE9SLCBUT0tFTi5FUVVBTFMsIFRPS0VOLkVPRiwgVE9LRU4uU0VNSUNPTE9OLCBUT0tFTi5DT01NQVxuICAgIF0pKTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfcmVnZXhwID0gZnVuY3Rpb24oYywgcHJldmlvdXNfdG9rZW4pIHtcblxuICBpZiAoYyA9PT0gJy8nICYmIHRoaXMuX2FsbG93X3JlZ2V4cF9vcl94bWwocHJldmlvdXNfdG9rZW4pKSB7XG4gICAgLy8gaGFuZGxlIHJlZ2V4cFxuICAgIC8vXG4gICAgdmFyIHJlc3VsdGluZ19zdHJpbmcgPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgdmFyIGVzYyA9IGZhbHNlO1xuXG4gICAgdmFyIGluX2NoYXJfY2xhc3MgPSBmYWxzZTtcbiAgICB3aGlsZSAodGhpcy5faW5wdXQuaGFzTmV4dCgpICYmXG4gICAgICAoKGVzYyB8fCBpbl9jaGFyX2NsYXNzIHx8IHRoaXMuX2lucHV0LnBlZWsoKSAhPT0gYykgJiZcbiAgICAgICAgIXRoaXMuX2lucHV0LnRlc3RDaGFyKGFjb3JuLm5ld2xpbmUpKSkge1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSB0aGlzLl9pbnB1dC5wZWVrKCk7XG4gICAgICBpZiAoIWVzYykge1xuICAgICAgICBlc2MgPSB0aGlzLl9pbnB1dC5wZWVrKCkgPT09ICdcXFxcJztcbiAgICAgICAgaWYgKHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gJ1snKSB7XG4gICAgICAgICAgaW5fY2hhcl9jbGFzcyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5faW5wdXQucGVlaygpID09PSAnXScpIHtcbiAgICAgICAgICBpbl9jaGFyX2NsYXNzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVzYyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5faW5wdXQubmV4dCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9pbnB1dC5wZWVrKCkgPT09IGMpIHtcbiAgICAgIHJlc3VsdGluZ19zdHJpbmcgKz0gdGhpcy5faW5wdXQubmV4dCgpO1xuXG4gICAgICAvLyByZWdleHBzIG1heSBoYXZlIG1vZGlmaWVycyAvcmVnZXhwL01PRCAsIHNvIGZldGNoIHRob3NlLCB0b29cbiAgICAgIC8vIE9ubHkgW2dpbV0gYXJlIHZhbGlkLCBidXQgaWYgdGhlIHVzZXIgcHV0cyBpbiBnYXJiYWdlLCBkbyB3aGF0IHdlIGNhbiB0byB0YWtlIGl0LlxuICAgICAgcmVzdWx0aW5nX3N0cmluZyArPSB0aGlzLl9pbnB1dC5yZWFkKGFjb3JuLmlkZW50aWZpZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlNUUklORywgcmVzdWx0aW5nX3N0cmluZyk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkX3htbCA9IGZ1bmN0aW9uKGMsIHByZXZpb3VzX3Rva2VuKSB7XG5cbiAgaWYgKHRoaXMuX29wdGlvbnMuZTR4ICYmIGMgPT09IFwiPFwiICYmIHRoaXMuX2FsbG93X3JlZ2V4cF9vcl94bWwocHJldmlvdXNfdG9rZW4pKSB7XG4gICAgdmFyIHhtbFN0ciA9ICcnO1xuICAgIHZhciBtYXRjaCA9IHRoaXMuX19wYXR0ZXJucy54bWwucmVhZF9tYXRjaCgpO1xuICAgIC8vIGhhbmRsZSBlNHggeG1sIGxpdGVyYWxzXG4gICAgLy9cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIC8vIFRyaW0gcm9vdCB0YWcgdG8gYXR0ZW1wdCB0b1xuICAgICAgdmFyIHJvb3RUYWcgPSBtYXRjaFsyXS5yZXBsYWNlKC9ee1xccysvLCAneycpLnJlcGxhY2UoL1xccyt9JC8sICd9Jyk7XG4gICAgICB2YXIgaXNDdXJseVJvb3QgPSByb290VGFnLmluZGV4T2YoJ3snKSA9PT0gMDtcbiAgICAgIHZhciBkZXB0aCA9IDA7XG4gICAgICB3aGlsZSAobWF0Y2gpIHtcbiAgICAgICAgdmFyIGlzRW5kVGFnID0gISFtYXRjaFsxXTtcbiAgICAgICAgdmFyIHRhZ05hbWUgPSBtYXRjaFsyXTtcbiAgICAgICAgdmFyIGlzU2luZ2xldG9uVGFnID0gKCEhbWF0Y2hbbWF0Y2gubGVuZ3RoIC0gMV0pIHx8ICh0YWdOYW1lLnNsaWNlKDAsIDgpID09PSBcIiFbQ0RBVEFbXCIpO1xuICAgICAgICBpZiAoIWlzU2luZ2xldG9uVGFnICYmXG4gICAgICAgICAgKHRhZ05hbWUgPT09IHJvb3RUYWcgfHwgKGlzQ3VybHlSb290ICYmIHRhZ05hbWUucmVwbGFjZSgvXntcXHMrLywgJ3snKS5yZXBsYWNlKC9cXHMrfSQvLCAnfScpKSkpIHtcbiAgICAgICAgICBpZiAoaXNFbmRUYWcpIHtcbiAgICAgICAgICAgIC0tZGVwdGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICsrZGVwdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHhtbFN0ciArPSBtYXRjaFswXTtcbiAgICAgICAgaWYgKGRlcHRoIDw9IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBtYXRjaCA9IHRoaXMuX19wYXR0ZXJucy54bWwucmVhZF9tYXRjaCgpO1xuICAgICAgfVxuICAgICAgLy8gaWYgd2UgZGlkbid0IGNsb3NlIGNvcnJlY3RseSwga2VlcCB1bmZvcm1hdHRlZC5cbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgeG1sU3RyICs9IHRoaXMuX2lucHV0Lm1hdGNoKC9bXFxzXFxTXSovZylbMF07XG4gICAgICB9XG4gICAgICB4bWxTdHIgPSB4bWxTdHIucmVwbGFjZShhY29ybi5hbGxMaW5lQnJlYWtzLCAnXFxuJyk7XG4gICAgICByZXR1cm4gdGhpcy5fY3JlYXRlX3Rva2VuKFRPS0VOLlNUUklORywgeG1sU3RyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbmZ1bmN0aW9uIHVuZXNjYXBlX3N0cmluZyhzKSB7XG4gIC8vIFlvdSB0aGluayB0aGF0IGEgcmVnZXggd291bGQgd29yayBmb3IgdGhpc1xuICAvLyByZXR1cm4gcy5yZXBsYWNlKC9cXFxceChbMC05YS1mXXsyfSkvZ2ksIGZ1bmN0aW9uKG1hdGNoLCB2YWwpIHtcbiAgLy8gICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludCh2YWwsIDE2KSk7XG4gIC8vICAgICB9KVxuICAvLyBIb3dldmVyLCBkZWFsaW5nIHdpdGggJ1xceGZmJywgJ1xcXFx4ZmYnLCAnXFxcXFxceGZmJyBtYWtlcyB0aGlzIG1vcmUgZnVuLlxuICB2YXIgb3V0ID0gJycsXG4gICAgZXNjYXBlZCA9IDA7XG5cbiAgdmFyIGlucHV0X3NjYW4gPSBuZXcgSW5wdXRTY2FubmVyKHMpO1xuICB2YXIgbWF0Y2hlZCA9IG51bGw7XG5cbiAgd2hpbGUgKGlucHV0X3NjYW4uaGFzTmV4dCgpKSB7XG4gICAgLy8gS2VlcCBhbnkgd2hpdGVzcGFjZSwgbm9uLXNsYXNoIGNoYXJhY3RlcnNcbiAgICAvLyBhbHNvIGtlZXAgc2xhc2ggcGFpcnMuXG4gICAgbWF0Y2hlZCA9IGlucHV0X3NjYW4ubWF0Y2goLyhbXFxzXXxbXlxcXFxdfFxcXFxcXFxcKSsvZyk7XG5cbiAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgb3V0ICs9IG1hdGNoZWRbMF07XG4gICAgfVxuXG4gICAgaWYgKGlucHV0X3NjYW4ucGVlaygpID09PSAnXFxcXCcpIHtcbiAgICAgIGlucHV0X3NjYW4ubmV4dCgpO1xuICAgICAgaWYgKGlucHV0X3NjYW4ucGVlaygpID09PSAneCcpIHtcbiAgICAgICAgbWF0Y2hlZCA9IGlucHV0X3NjYW4ubWF0Y2goL3goWzAtOUEtRmEtZl17Mn0pL2cpO1xuICAgICAgfSBlbHNlIGlmIChpbnB1dF9zY2FuLnBlZWsoKSA9PT0gJ3UnKSB7XG4gICAgICAgIG1hdGNoZWQgPSBpbnB1dF9zY2FuLm1hdGNoKC91KFswLTlBLUZhLWZdezR9KS9nKTtcbiAgICAgICAgaWYgKCFtYXRjaGVkKSB7XG4gICAgICAgICAgbWF0Y2hlZCA9IGlucHV0X3NjYW4ubWF0Y2goL3VcXHsoWzAtOUEtRmEtZl0rKVxcfS9nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICdcXFxcJztcbiAgICAgICAgaWYgKGlucHV0X3NjYW4uaGFzTmV4dCgpKSB7XG4gICAgICAgICAgb3V0ICs9IGlucHV0X3NjYW4ubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGVyZSdzIHNvbWUgZXJyb3IgZGVjb2RpbmcsIHJldHVybiB0aGUgb3JpZ2luYWwgc3RyaW5nXG4gICAgICBpZiAoIW1hdGNoZWQpIHtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICB9XG5cbiAgICAgIGVzY2FwZWQgPSBwYXJzZUludChtYXRjaGVkWzFdLCAxNik7XG5cbiAgICAgIGlmIChlc2NhcGVkID4gMHg3ZSAmJiBlc2NhcGVkIDw9IDB4ZmYgJiYgbWF0Y2hlZFswXS5pbmRleE9mKCd4JykgPT09IDApIHtcbiAgICAgICAgLy8gd2UgYmFpbCBvdXQgb24gXFx4N2YuLlxceGZmLFxuICAgICAgICAvLyBsZWF2aW5nIHdob2xlIHN0cmluZyBlc2NhcGVkLFxuICAgICAgICAvLyBhcyBpdCdzIHByb2JhYmx5IGNvbXBsZXRlbHkgYmluYXJ5XG4gICAgICAgIHJldHVybiBzO1xuICAgICAgfSBlbHNlIGlmIChlc2NhcGVkID49IDB4MDAgJiYgZXNjYXBlZCA8IDB4MjApIHtcbiAgICAgICAgLy8gbGVhdmUgMHgwMC4uLjB4MWYgZXNjYXBlZFxuICAgICAgICBvdXQgKz0gJ1xcXFwnICsgbWF0Y2hlZFswXTtcbiAgICAgIH0gZWxzZSBpZiAoZXNjYXBlZCA+IDB4MTBGRkZGKSB7XG4gICAgICAgIC8vIElmIHRoZSBlc2NhcGUgc2VxdWVuY2UgaXMgb3V0IG9mIGJvdW5kcywga2VlcCB0aGUgb3JpZ2luYWwgc2VxdWVuY2UgYW5kIGNvbnRpbnVlIGNvbnZlcnNpb25cbiAgICAgICAgb3V0ICs9ICdcXFxcJyArIG1hdGNoZWRbMF07XG4gICAgICB9IGVsc2UgaWYgKGVzY2FwZWQgPT09IDB4MjIgfHwgZXNjYXBlZCA9PT0gMHgyNyB8fCBlc2NhcGVkID09PSAweDVjKSB7XG4gICAgICAgIC8vIHNpbmdsZS1xdW90ZSwgYXBvc3Ryb3BoZSwgYmFja3NsYXNoIC0gZXNjYXBlIHRoZXNlXG4gICAgICAgIG91dCArPSAnXFxcXCcgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGVzY2FwZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZXNjYXBlZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLy8gaGFuZGxlIHN0cmluZ1xuLy9cblRva2VuaXplci5wcm90b3R5cGUuX3JlYWRfc3RyaW5nX3JlY3Vyc2l2ZSA9IGZ1bmN0aW9uKGRlbGltaXRlciwgYWxsb3dfdW5lc2NhcGVkX25ld2xpbmVzLCBzdGFydF9zdWIpIHtcbiAgdmFyIGN1cnJlbnRfY2hhcjtcbiAgdmFyIHBhdHRlcm47XG4gIGlmIChkZWxpbWl0ZXIgPT09ICdcXCcnKSB7XG4gICAgcGF0dGVybiA9IHRoaXMuX19wYXR0ZXJucy5zaW5nbGVfcXVvdGU7XG4gIH0gZWxzZSBpZiAoZGVsaW1pdGVyID09PSAnXCInKSB7XG4gICAgcGF0dGVybiA9IHRoaXMuX19wYXR0ZXJucy5kb3VibGVfcXVvdGU7XG4gIH0gZWxzZSBpZiAoZGVsaW1pdGVyID09PSAnYCcpIHtcbiAgICBwYXR0ZXJuID0gdGhpcy5fX3BhdHRlcm5zLnRlbXBsYXRlX3RleHQ7XG4gIH0gZWxzZSBpZiAoZGVsaW1pdGVyID09PSAnfScpIHtcbiAgICBwYXR0ZXJuID0gdGhpcy5fX3BhdHRlcm5zLnRlbXBsYXRlX2V4cHJlc3Npb247XG4gIH1cblxuICB2YXIgcmVzdWx0aW5nX3N0cmluZyA9IHBhdHRlcm4ucmVhZCgpO1xuICB2YXIgbmV4dCA9ICcnO1xuICB3aGlsZSAodGhpcy5faW5wdXQuaGFzTmV4dCgpKSB7XG4gICAgbmV4dCA9IHRoaXMuX2lucHV0Lm5leHQoKTtcbiAgICBpZiAobmV4dCA9PT0gZGVsaW1pdGVyIHx8XG4gICAgICAoIWFsbG93X3VuZXNjYXBlZF9uZXdsaW5lcyAmJiBhY29ybi5uZXdsaW5lLnRlc3QobmV4dCkpKSB7XG4gICAgICB0aGlzLl9pbnB1dC5iYWNrKCk7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKG5leHQgPT09ICdcXFxcJyAmJiB0aGlzLl9pbnB1dC5oYXNOZXh0KCkpIHtcbiAgICAgIGN1cnJlbnRfY2hhciA9IHRoaXMuX2lucHV0LnBlZWsoKTtcblxuICAgICAgaWYgKGN1cnJlbnRfY2hhciA9PT0gJ3gnIHx8IGN1cnJlbnRfY2hhciA9PT0gJ3UnKSB7XG4gICAgICAgIHRoaXMuaGFzX2NoYXJfZXNjYXBlcyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnRfY2hhciA9PT0gJ1xccicgJiYgdGhpcy5faW5wdXQucGVlaygxKSA9PT0gJ1xcbicpIHtcbiAgICAgICAgdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgfVxuICAgICAgbmV4dCArPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgfSBlbHNlIGlmIChzdGFydF9zdWIpIHtcbiAgICAgIGlmIChzdGFydF9zdWIgPT09ICckeycgJiYgbmV4dCA9PT0gJyQnICYmIHRoaXMuX2lucHV0LnBlZWsoKSA9PT0gJ3snKSB7XG4gICAgICAgIG5leHQgKz0gdGhpcy5faW5wdXQubmV4dCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnRfc3ViID09PSBuZXh0KSB7XG4gICAgICAgIGlmIChkZWxpbWl0ZXIgPT09ICdgJykge1xuICAgICAgICAgIG5leHQgKz0gdGhpcy5fcmVhZF9zdHJpbmdfcmVjdXJzaXZlKCd9JywgYWxsb3dfdW5lc2NhcGVkX25ld2xpbmVzLCAnYCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQgKz0gdGhpcy5fcmVhZF9zdHJpbmdfcmVjdXJzaXZlKCdgJywgYWxsb3dfdW5lc2NhcGVkX25ld2xpbmVzLCAnJHsnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW5wdXQuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgbmV4dCArPSB0aGlzLl9pbnB1dC5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbmV4dCArPSBwYXR0ZXJuLnJlYWQoKTtcbiAgICByZXN1bHRpbmdfc3RyaW5nICs9IG5leHQ7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0aW5nX3N0cmluZztcbn07XG5cbm1vZHVsZS5leHBvcnRzLlRva2VuaXplciA9IFRva2VuaXplcjtcbm1vZHVsZS5leHBvcnRzLlRPS0VOID0gVE9LRU47XG5tb2R1bGUuZXhwb3J0cy5wb3NpdGlvbmFibGVfb3BlcmF0b3JzID0gcG9zaXRpb25hYmxlX29wZXJhdG9ycy5zbGljZSgpO1xubW9kdWxlLmV4cG9ydHMubGluZV9zdGFydGVycyA9IGxpbmVfc3RhcnRlcnMuc2xpY2UoKTtcblxuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG52YXIgcmVnZXhwX2hhc19zdGlja3kgPSBSZWdFeHAucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdzdGlja3knKTtcblxuZnVuY3Rpb24gSW5wdXRTY2FubmVyKGlucHV0X3N0cmluZykge1xuICB0aGlzLl9faW5wdXQgPSBpbnB1dF9zdHJpbmcgfHwgJyc7XG4gIHRoaXMuX19pbnB1dF9sZW5ndGggPSB0aGlzLl9faW5wdXQubGVuZ3RoO1xuICB0aGlzLl9fcG9zaXRpb24gPSAwO1xufVxuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnJlc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fX3Bvc2l0aW9uID0gMDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUuYmFjayA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fX3Bvc2l0aW9uID4gMCkge1xuICAgIHRoaXMuX19wb3NpdGlvbiAtPSAxO1xuICB9XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLmhhc05leHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX19wb3NpdGlvbiA8IHRoaXMuX19pbnB1dF9sZW5ndGg7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHZhbCA9IG51bGw7XG4gIGlmICh0aGlzLmhhc05leHQoKSkge1xuICAgIHZhbCA9IHRoaXMuX19pbnB1dC5jaGFyQXQodGhpcy5fX3Bvc2l0aW9uKTtcbiAgICB0aGlzLl9fcG9zaXRpb24gKz0gMTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgdmFyIHZhbCA9IG51bGw7XG4gIGluZGV4ID0gaW5kZXggfHwgMDtcbiAgaW5kZXggKz0gdGhpcy5fX3Bvc2l0aW9uO1xuICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuX19pbnB1dF9sZW5ndGgpIHtcbiAgICB2YWwgPSB0aGlzLl9faW5wdXQuY2hhckF0KGluZGV4KTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuLy8gVGhpcyBpcyBhIEphdmFTY3JpcHQgb25seSBoZWxwZXIgZnVuY3Rpb24gKG5vdCBpbiBweXRob24pXG4vLyBKYXZhc2NyaXB0IGRvZXNuJ3QgaGF2ZSBhIG1hdGNoIG1ldGhvZFxuLy8gYW5kIG5vdCBhbGwgaW1wbGVtZW50YXRpb24gc3VwcG9ydCBcInN0aWNreVwiIGZsYWcuXG4vLyBJZiB0aGV5IGRvIG5vdCBzdXBwb3J0IHN0aWNreSB0aGVuIGJvdGggdGhpcy5tYXRjaCgpIGFuZCB0aGlzLnRlc3QoKSBtZXRob2Rcbi8vIG11c3QgZ2V0IHRoZSBtYXRjaCBhbmQgY2hlY2sgdGhlIGluZGV4IG9mIHRoZSBtYXRjaC5cbi8vIElmIHN0aWNreSBpcyBzdXBwb3J0ZWQgYW5kIHNldCwgdGhpcyBtZXRob2Qgd2lsbCB1c2UgaXQuXG4vLyBPdGhlcndpc2UgaXQgd2lsbCBjaGVjayB0aGF0IGdsb2JhbCBpcyBzZXQsIGFuZCBmYWxsIGJhY2sgdG8gdGhlIHNsb3dlciBtZXRob2QuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLl9fbWF0Y2ggPSBmdW5jdGlvbihwYXR0ZXJuLCBpbmRleCkge1xuICBwYXR0ZXJuLmxhc3RJbmRleCA9IGluZGV4O1xuICB2YXIgcGF0dGVybl9tYXRjaCA9IHBhdHRlcm4uZXhlYyh0aGlzLl9faW5wdXQpO1xuXG4gIGlmIChwYXR0ZXJuX21hdGNoICYmICEocmVnZXhwX2hhc19zdGlja3kgJiYgcGF0dGVybi5zdGlja3kpKSB7XG4gICAgaWYgKHBhdHRlcm5fbWF0Y2guaW5kZXggIT09IGluZGV4KSB7XG4gICAgICBwYXR0ZXJuX21hdGNoID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGF0dGVybl9tYXRjaDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uKHBhdHRlcm4sIGluZGV4KSB7XG4gIGluZGV4ID0gaW5kZXggfHwgMDtcbiAgaW5kZXggKz0gdGhpcy5fX3Bvc2l0aW9uO1xuXG4gIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fX2lucHV0X2xlbmd0aCkge1xuICAgIHJldHVybiAhIXRoaXMuX19tYXRjaChwYXR0ZXJuLCBpbmRleCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLnRlc3RDaGFyID0gZnVuY3Rpb24ocGF0dGVybiwgaW5kZXgpIHtcbiAgLy8gdGVzdCBvbmUgY2hhcmFjdGVyIHJlZ2V4IG1hdGNoXG4gIHZhciB2YWwgPSB0aGlzLnBlZWsoaW5kZXgpO1xuICBwYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgcGF0dGVybi50ZXN0KHZhbCk7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgcGF0dGVybl9tYXRjaCA9IHRoaXMuX19tYXRjaChwYXR0ZXJuLCB0aGlzLl9fcG9zaXRpb24pO1xuICBpZiAocGF0dGVybl9tYXRjaCkge1xuICAgIHRoaXMuX19wb3NpdGlvbiArPSBwYXR0ZXJuX21hdGNoWzBdLmxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICBwYXR0ZXJuX21hdGNoID0gbnVsbDtcbiAgfVxuICByZXR1cm4gcGF0dGVybl9tYXRjaDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKHN0YXJ0aW5nX3BhdHRlcm4sIHVudGlsX3BhdHRlcm4sIHVudGlsX2FmdGVyKSB7XG4gIHZhciB2YWwgPSAnJztcbiAgdmFyIG1hdGNoO1xuICBpZiAoc3RhcnRpbmdfcGF0dGVybikge1xuICAgIG1hdGNoID0gdGhpcy5tYXRjaChzdGFydGluZ19wYXR0ZXJuKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhbCArPSBtYXRjaFswXTtcbiAgICB9XG4gIH1cbiAgaWYgKHVudGlsX3BhdHRlcm4gJiYgKG1hdGNoIHx8ICFzdGFydGluZ19wYXR0ZXJuKSkge1xuICAgIHZhbCArPSB0aGlzLnJlYWRVbnRpbCh1bnRpbF9wYXR0ZXJuLCB1bnRpbF9hZnRlcik7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUucmVhZFVudGlsID0gZnVuY3Rpb24ocGF0dGVybiwgdW50aWxfYWZ0ZXIpIHtcbiAgdmFyIHZhbCA9ICcnO1xuICB2YXIgbWF0Y2hfaW5kZXggPSB0aGlzLl9fcG9zaXRpb247XG4gIHBhdHRlcm4ubGFzdEluZGV4ID0gdGhpcy5fX3Bvc2l0aW9uO1xuICB2YXIgcGF0dGVybl9tYXRjaCA9IHBhdHRlcm4uZXhlYyh0aGlzLl9faW5wdXQpO1xuICBpZiAocGF0dGVybl9tYXRjaCkge1xuICAgIG1hdGNoX2luZGV4ID0gcGF0dGVybl9tYXRjaC5pbmRleDtcbiAgICBpZiAodW50aWxfYWZ0ZXIpIHtcbiAgICAgIG1hdGNoX2luZGV4ICs9IHBhdHRlcm5fbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXRjaF9pbmRleCA9IHRoaXMuX19pbnB1dF9sZW5ndGg7XG4gIH1cblxuICB2YWwgPSB0aGlzLl9faW5wdXQuc3Vic3RyaW5nKHRoaXMuX19wb3NpdGlvbiwgbWF0Y2hfaW5kZXgpO1xuICB0aGlzLl9fcG9zaXRpb24gPSBtYXRjaF9pbmRleDtcbiAgcmV0dXJuIHZhbDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUucmVhZFVudGlsQWZ0ZXIgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHJldHVybiB0aGlzLnJlYWRVbnRpbChwYXR0ZXJuLCB0cnVlKTtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUuZ2V0X3JlZ2V4cCA9IGZ1bmN0aW9uKHBhdHRlcm4sIG1hdGNoX2Zyb20pIHtcbiAgdmFyIHJlc3VsdCA9IG51bGw7XG4gIHZhciBmbGFncyA9ICdnJztcbiAgaWYgKG1hdGNoX2Zyb20gJiYgcmVnZXhwX2hhc19zdGlja3kpIHtcbiAgICBmbGFncyA9ICd5JztcbiAgfVxuICAvLyBzdHJpbmdzIGFyZSBjb252ZXJ0ZWQgdG8gcmVnZXhwXG4gIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gXCJzdHJpbmdcIiAmJiBwYXR0ZXJuICE9PSAnJykge1xuICAgIC8vIHJlc3VsdCA9IG5ldyBSZWdFeHAocGF0dGVybi5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKSwgZmxhZ3MpO1xuICAgIHJlc3VsdCA9IG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xuICB9IGVsc2UgaWYgKHBhdHRlcm4pIHtcbiAgICByZXN1bHQgPSBuZXcgUmVnRXhwKHBhdHRlcm4uc291cmNlLCBmbGFncyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbklucHV0U2Nhbm5lci5wcm90b3R5cGUuZ2V0X2xpdGVyYWxfcmVnZXhwID0gZnVuY3Rpb24obGl0ZXJhbF9zdHJpbmcpIHtcbiAgcmV0dXJuIFJlZ0V4cChsaXRlcmFsX3N0cmluZy5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKSk7XG59O1xuXG4vKiBjc3MgYmVhdXRpZmllciBsZWdhY3kgaGVscGVycyAqL1xuSW5wdXRTY2FubmVyLnByb3RvdHlwZS5wZWVrVW50aWxBZnRlciA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5fX3Bvc2l0aW9uO1xuICB2YXIgdmFsID0gdGhpcy5yZWFkVW50aWxBZnRlcihwYXR0ZXJuKTtcbiAgdGhpcy5fX3Bvc2l0aW9uID0gc3RhcnQ7XG4gIHJldHVybiB2YWw7XG59O1xuXG5JbnB1dFNjYW5uZXIucHJvdG90eXBlLmxvb2tCYWNrID0gZnVuY3Rpb24odGVzdFZhbCkge1xuICB2YXIgc3RhcnQgPSB0aGlzLl9fcG9zaXRpb24gLSAxO1xuICByZXR1cm4gc3RhcnQgPj0gdGVzdFZhbC5sZW5ndGggJiYgdGhpcy5fX2lucHV0LnN1YnN0cmluZyhzdGFydCAtIHRlc3RWYWwubGVuZ3RoLCBzdGFydClcbiAgICAudG9Mb3dlckNhc2UoKSA9PT0gdGVzdFZhbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzLklucHV0U2Nhbm5lciA9IElucHV0U2Nhbm5lcjtcblxuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbnZhciBJbnB1dFNjYW5uZXIgPSAoX193ZWJwYWNrX3JlcXVpcmVfXyg4KS5JbnB1dFNjYW5uZXIpO1xudmFyIFRva2VuID0gKF9fd2VicGFja19yZXF1aXJlX18oMykuVG9rZW4pO1xudmFyIFRva2VuU3RyZWFtID0gKF9fd2VicGFja19yZXF1aXJlX18oMTApLlRva2VuU3RyZWFtKTtcbnZhciBXaGl0ZXNwYWNlUGF0dGVybiA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDExKS5XaGl0ZXNwYWNlUGF0dGVybik7XG5cbnZhciBUT0tFTiA9IHtcbiAgU1RBUlQ6ICdUS19TVEFSVCcsXG4gIFJBVzogJ1RLX1JBVycsXG4gIEVPRjogJ1RLX0VPRidcbn07XG5cbnZhciBUb2tlbml6ZXIgPSBmdW5jdGlvbihpbnB1dF9zdHJpbmcsIG9wdGlvbnMpIHtcbiAgdGhpcy5faW5wdXQgPSBuZXcgSW5wdXRTY2FubmVyKGlucHV0X3N0cmluZyk7XG4gIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLl9fdG9rZW5zID0gbnVsbDtcblxuICB0aGlzLl9wYXR0ZXJucyA9IHt9O1xuICB0aGlzLl9wYXR0ZXJucy53aGl0ZXNwYWNlID0gbmV3IFdoaXRlc3BhY2VQYXR0ZXJuKHRoaXMuX2lucHV0KTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5faW5wdXQucmVzdGFydCgpO1xuICB0aGlzLl9fdG9rZW5zID0gbmV3IFRva2VuU3RyZWFtKCk7XG5cbiAgdGhpcy5fcmVzZXQoKTtcblxuICB2YXIgY3VycmVudDtcbiAgdmFyIHByZXZpb3VzID0gbmV3IFRva2VuKFRPS0VOLlNUQVJULCAnJyk7XG4gIHZhciBvcGVuX3Rva2VuID0gbnVsbDtcbiAgdmFyIG9wZW5fc3RhY2sgPSBbXTtcbiAgdmFyIGNvbW1lbnRzID0gbmV3IFRva2VuU3RyZWFtKCk7XG5cbiAgd2hpbGUgKHByZXZpb3VzLnR5cGUgIT09IFRPS0VOLkVPRikge1xuICAgIGN1cnJlbnQgPSB0aGlzLl9nZXRfbmV4dF90b2tlbihwcmV2aW91cywgb3Blbl90b2tlbik7XG4gICAgd2hpbGUgKHRoaXMuX2lzX2NvbW1lbnQoY3VycmVudCkpIHtcbiAgICAgIGNvbW1lbnRzLmFkZChjdXJyZW50KTtcbiAgICAgIGN1cnJlbnQgPSB0aGlzLl9nZXRfbmV4dF90b2tlbihwcmV2aW91cywgb3Blbl90b2tlbik7XG4gICAgfVxuXG4gICAgaWYgKCFjb21tZW50cy5pc0VtcHR5KCkpIHtcbiAgICAgIGN1cnJlbnQuY29tbWVudHNfYmVmb3JlID0gY29tbWVudHM7XG4gICAgICBjb21tZW50cyA9IG5ldyBUb2tlblN0cmVhbSgpO1xuICAgIH1cblxuICAgIGN1cnJlbnQucGFyZW50ID0gb3Blbl90b2tlbjtcblxuICAgIGlmICh0aGlzLl9pc19vcGVuaW5nKGN1cnJlbnQpKSB7XG4gICAgICBvcGVuX3N0YWNrLnB1c2gob3Blbl90b2tlbik7XG4gICAgICBvcGVuX3Rva2VuID0gY3VycmVudDtcbiAgICB9IGVsc2UgaWYgKG9wZW5fdG9rZW4gJiYgdGhpcy5faXNfY2xvc2luZyhjdXJyZW50LCBvcGVuX3Rva2VuKSkge1xuICAgICAgY3VycmVudC5vcGVuZWQgPSBvcGVuX3Rva2VuO1xuICAgICAgb3Blbl90b2tlbi5jbG9zZWQgPSBjdXJyZW50O1xuICAgICAgb3Blbl90b2tlbiA9IG9wZW5fc3RhY2sucG9wKCk7XG4gICAgICBjdXJyZW50LnBhcmVudCA9IG9wZW5fdG9rZW47XG4gICAgfVxuXG4gICAgY3VycmVudC5wcmV2aW91cyA9IHByZXZpb3VzO1xuICAgIHByZXZpb3VzLm5leHQgPSBjdXJyZW50O1xuXG4gICAgdGhpcy5fX3Rva2Vucy5hZGQoY3VycmVudCk7XG4gICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX190b2tlbnM7XG59O1xuXG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX2ZpcnN0X3Rva2VuID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9fdG9rZW5zLmlzRW1wdHkoKTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24oKSB7fTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5fZ2V0X25leHRfdG9rZW4gPSBmdW5jdGlvbihwcmV2aW91c190b2tlbiwgb3Blbl90b2tlbikgeyAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHRoaXMuX3JlYWRXaGl0ZXNwYWNlKCk7XG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5faW5wdXQucmVhZCgvLisvZyk7XG4gIGlmIChyZXN1bHRpbmdfc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZV90b2tlbihUT0tFTi5SQVcsIHJlc3VsdGluZ19zdHJpbmcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLl9jcmVhdGVfdG9rZW4oVE9LRU4uRU9GLCAnJyk7XG4gIH1cbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2lzX2NvbW1lbnQgPSBmdW5jdGlvbihjdXJyZW50X3Rva2VuKSB7IC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZS5faXNfb3BlbmluZyA9IGZ1bmN0aW9uKGN1cnJlbnRfdG9rZW4pIHsgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9pc19jbG9zaW5nID0gZnVuY3Rpb24oY3VycmVudF90b2tlbiwgb3Blbl90b2tlbikgeyAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHJldHVybiBmYWxzZTtcbn07XG5cblRva2VuaXplci5wcm90b3R5cGUuX2NyZWF0ZV90b2tlbiA9IGZ1bmN0aW9uKHR5cGUsIHRleHQpIHtcbiAgdmFyIHRva2VuID0gbmV3IFRva2VuKHR5cGUsIHRleHQsXG4gICAgdGhpcy5fcGF0dGVybnMud2hpdGVzcGFjZS5uZXdsaW5lX2NvdW50LFxuICAgIHRoaXMuX3BhdHRlcm5zLndoaXRlc3BhY2Uud2hpdGVzcGFjZV9iZWZvcmVfdG9rZW4pO1xuICByZXR1cm4gdG9rZW47XG59O1xuXG5Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkV2hpdGVzcGFjZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcGF0dGVybnMud2hpdGVzcGFjZS5yZWFkKCk7XG59O1xuXG5cblxubW9kdWxlLmV4cG9ydHMuVG9rZW5pemVyID0gVG9rZW5pemVyO1xubW9kdWxlLmV4cG9ydHMuVE9LRU4gPSBUT0tFTjtcblxuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxuZnVuY3Rpb24gVG9rZW5TdHJlYW0ocGFyZW50X3Rva2VuKSB7XG4gIC8vIHByaXZhdGVcbiAgdGhpcy5fX3Rva2VucyA9IFtdO1xuICB0aGlzLl9fdG9rZW5zX2xlbmd0aCA9IHRoaXMuX190b2tlbnMubGVuZ3RoO1xuICB0aGlzLl9fcG9zaXRpb24gPSAwO1xuICB0aGlzLl9fcGFyZW50X3Rva2VuID0gcGFyZW50X3Rva2VuO1xufVxuXG5Ub2tlblN0cmVhbS5wcm90b3R5cGUucmVzdGFydCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9fcG9zaXRpb24gPSAwO1xufTtcblxuVG9rZW5TdHJlYW0ucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX190b2tlbnNfbGVuZ3RoID09PSAwO1xufTtcblxuVG9rZW5TdHJlYW0ucHJvdG90eXBlLmhhc05leHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX19wb3NpdGlvbiA8IHRoaXMuX190b2tlbnNfbGVuZ3RoO1xufTtcblxuVG9rZW5TdHJlYW0ucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHZhbCA9IG51bGw7XG4gIGlmICh0aGlzLmhhc05leHQoKSkge1xuICAgIHZhbCA9IHRoaXMuX190b2tlbnNbdGhpcy5fX3Bvc2l0aW9uXTtcbiAgICB0aGlzLl9fcG9zaXRpb24gKz0gMTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuVG9rZW5TdHJlYW0ucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbihpbmRleCkge1xuICB2YXIgdmFsID0gbnVsbDtcbiAgaW5kZXggPSBpbmRleCB8fCAwO1xuICBpbmRleCArPSB0aGlzLl9fcG9zaXRpb247XG4gIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fX3Rva2Vuc19sZW5ndGgpIHtcbiAgICB2YWwgPSB0aGlzLl9fdG9rZW5zW2luZGV4XTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuVG9rZW5TdHJlYW0ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHRva2VuKSB7XG4gIGlmICh0aGlzLl9fcGFyZW50X3Rva2VuKSB7XG4gICAgdG9rZW4ucGFyZW50ID0gdGhpcy5fX3BhcmVudF90b2tlbjtcbiAgfVxuICB0aGlzLl9fdG9rZW5zLnB1c2godG9rZW4pO1xuICB0aGlzLl9fdG9rZW5zX2xlbmd0aCArPSAxO1xufTtcblxubW9kdWxlLmV4cG9ydHMuVG9rZW5TdHJlYW0gPSBUb2tlblN0cmVhbTtcblxuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLypqc2hpbnQgbm9kZTp0cnVlICovXG4vKlxuXG4gIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4gIENvcHlyaWdodCAoYykgMjAwNy0yMDE4IEVpbmFyIExpZWxtYW5pcywgTGlhbSBOZXdtYW4sIGFuZCBjb250cmlidXRvcnMuXG5cbiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICBTT0ZUV0FSRS5cbiovXG5cblxuXG52YXIgUGF0dGVybiA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKS5QYXR0ZXJuKTtcblxuZnVuY3Rpb24gV2hpdGVzcGFjZVBhdHRlcm4oaW5wdXRfc2Nhbm5lciwgcGFyZW50KSB7XG4gIFBhdHRlcm4uY2FsbCh0aGlzLCBpbnB1dF9zY2FubmVyLCBwYXJlbnQpO1xuICBpZiAocGFyZW50KSB7XG4gICAgdGhpcy5fbGluZV9yZWdleHAgPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhcmVudC5fbGluZV9yZWdleHApO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX19zZXRfd2hpdGVzcGFjZV9wYXR0ZXJucygnJywgJycpO1xuICB9XG5cbiAgdGhpcy5uZXdsaW5lX2NvdW50ID0gMDtcbiAgdGhpcy53aGl0ZXNwYWNlX2JlZm9yZV90b2tlbiA9ICcnO1xufVxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlID0gbmV3IFBhdHRlcm4oKTtcblxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlLl9fc2V0X3doaXRlc3BhY2VfcGF0dGVybnMgPSBmdW5jdGlvbih3aGl0ZXNwYWNlX2NoYXJzLCBuZXdsaW5lX2NoYXJzKSB7XG4gIHdoaXRlc3BhY2VfY2hhcnMgKz0gJ1xcXFx0ICc7XG4gIG5ld2xpbmVfY2hhcnMgKz0gJ1xcXFxuXFxcXHInO1xuXG4gIHRoaXMuX21hdGNoX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKFxuICAgICdbJyArIHdoaXRlc3BhY2VfY2hhcnMgKyBuZXdsaW5lX2NoYXJzICsgJ10rJywgdHJ1ZSk7XG4gIHRoaXMuX25ld2xpbmVfcmVnZXhwID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChcbiAgICAnXFxcXHJcXFxcbnxbJyArIG5ld2xpbmVfY2hhcnMgKyAnXScpO1xufTtcblxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5uZXdsaW5lX2NvdW50ID0gMDtcbiAgdGhpcy53aGl0ZXNwYWNlX2JlZm9yZV90b2tlbiA9ICcnO1xuXG4gIHZhciByZXN1bHRpbmdfc3RyaW5nID0gdGhpcy5faW5wdXQucmVhZCh0aGlzLl9tYXRjaF9wYXR0ZXJuKTtcbiAgaWYgKHJlc3VsdGluZ19zdHJpbmcgPT09ICcgJykge1xuICAgIHRoaXMud2hpdGVzcGFjZV9iZWZvcmVfdG9rZW4gPSAnICc7XG4gIH0gZWxzZSBpZiAocmVzdWx0aW5nX3N0cmluZykge1xuICAgIHZhciBtYXRjaGVzID0gdGhpcy5fX3NwbGl0KHRoaXMuX25ld2xpbmVfcmVnZXhwLCByZXN1bHRpbmdfc3RyaW5nKTtcbiAgICB0aGlzLm5ld2xpbmVfY291bnQgPSBtYXRjaGVzLmxlbmd0aCAtIDE7XG4gICAgdGhpcy53aGl0ZXNwYWNlX2JlZm9yZV90b2tlbiA9IG1hdGNoZXNbdGhpcy5uZXdsaW5lX2NvdW50XTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHRpbmdfc3RyaW5nO1xufTtcblxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlLm1hdGNoaW5nID0gZnVuY3Rpb24od2hpdGVzcGFjZV9jaGFycywgbmV3bGluZV9jaGFycykge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fY3JlYXRlKCk7XG4gIHJlc3VsdC5fX3NldF93aGl0ZXNwYWNlX3BhdHRlcm5zKHdoaXRlc3BhY2VfY2hhcnMsIG5ld2xpbmVfY2hhcnMpO1xuICByZXN1bHQuX3VwZGF0ZSgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuV2hpdGVzcGFjZVBhdHRlcm4ucHJvdG90eXBlLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBXaGl0ZXNwYWNlUGF0dGVybih0aGlzLl9pbnB1dCwgdGhpcyk7XG59O1xuXG5XaGl0ZXNwYWNlUGF0dGVybi5wcm90b3R5cGUuX19zcGxpdCA9IGZ1bmN0aW9uKHJlZ2V4cCwgaW5wdXRfc3RyaW5nKSB7XG4gIHJlZ2V4cC5sYXN0SW5kZXggPSAwO1xuICB2YXIgc3RhcnRfaW5kZXggPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBuZXh0X21hdGNoID0gcmVnZXhwLmV4ZWMoaW5wdXRfc3RyaW5nKTtcbiAgd2hpbGUgKG5leHRfbWF0Y2gpIHtcbiAgICByZXN1bHQucHVzaChpbnB1dF9zdHJpbmcuc3Vic3RyaW5nKHN0YXJ0X2luZGV4LCBuZXh0X21hdGNoLmluZGV4KSk7XG4gICAgc3RhcnRfaW5kZXggPSBuZXh0X21hdGNoLmluZGV4ICsgbmV4dF9tYXRjaFswXS5sZW5ndGg7XG4gICAgbmV4dF9tYXRjaCA9IHJlZ2V4cC5leGVjKGlucHV0X3N0cmluZyk7XG4gIH1cblxuICBpZiAoc3RhcnRfaW5kZXggPCBpbnB1dF9zdHJpbmcubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnB1c2goaW5wdXRfc3RyaW5nLnN1YnN0cmluZyhzdGFydF9pbmRleCwgaW5wdXRfc3RyaW5nLmxlbmd0aCkpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxubW9kdWxlLmV4cG9ydHMuV2hpdGVzcGFjZVBhdHRlcm4gPSBXaGl0ZXNwYWNlUGF0dGVybjtcblxuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxuZnVuY3Rpb24gUGF0dGVybihpbnB1dF9zY2FubmVyLCBwYXJlbnQpIHtcbiAgdGhpcy5faW5wdXQgPSBpbnB1dF9zY2FubmVyO1xuICB0aGlzLl9zdGFydGluZ19wYXR0ZXJuID0gbnVsbDtcbiAgdGhpcy5fbWF0Y2hfcGF0dGVybiA9IG51bGw7XG4gIHRoaXMuX3VudGlsX3BhdHRlcm4gPSBudWxsO1xuICB0aGlzLl91bnRpbF9hZnRlciA9IGZhbHNlO1xuXG4gIGlmIChwYXJlbnQpIHtcbiAgICB0aGlzLl9zdGFydGluZ19wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChwYXJlbnQuX3N0YXJ0aW5nX3BhdHRlcm4sIHRydWUpO1xuICAgIHRoaXMuX21hdGNoX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhcmVudC5fbWF0Y2hfcGF0dGVybiwgdHJ1ZSk7XG4gICAgdGhpcy5fdW50aWxfcGF0dGVybiA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAocGFyZW50Ll91bnRpbF9wYXR0ZXJuKTtcbiAgICB0aGlzLl91bnRpbF9hZnRlciA9IHBhcmVudC5fdW50aWxfYWZ0ZXI7XG4gIH1cbn1cblxuUGF0dGVybi5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5faW5wdXQucmVhZCh0aGlzLl9zdGFydGluZ19wYXR0ZXJuKTtcbiAgaWYgKCF0aGlzLl9zdGFydGluZ19wYXR0ZXJuIHx8IHJlc3VsdCkge1xuICAgIHJlc3VsdCArPSB0aGlzLl9pbnB1dC5yZWFkKHRoaXMuX21hdGNoX3BhdHRlcm4sIHRoaXMuX3VudGlsX3BhdHRlcm4sIHRoaXMuX3VudGlsX2FmdGVyKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuUGF0dGVybi5wcm90b3R5cGUucmVhZF9tYXRjaCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5faW5wdXQubWF0Y2godGhpcy5fbWF0Y2hfcGF0dGVybik7XG59O1xuXG5QYXR0ZXJuLnByb3RvdHlwZS51bnRpbF9hZnRlciA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2NyZWF0ZSgpO1xuICByZXN1bHQuX3VudGlsX2FmdGVyID0gdHJ1ZTtcbiAgcmVzdWx0Ll91bnRpbF9wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChwYXR0ZXJuKTtcbiAgcmVzdWx0Ll91cGRhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblBhdHRlcm4ucHJvdG90eXBlLnVudGlsID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fY3JlYXRlKCk7XG4gIHJlc3VsdC5fdW50aWxfYWZ0ZXIgPSBmYWxzZTtcbiAgcmVzdWx0Ll91bnRpbF9wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChwYXR0ZXJuKTtcbiAgcmVzdWx0Ll91cGRhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblBhdHRlcm4ucHJvdG90eXBlLnN0YXJ0aW5nX3dpdGggPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9jcmVhdGUoKTtcbiAgcmVzdWx0Ll9zdGFydGluZ19wYXR0ZXJuID0gdGhpcy5faW5wdXQuZ2V0X3JlZ2V4cChwYXR0ZXJuLCB0cnVlKTtcbiAgcmVzdWx0Ll91cGRhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblBhdHRlcm4ucHJvdG90eXBlLm1hdGNoaW5nID0gZnVuY3Rpb24ocGF0dGVybikge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fY3JlYXRlKCk7XG4gIHJlc3VsdC5fbWF0Y2hfcGF0dGVybiA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAocGF0dGVybiwgdHJ1ZSk7XG4gIHJlc3VsdC5fdXBkYXRlKCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5QYXR0ZXJuLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgUGF0dGVybih0aGlzLl9pbnB1dCwgdGhpcyk7XG59O1xuXG5QYXR0ZXJuLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24oKSB7fTtcblxubW9kdWxlLmV4cG9ydHMuUGF0dGVybiA9IFBhdHRlcm47XG5cblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vKmpzaGludCBub2RlOnRydWUgKi9cbi8qXG5cbiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbiAgQ29weXJpZ2h0IChjKSAyMDA3LTIwMTggRWluYXIgTGllbG1hbmlzLCBMaWFtIE5ld21hbiwgYW5kIGNvbnRyaWJ1dG9ycy5cblxuICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gIFNPRlRXQVJFLlxuKi9cblxuXG5cbmZ1bmN0aW9uIERpcmVjdGl2ZXMoc3RhcnRfYmxvY2tfcGF0dGVybiwgZW5kX2Jsb2NrX3BhdHRlcm4pIHtcbiAgc3RhcnRfYmxvY2tfcGF0dGVybiA9IHR5cGVvZiBzdGFydF9ibG9ja19wYXR0ZXJuID09PSAnc3RyaW5nJyA/IHN0YXJ0X2Jsb2NrX3BhdHRlcm4gOiBzdGFydF9ibG9ja19wYXR0ZXJuLnNvdXJjZTtcbiAgZW5kX2Jsb2NrX3BhdHRlcm4gPSB0eXBlb2YgZW5kX2Jsb2NrX3BhdHRlcm4gPT09ICdzdHJpbmcnID8gZW5kX2Jsb2NrX3BhdHRlcm4gOiBlbmRfYmxvY2tfcGF0dGVybi5zb3VyY2U7XG4gIHRoaXMuX19kaXJlY3RpdmVzX2Jsb2NrX3BhdHRlcm4gPSBuZXcgUmVnRXhwKHN0YXJ0X2Jsb2NrX3BhdHRlcm4gKyAvIGJlYXV0aWZ5KCBcXHcrWzpdXFx3KykrIC8uc291cmNlICsgZW5kX2Jsb2NrX3BhdHRlcm4sICdnJyk7XG4gIHRoaXMuX19kaXJlY3RpdmVfcGF0dGVybiA9IC8gKFxcdyspWzpdKFxcdyspL2c7XG5cbiAgdGhpcy5fX2RpcmVjdGl2ZXNfZW5kX2lnbm9yZV9wYXR0ZXJuID0gbmV3IFJlZ0V4cChzdGFydF9ibG9ja19wYXR0ZXJuICsgL1xcc2JlYXV0aWZ5XFxzaWdub3JlOmVuZFxccy8uc291cmNlICsgZW5kX2Jsb2NrX3BhdHRlcm4sICdnJyk7XG59XG5cbkRpcmVjdGl2ZXMucHJvdG90eXBlLmdldF9kaXJlY3RpdmVzID0gZnVuY3Rpb24odGV4dCkge1xuICBpZiAoIXRleHQubWF0Y2godGhpcy5fX2RpcmVjdGl2ZXNfYmxvY2tfcGF0dGVybikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBkaXJlY3RpdmVzID0ge307XG4gIHRoaXMuX19kaXJlY3RpdmVfcGF0dGVybi5sYXN0SW5kZXggPSAwO1xuICB2YXIgZGlyZWN0aXZlX21hdGNoID0gdGhpcy5fX2RpcmVjdGl2ZV9wYXR0ZXJuLmV4ZWModGV4dCk7XG5cbiAgd2hpbGUgKGRpcmVjdGl2ZV9tYXRjaCkge1xuICAgIGRpcmVjdGl2ZXNbZGlyZWN0aXZlX21hdGNoWzFdXSA9IGRpcmVjdGl2ZV9tYXRjaFsyXTtcbiAgICBkaXJlY3RpdmVfbWF0Y2ggPSB0aGlzLl9fZGlyZWN0aXZlX3BhdHRlcm4uZXhlYyh0ZXh0KTtcbiAgfVxuXG4gIHJldHVybiBkaXJlY3RpdmVzO1xufTtcblxuRGlyZWN0aXZlcy5wcm90b3R5cGUucmVhZElnbm9yZWQgPSBmdW5jdGlvbihpbnB1dCkge1xuICByZXR1cm4gaW5wdXQucmVhZFVudGlsQWZ0ZXIodGhpcy5fX2RpcmVjdGl2ZXNfZW5kX2lnbm9yZV9wYXR0ZXJuKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMuRGlyZWN0aXZlcyA9IERpcmVjdGl2ZXM7XG5cblxuLyoqKi8gfSksXG4vKiAxNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qanNoaW50IG5vZGU6dHJ1ZSAqL1xuLypcblxuICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuICBDb3B5cmlnaHQgKGMpIDIwMDctMjAxOCBFaW5hciBMaWVsbWFuaXMsIExpYW0gTmV3bWFuLCBhbmQgY29udHJpYnV0b3JzLlxuXG4gIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgU09GVFdBUkUuXG4qL1xuXG5cblxudmFyIFBhdHRlcm4gPSAoX193ZWJwYWNrX3JlcXVpcmVfXygxMikuUGF0dGVybik7XG5cblxudmFyIHRlbXBsYXRlX25hbWVzID0ge1xuICBkamFuZ286IGZhbHNlLFxuICBlcmI6IGZhbHNlLFxuICBoYW5kbGViYXJzOiBmYWxzZSxcbiAgcGhwOiBmYWxzZSxcbiAgc21hcnR5OiBmYWxzZVxufTtcblxuLy8gVGhpcyBsZXRzIHRlbXBsYXRlcyBhcHBlYXIgYW55d2hlcmUgd2Ugd291bGQgZG8gYSByZWFkVW50aWxcbi8vIFRoZSBjb3N0IGlzIGhpZ2hlciBidXQgaXQgaXMgcGF5IHRvIHBsYXkuXG5mdW5jdGlvbiBUZW1wbGF0YWJsZVBhdHRlcm4oaW5wdXRfc2Nhbm5lciwgcGFyZW50KSB7XG4gIFBhdHRlcm4uY2FsbCh0aGlzLCBpbnB1dF9zY2FubmVyLCBwYXJlbnQpO1xuICB0aGlzLl9fdGVtcGxhdGVfcGF0dGVybiA9IG51bGw7XG4gIHRoaXMuX2Rpc2FibGVkID0gT2JqZWN0LmFzc2lnbih7fSwgdGVtcGxhdGVfbmFtZXMpO1xuICB0aGlzLl9leGNsdWRlZCA9IE9iamVjdC5hc3NpZ24oe30sIHRlbXBsYXRlX25hbWVzKTtcblxuICBpZiAocGFyZW50KSB7XG4gICAgdGhpcy5fX3RlbXBsYXRlX3BhdHRlcm4gPSB0aGlzLl9pbnB1dC5nZXRfcmVnZXhwKHBhcmVudC5fX3RlbXBsYXRlX3BhdHRlcm4pO1xuICAgIHRoaXMuX2V4Y2x1ZGVkID0gT2JqZWN0LmFzc2lnbih0aGlzLl9leGNsdWRlZCwgcGFyZW50Ll9leGNsdWRlZCk7XG4gICAgdGhpcy5fZGlzYWJsZWQgPSBPYmplY3QuYXNzaWduKHRoaXMuX2Rpc2FibGVkLCBwYXJlbnQuX2Rpc2FibGVkKTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IG5ldyBQYXR0ZXJuKGlucHV0X3NjYW5uZXIpO1xuICB0aGlzLl9fcGF0dGVybnMgPSB7XG4gICAgaGFuZGxlYmFyc19jb21tZW50OiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoL3t7IS0tLykudW50aWxfYWZ0ZXIoLy0tfX0vKSxcbiAgICBoYW5kbGViYXJzX3VuZXNjYXBlZDogcGF0dGVybi5zdGFydGluZ193aXRoKC97e3svKS51bnRpbF9hZnRlcigvfX19LyksXG4gICAgaGFuZGxlYmFyczogcGF0dGVybi5zdGFydGluZ193aXRoKC97ey8pLnVudGlsX2FmdGVyKC99fS8pLFxuICAgIHBocDogcGF0dGVybi5zdGFydGluZ193aXRoKC88XFw/KD86Wz0gXXxwaHApLykudW50aWxfYWZ0ZXIoL1xcPz4vKSxcbiAgICBlcmI6IHBhdHRlcm4uc3RhcnRpbmdfd2l0aCgvPCVbXiVdLykudW50aWxfYWZ0ZXIoL1teJV0lPi8pLFxuICAgIC8vIGRqYW5nbyBjb2ZsaWN0cyB3aXRoIGhhbmRsZWJhcnMgYSBiaXQuXG4gICAgZGphbmdvOiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoL3slLykudW50aWxfYWZ0ZXIoLyV9LyksXG4gICAgZGphbmdvX3ZhbHVlOiBwYXR0ZXJuLnN0YXJ0aW5nX3dpdGgoL3t7LykudW50aWxfYWZ0ZXIoL319LyksXG4gICAgZGphbmdvX2NvbW1lbnQ6IHBhdHRlcm4uc3RhcnRpbmdfd2l0aCgveyMvKS51bnRpbF9hZnRlcigvI30vKSxcbiAgICBzbWFydHk6IHBhdHRlcm4uc3RhcnRpbmdfd2l0aCgveyg/PVtefXtcXHNcXG5dKS8pLnVudGlsX2FmdGVyKC9bXlxcc1xcbl19LyksXG4gICAgc21hcnR5X2NvbW1lbnQ6IHBhdHRlcm4uc3RhcnRpbmdfd2l0aCgve1xcKi8pLnVudGlsX2FmdGVyKC9cXCp9LyksXG4gICAgc21hcnR5X2xpdGVyYWw6IHBhdHRlcm4uc3RhcnRpbmdfd2l0aCgve2xpdGVyYWx9LykudW50aWxfYWZ0ZXIoL3tcXC9saXRlcmFsfS8pXG4gIH07XG59XG5UZW1wbGF0YWJsZVBhdHRlcm4ucHJvdG90eXBlID0gbmV3IFBhdHRlcm4oKTtcblxuVGVtcGxhdGFibGVQYXR0ZXJuLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGVtcGxhdGFibGVQYXR0ZXJuKHRoaXMuX2lucHV0LCB0aGlzKTtcbn07XG5cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9fc2V0X3RlbXBsYXRlZF9wYXR0ZXJuKCk7XG59O1xuXG5UZW1wbGF0YWJsZVBhdHRlcm4ucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbihsYW5ndWFnZSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fY3JlYXRlKCk7XG4gIHJlc3VsdC5fZGlzYWJsZWRbbGFuZ3VhZ2VdID0gdHJ1ZTtcbiAgcmVzdWx0Ll91cGRhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUucmVhZF9vcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fY3JlYXRlKCk7XG4gIGZvciAodmFyIGxhbmd1YWdlIGluIHRlbXBsYXRlX25hbWVzKSB7XG4gICAgcmVzdWx0Ll9kaXNhYmxlZFtsYW5ndWFnZV0gPSBvcHRpb25zLnRlbXBsYXRpbmcuaW5kZXhPZihsYW5ndWFnZSkgPT09IC0xO1xuICB9XG4gIHJlc3VsdC5fdXBkYXRlKCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5UZW1wbGF0YWJsZVBhdHRlcm4ucHJvdG90eXBlLmV4Y2x1ZGUgPSBmdW5jdGlvbihsYW5ndWFnZSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5fY3JlYXRlKCk7XG4gIHJlc3VsdC5fZXhjbHVkZWRbbGFuZ3VhZ2VdID0gdHJ1ZTtcbiAgcmVzdWx0Ll91cGRhdGUoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGlzLl9tYXRjaF9wYXR0ZXJuKSB7XG4gICAgcmVzdWx0ID0gdGhpcy5faW5wdXQucmVhZCh0aGlzLl9zdGFydGluZ19wYXR0ZXJuKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSB0aGlzLl9pbnB1dC5yZWFkKHRoaXMuX3N0YXJ0aW5nX3BhdHRlcm4sIHRoaXMuX190ZW1wbGF0ZV9wYXR0ZXJuKTtcbiAgfVxuICB2YXIgbmV4dCA9IHRoaXMuX3JlYWRfdGVtcGxhdGUoKTtcbiAgd2hpbGUgKG5leHQpIHtcbiAgICBpZiAodGhpcy5fbWF0Y2hfcGF0dGVybikge1xuICAgICAgbmV4dCArPSB0aGlzLl9pbnB1dC5yZWFkKHRoaXMuX21hdGNoX3BhdHRlcm4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0ICs9IHRoaXMuX2lucHV0LnJlYWRVbnRpbCh0aGlzLl9fdGVtcGxhdGVfcGF0dGVybik7XG4gICAgfVxuICAgIHJlc3VsdCArPSBuZXh0O1xuICAgIG5leHQgPSB0aGlzLl9yZWFkX3RlbXBsYXRlKCk7XG4gIH1cblxuICBpZiAodGhpcy5fdW50aWxfYWZ0ZXIpIHtcbiAgICByZXN1bHQgKz0gdGhpcy5faW5wdXQucmVhZFVudGlsQWZ0ZXIodGhpcy5fdW50aWxfcGF0dGVybik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblRlbXBsYXRhYmxlUGF0dGVybi5wcm90b3R5cGUuX19zZXRfdGVtcGxhdGVkX3BhdHRlcm4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGl0ZW1zID0gW107XG5cbiAgaWYgKCF0aGlzLl9kaXNhYmxlZC5waHApIHtcbiAgICBpdGVtcy5wdXNoKHRoaXMuX19wYXR0ZXJucy5waHAuX3N0YXJ0aW5nX3BhdHRlcm4uc291cmNlKTtcbiAgfVxuICBpZiAoIXRoaXMuX2Rpc2FibGVkLmhhbmRsZWJhcnMpIHtcbiAgICBpdGVtcy5wdXNoKHRoaXMuX19wYXR0ZXJucy5oYW5kbGViYXJzLl9zdGFydGluZ19wYXR0ZXJuLnNvdXJjZSk7XG4gIH1cbiAgaWYgKCF0aGlzLl9kaXNhYmxlZC5lcmIpIHtcbiAgICBpdGVtcy5wdXNoKHRoaXMuX19wYXR0ZXJucy5lcmIuX3N0YXJ0aW5nX3BhdHRlcm4uc291cmNlKTtcbiAgfVxuICBpZiAoIXRoaXMuX2Rpc2FibGVkLmRqYW5nbykge1xuICAgIGl0ZW1zLnB1c2godGhpcy5fX3BhdHRlcm5zLmRqYW5nby5fc3RhcnRpbmdfcGF0dGVybi5zb3VyY2UpO1xuICAgIC8vIFRoZSBzdGFydGluZyBwYXR0ZXJuIGZvciBkamFuZ28gaXMgbW9yZSBjb21wbGV4IGJlY2F1c2UgaXQgaGFzIGRpZmZlcmVudFxuICAgIC8vIHBhdHRlcm5zIGZvciB2YWx1ZSwgY29tbWVudCwgYW5kIG90aGVyIHNlY3Rpb25zXG4gICAgaXRlbXMucHVzaCh0aGlzLl9fcGF0dGVybnMuZGphbmdvX3ZhbHVlLl9zdGFydGluZ19wYXR0ZXJuLnNvdXJjZSk7XG4gICAgaXRlbXMucHVzaCh0aGlzLl9fcGF0dGVybnMuZGphbmdvX2NvbW1lbnQuX3N0YXJ0aW5nX3BhdHRlcm4uc291cmNlKTtcbiAgfVxuICBpZiAoIXRoaXMuX2Rpc2FibGVkLnNtYXJ0eSkge1xuICAgIGl0ZW1zLnB1c2godGhpcy5fX3BhdHRlcm5zLnNtYXJ0eS5fc3RhcnRpbmdfcGF0dGVybi5zb3VyY2UpO1xuICB9XG5cbiAgaWYgKHRoaXMuX3VudGlsX3BhdHRlcm4pIHtcbiAgICBpdGVtcy5wdXNoKHRoaXMuX3VudGlsX3BhdHRlcm4uc291cmNlKTtcbiAgfVxuICB0aGlzLl9fdGVtcGxhdGVfcGF0dGVybiA9IHRoaXMuX2lucHV0LmdldF9yZWdleHAoJyg/OicgKyBpdGVtcy5qb2luKCd8JykgKyAnKScpO1xufTtcblxuVGVtcGxhdGFibGVQYXR0ZXJuLnByb3RvdHlwZS5fcmVhZF90ZW1wbGF0ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzdWx0aW5nX3N0cmluZyA9ICcnO1xuICB2YXIgYyA9IHRoaXMuX2lucHV0LnBlZWsoKTtcbiAgaWYgKGMgPT09ICc8Jykge1xuICAgIHZhciBwZWVrMSA9IHRoaXMuX2lucHV0LnBlZWsoMSk7XG4gICAgLy9pZiB3ZSdyZSBpbiBhIGNvbW1lbnQsIGRvIHNvbWV0aGluZyBzcGVjaWFsXG4gICAgLy8gV2UgdHJlYXQgYWxsIGNvbW1lbnRzIGFzIGxpdGVyYWxzLCBldmVuIG1vcmUgdGhhbiBwcmVmb3JtYXR0ZWQgdGFnc1xuICAgIC8vIHdlIGp1c3QgbG9vayBmb3IgdGhlIGFwcHJvcHJpYXRlIGNsb3NlIHRhZ1xuICAgIGlmICghdGhpcy5fZGlzYWJsZWQucGhwICYmICF0aGlzLl9leGNsdWRlZC5waHAgJiYgcGVlazEgPT09ICc/Jykge1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHxcbiAgICAgICAgdGhpcy5fX3BhdHRlcm5zLnBocC5yZWFkKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fZGlzYWJsZWQuZXJiICYmICF0aGlzLl9leGNsdWRlZC5lcmIgJiYgcGVlazEgPT09ICclJykge1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHxcbiAgICAgICAgdGhpcy5fX3BhdHRlcm5zLmVyYi5yZWFkKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGMgPT09ICd7Jykge1xuICAgIGlmICghdGhpcy5fZGlzYWJsZWQuaGFuZGxlYmFycyAmJiAhdGhpcy5fZXhjbHVkZWQuaGFuZGxlYmFycykge1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHxcbiAgICAgICAgdGhpcy5fX3BhdHRlcm5zLmhhbmRsZWJhcnNfY29tbWVudC5yZWFkKCk7XG4gICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fFxuICAgICAgICB0aGlzLl9fcGF0dGVybnMuaGFuZGxlYmFyc191bmVzY2FwZWQucmVhZCgpO1xuICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHxcbiAgICAgICAgdGhpcy5fX3BhdHRlcm5zLmhhbmRsZWJhcnMucmVhZCgpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2Rpc2FibGVkLmRqYW5nbykge1xuICAgICAgLy8gZGphbmdvIGNvZmxpY3RzIHdpdGggaGFuZGxlYmFycyBhIGJpdC5cbiAgICAgIGlmICghdGhpcy5fZXhjbHVkZWQuZGphbmdvICYmICF0aGlzLl9leGNsdWRlZC5oYW5kbGViYXJzKSB7XG4gICAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgICAgdGhpcy5fX3BhdHRlcm5zLmRqYW5nb192YWx1ZS5yZWFkKCk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX2V4Y2x1ZGVkLmRqYW5nbykge1xuICAgICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fFxuICAgICAgICAgIHRoaXMuX19wYXR0ZXJucy5kamFuZ29fY29tbWVudC5yZWFkKCk7XG4gICAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgICAgdGhpcy5fX3BhdHRlcm5zLmRqYW5nby5yZWFkKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5fZGlzYWJsZWQuc21hcnR5KSB7XG4gICAgICAvLyBzbWFydHkgY2Fubm90IGJlIGVuYWJsZWQgd2l0aCBkamFuZ28gb3IgaGFuZGxlYmFycyBlbmFibGVkXG4gICAgICBpZiAodGhpcy5fZGlzYWJsZWQuZGphbmdvICYmIHRoaXMuX2Rpc2FibGVkLmhhbmRsZWJhcnMpIHtcbiAgICAgICAgcmVzdWx0aW5nX3N0cmluZyA9IHJlc3VsdGluZ19zdHJpbmcgfHxcbiAgICAgICAgICB0aGlzLl9fcGF0dGVybnMuc21hcnR5X2NvbW1lbnQucmVhZCgpO1xuICAgICAgICByZXN1bHRpbmdfc3RyaW5nID0gcmVzdWx0aW5nX3N0cmluZyB8fFxuICAgICAgICAgIHRoaXMuX19wYXR0ZXJucy5zbWFydHlfbGl0ZXJhbC5yZWFkKCk7XG4gICAgICAgIHJlc3VsdGluZ19zdHJpbmcgPSByZXN1bHRpbmdfc3RyaW5nIHx8XG4gICAgICAgICAgdGhpcy5fX3BhdHRlcm5zLnNtYXJ0eS5yZWFkKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRpbmdfc3RyaW5nO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cy5UZW1wbGF0YWJsZVBhdHRlcm4gPSBUZW1wbGF0YWJsZVBhdHRlcm47XG5cblxuLyoqKi8gfSlcbi8qKioqKiovIFx0XSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcbi8qKioqKiovIFx0XHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBzdGFydHVwXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHQvLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyBcdGxlZ2FjeV9iZWF1dGlmeV9qcyA9IF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyBcdFxuLyoqKioqKi8gfSkoKVxuO1xudmFyIGpzX2JlYXV0aWZ5ID0gbGVnYWN5X2JlYXV0aWZ5X2pzO1xuLyogRm9vdGVyICovXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBBZGQgc3VwcG9ydCBmb3IgQU1EICggaHR0cHM6Ly9naXRodWIuY29tL2FtZGpzL2FtZGpzLWFwaS93aWtpL0FNRCNkZWZpbmVhbWQtcHJvcGVydHktIClcbiAgICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4geyBqc19iZWF1dGlmeToganNfYmVhdXRpZnkgfTtcbiAgICB9KTtcbn0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBBZGQgc3VwcG9ydCBmb3IgQ29tbW9uSlMuIEp1c3QgcHV0IHRoaXMgZmlsZSBzb21ld2hlcmUgb24geW91ciByZXF1aXJlLnBhdGhzXG4gICAgLy8gYW5kIHlvdSB3aWxsIGJlIGFibGUgdG8gYHZhciBqc19iZWF1dGlmeSA9IHJlcXVpcmUoXCJiZWF1dGlmeVwiKS5qc19iZWF1dGlmeWAuXG4gICAgZXhwb3J0cy5qc19iZWF1dGlmeSA9IGpzX2JlYXV0aWZ5O1xufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gSWYgd2UncmUgcnVubmluZyBhIHdlYiBwYWdlIGFuZCBkb24ndCBoYXZlIGVpdGhlciBvZiB0aGUgYWJvdmUsIGFkZCBvdXIgb25lIGdsb2JhbFxuICAgIHdpbmRvdy5qc19iZWF1dGlmeSA9IGpzX2JlYXV0aWZ5O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gSWYgd2UgZG9uJ3QgZXZlbiBoYXZlIHdpbmRvdywgdHJ5IGdsb2JhbC5cbiAgICBnbG9iYWwuanNfYmVhdXRpZnkgPSBqc19iZWF1dGlmeTtcbn1cblxufSgpKTtcblxuIl0sIm5hbWVzIjpbImxlZ2FjeV9iZWF1dGlmeV9qcyIsIl9fd2VicGFja19tb2R1bGVzX18iLCJtb2R1bGUiLCJfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwiQmVhdXRpZmllciIsIk9wdGlvbnMiLCJqc19iZWF1dGlmeSIsImpzX3NvdXJjZV90ZXh0Iiwib3B0aW9ucyIsImJlYXV0aWZpZXIiLCJiZWF1dGlmeSIsImV4cG9ydHMiLCJkZWZhdWx0T3B0aW9ucyIsIk91dHB1dCIsIlRva2VuIiwiYWNvcm4iLCJUb2tlbml6ZXIiLCJsaW5lX3N0YXJ0ZXJzIiwicG9zaXRpb25hYmxlX29wZXJhdG9ycyIsIlRPS0VOIiwiaW5fYXJyYXkiLCJ3aGF0IiwiYXJyIiwiaW5kZXhPZiIsImx0cmltIiwicyIsInJlcGxhY2UiLCJnZW5lcmF0ZU1hcEZyb21TdHJpbmdzIiwibGlzdCIsInJlc3VsdCIsIngiLCJsZW5ndGgiLCJyZXNlcnZlZF93b3JkIiwidG9rZW4iLCJ3b3JkIiwidHlwZSIsIlJFU0VSVkVEIiwidGV4dCIsInJlc2VydmVkX2FycmF5Iiwid29yZHMiLCJzcGVjaWFsX3dvcmRzIiwidmFsaWRQb3NpdGlvblZhbHVlcyIsIk9QRVJBVE9SX1BPU0lUSU9OIiwiT1BFUkFUT1JfUE9TSVRJT05fQkVGT1JFX09SX1BSRVNFUlZFIiwiYmVmb3JlX25ld2xpbmUiLCJwcmVzZXJ2ZV9uZXdsaW5lIiwiTU9ERSIsIkJsb2NrU3RhdGVtZW50IiwiU3RhdGVtZW50IiwiT2JqZWN0TGl0ZXJhbCIsIkFycmF5TGl0ZXJhbCIsIkZvckluaXRpYWxpemVyIiwiQ29uZGl0aW9uYWwiLCJFeHByZXNzaW9uIiwicmVtb3ZlX3JlZHVuZGFudF9pbmRlbnRhdGlvbiIsIm91dHB1dCIsImZyYW1lIiwibXVsdGlsaW5lX2ZyYW1lIiwibW9kZSIsInJlbW92ZV9pbmRlbnQiLCJzdGFydF9saW5lX2luZGV4Iiwic3BsaXRfbGluZWJyZWFrcyIsImFsbExpbmVCcmVha3MiLCJvdXQiLCJpZHgiLCJwdXNoIiwic3Vic3RyaW5nIiwiaXNfYXJyYXkiLCJpc19leHByZXNzaW9uIiwiYWxsX2xpbmVzX3N0YXJ0X3dpdGgiLCJsaW5lcyIsImMiLCJpIiwibGluZSIsInRyaW0iLCJjaGFyQXQiLCJlYWNoX2xpbmVfbWF0Y2hlc19pbmRlbnQiLCJpbmRlbnQiLCJsZW4iLCJzb3VyY2VfdGV4dCIsIl9zb3VyY2VfdGV4dCIsIl9vdXRwdXQiLCJfdG9rZW5zIiwiX2xhc3RfbGFzdF90ZXh0IiwiX2ZsYWdzIiwiX3ByZXZpb3VzX2ZsYWdzIiwiX2ZsYWdfc3RvcmUiLCJfb3B0aW9ucyIsInByb3RvdHlwZSIsImNyZWF0ZV9mbGFncyIsImZsYWdzX2Jhc2UiLCJuZXh0X2luZGVudF9sZXZlbCIsImluZGVudGF0aW9uX2xldmVsIiwianVzdF9hZGRlZF9uZXdsaW5lIiwibGluZV9pbmRlbnRfbGV2ZWwiLCJuZXh0X2ZsYWdzIiwicGFyZW50IiwibGFzdF90b2tlbiIsIlNUQVJUX0JMT0NLIiwibGFzdF93b3JkIiwiZGVjbGFyYXRpb25fc3RhdGVtZW50IiwiZGVjbGFyYXRpb25fYXNzaWdubWVudCIsImlubGluZV9mcmFtZSIsImlmX2Jsb2NrIiwiZWxzZV9ibG9jayIsImNsYXNzX3N0YXJ0X2Jsb2NrIiwiZG9fYmxvY2siLCJkb193aGlsZSIsImltcG9ydF9ibG9jayIsImluX2Nhc2Vfc3RhdGVtZW50IiwiaW5fY2FzZSIsImNhc2VfYm9keSIsImNhc2VfYmxvY2siLCJhbGlnbm1lbnQiLCJnZXRfbGluZV9udW1iZXIiLCJ0ZXJuYXJ5X2RlcHRoIiwiX3Jlc2V0IiwiYmFzZUluZGVudFN0cmluZyIsIm1hdGNoIiwicmF3IiwidGVzdF9vdXRwdXRfcmF3Iiwic2V0X21vZGUiLCJ0b2tlbml6ZXIiLCJ0b2tlbml6ZSIsImRpc2FibGVkIiwic3dlZXRfY29kZSIsImVvbCIsImxpbmVCcmVhayIsInRlc3QiLCJjdXJyZW50X3Rva2VuIiwibmV4dCIsImhhbmRsZV90b2tlbiIsImdldF9jb2RlIiwicHJlc2VydmVfc3RhdGVtZW50X2ZsYWdzIiwiU1RBUlRfRVhQUiIsImhhbmRsZV9zdGFydF9leHByIiwiRU5EX0VYUFIiLCJoYW5kbGVfZW5kX2V4cHIiLCJoYW5kbGVfc3RhcnRfYmxvY2siLCJFTkRfQkxPQ0siLCJoYW5kbGVfZW5kX2Jsb2NrIiwiV09SRCIsImhhbmRsZV93b3JkIiwiU0VNSUNPTE9OIiwiaGFuZGxlX3NlbWljb2xvbiIsIlNUUklORyIsImhhbmRsZV9zdHJpbmciLCJFUVVBTFMiLCJoYW5kbGVfZXF1YWxzIiwiT1BFUkFUT1IiLCJoYW5kbGVfb3BlcmF0b3IiLCJDT01NQSIsImhhbmRsZV9jb21tYSIsIkJMT0NLX0NPTU1FTlQiLCJoYW5kbGVfYmxvY2tfY29tbWVudCIsIkNPTU1FTlQiLCJoYW5kbGVfY29tbWVudCIsIkRPVCIsImhhbmRsZV9kb3QiLCJFT0YiLCJoYW5kbGVfZW9mIiwiVU5LTk9XTiIsImhhbmRsZV91bmtub3duIiwiaGFuZGxlX3doaXRlc3BhY2VfYW5kX2NvbW1lbnRzIiwibmV3bGluZXMiLCJrZWVwX3doaXRlc3BhY2UiLCJrZWVwX2FycmF5X2luZGVudGF0aW9uIiwiY29tbWVudHNfYmVmb3JlIiwiY29tbWVudF90b2tlbiIsInByaW50X25ld2xpbmUiLCJtYXhfcHJlc2VydmVfbmV3bGluZXMiLCJwcmVzZXJ2ZV9uZXdsaW5lcyIsImoiLCJuZXdsaW5lX3Jlc3RyaWN0ZWRfdG9rZW5zIiwiYWxsb3dfd3JhcF9vcl9wcmVzZXJ2ZWRfbmV3bGluZSIsImZvcmNlX2xpbmV3cmFwIiwidW5kZWZpbmVkIiwic2hvdWxkUHJlc2VydmVPckZvcmNlIiwib3BlcmF0b3JMb2dpY0FwcGxpZXMiLCJzaG91bGRQcmludE9wZXJhdG9yTmV3bGluZSIsIm9wZXJhdG9yX3Bvc2l0aW9uIiwid3JhcF9saW5lX2xlbmd0aCIsInNldF93cmFwX3BvaW50IiwiZm9yY2VfbmV3bGluZSIsIm5leHRfdG9rZW4iLCJwZWVrIiwicmVzdG9yZV9tb2RlIiwiYWRkX25ld19saW5lIiwicHJpbnRfdG9rZW5fbGluZV9pbmRlbnRhdGlvbiIsImN1cnJlbnRfbGluZSIsInNldF9pbmRlbnQiLCJ3aGl0ZXNwYWNlX2JlZm9yZSIsInNwYWNlX2JlZm9yZV90b2tlbiIsInByaW50X3Rva2VuIiwiYWRkX3Jhd190b2tlbiIsImNvbW1hX2ZpcnN0IiwicHJldmlvdXMiLCJwcmV2aW91c19saW5lIiwibGFzdCIsInBvcHBlZCIsInBvcCIsImlzX2VtcHR5IiwiYWRkX3Rva2VuIiwibm9uX2JyZWFraW5nX3NwYWNlIiwicHJldmlvdXNfdG9rZW5fd3JhcHBlZCIsImRlaW5kZW50Iiwic3RhcnRfb2Zfb2JqZWN0X3Byb3BlcnR5Iiwic3RhcnRfb2Zfc3RhdGVtZW50Iiwic3RhcnQiLCJuZXh0X21vZGUiLCJzcGFjZV9pbl9wYXJlbiIsInNwYWNlX2JlZm9yZV9jb25kaXRpb25hbCIsInBlZWtfYmFja190d28iLCJzcGFjZV9hZnRlcl9uYW1lZF9mdW5jdGlvbiIsInBlZWtfYmFja190aHJlZSIsInNwYWNlX2FmdGVyX2Fub25fZnVuY3Rpb24iLCJzcGFjZV9pbl9lbXB0eV9wYXJlbiIsInNlY29uZF90b2tlbiIsImVtcHR5X2JyYWNlcyIsImVtcHR5X2Fub255bW91c19mdW5jdGlvbiIsImJyYWNlX3ByZXNlcnZlX2lubGluZSIsImluZGV4IiwiY2hlY2tfdG9rZW4iLCJvcGVuZWQiLCJicmFjZV9zdHlsZSIsImpzbGludF9oYXBweSIsImp1c3RfYWRkZWRfYmxhbmtsaW5lIiwicHJlZml4Iiwic3RhcnRzV2l0aCIsImlzR2VuZXJhdG9yQXN0ZXJpc2siLCJpc1VuYXJ5Iiwic3BhY2VfYmVmb3JlIiwic3BhY2VfYWZ0ZXIiLCJpbl90ZXJuYXJ5IiwiaXNDb2xvbiIsImlzVGVybmFyeUNvbG9uIiwiaXNPdGhlckNvbG9uIiwiYWZ0ZXJfbmV3bGluZSIsIm5ld19saW5lX25lZWRlZCIsImRpcmVjdGl2ZXMiLCJwcmVzZXJ2ZSIsIm5ld2xpbmUiLCJwcmludF9ibG9ja19jb21tbWVudCIsImphdmFkb2MiLCJzdGFybGVzcyIsImxhc3RJbmRlbnQiLCJsYXN0SW5kZW50TGVuZ3RoIiwic2xpY2UiLCJicmVha19jaGFpbmVkX21ldGhvZHMiLCJ1bmluZGVudF9jaGFpbmVkX21ldGhvZHMiLCJPdXRwdXRMaW5lIiwiX19wYXJlbnQiLCJfX2NoYXJhY3Rlcl9jb3VudCIsIl9faW5kZW50X2NvdW50IiwiX19hbGlnbm1lbnRfY291bnQiLCJfX3dyYXBfcG9pbnRfaW5kZXgiLCJfX3dyYXBfcG9pbnRfY2hhcmFjdGVyX2NvdW50IiwiX193cmFwX3BvaW50X2luZGVudF9jb3VudCIsIl9fd3JhcF9wb2ludF9hbGlnbm1lbnRfY291bnQiLCJfX2l0ZW1zIiwiY2xvbmVfZW1wdHkiLCJpdGVtIiwiaGFzX21hdGNoIiwicGF0dGVybiIsImxhc3RDaGVja2VkT3V0cHV0IiwiZ2V0X2luZGVudF9zaXplIiwiX3NldF93cmFwX3BvaW50IiwibmV4dF9saW5lIiwiX3Nob3VsZF93cmFwIiwiX2FsbG93X3dyYXAiLCJzcGxpY2UiLCJsYXN0X25ld2xpbmVfaW5kZXgiLCJsYXN0SW5kZXhPZiIsIl9yZW1vdmVfaW5kZW50IiwiaW5kZW50X3NpemUiLCJfcmVtb3ZlX3dyYXBfaW5kZW50IiwidG9TdHJpbmciLCJpbmRlbnRfZW1wdHlfbGluZXMiLCJnZXRfaW5kZW50X3N0cmluZyIsImpvaW4iLCJJbmRlbnRTdHJpbmdDYWNoZSIsIl9fY2FjaGUiLCJfX2luZGVudF9zaXplIiwiX19pbmRlbnRfc3RyaW5nIiwiaW5kZW50X2NoYXIiLCJpbmRlbnRfd2l0aF90YWJzIiwiQXJyYXkiLCJpbmRlbnRfbGV2ZWwiLCJfX2Jhc2Vfc3RyaW5nIiwiX19iYXNlX3N0cmluZ19sZW5ndGgiLCJjb2x1bW4iLCJfX2Vuc3VyZV9jYWNoZSIsIl9fYWRkX2NvbHVtbiIsIk1hdGgiLCJmbG9vciIsIl9faW5kZW50X2NhY2hlIiwiX2VuZF93aXRoX25ld2xpbmUiLCJlbmRfd2l0aF9uZXdsaW5lIiwiX19saW5lcyIsIl9fYWRkX291dHB1dGxpbmUiLCJsYXN0X2l0ZW0iLCJwcmludGFibGVfdG9rZW4iLCJfX2FkZF9zcGFjZV9iZWZvcmVfdG9rZW4iLCJvdXRwdXRfbGVuZ3RoIiwiZWF0X25ld2xpbmVzIiwiZW5zdXJlX2VtcHR5X2xpbmVfYWJvdmUiLCJzdGFydHNfd2l0aCIsImVuZHNfd2l0aCIsInBvdGVudGlhbEVtcHR5TGluZSIsImNsb3NlZCIsIl9fdW51c2VkX3dlYnBhY2tfbW9kdWxlIiwiYmFzZUFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMiLCJiYXNlQVNDSUlpZGVudGlmaWVyQ2hhcnMiLCJub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzIiwibm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMiLCJ1bmljb2RlRXNjYXBlT3JDb2RlUG9pbnQiLCJpZGVudGlmaWVyU3RhcnQiLCJpZGVudGlmaWVyQ2hhcnMiLCJpZGVudGlmaWVyIiwiUmVnRXhwIiwiaWRlbnRpZmllck1hdGNoIiwibm9uQVNDSUl3aGl0ZXNwYWNlIiwic291cmNlIiwiQmFzZU9wdGlvbnMiLCJjYWxsIiwicmF3X2JyYWNlX3N0eWxlIiwicmF3X29wdGlvbnMiLCJicmFjZXNfb25fb3duX2xpbmUiLCJicmFjZV9zdHlsZV9zcGxpdCIsIl9nZXRfc2VsZWN0aW9uX2xpc3QiLCJicyIsIl9nZXRfYm9vbGVhbiIsInVuZXNjYXBlX3N0cmluZ3MiLCJlNHgiLCJfZ2V0X3NlbGVjdGlvbiIsIm1lcmdlX2NoaWxkX2ZpZWxkIiwiX21lcmdlT3B0cyIsIl9nZXRfY2hhcmFjdGVycyIsIl9nZXRfbnVtYmVyIiwidGVtcGxhdGluZyIsIl9nZXRfYXJyYXkiLCJuYW1lIiwiZGVmYXVsdF92YWx1ZSIsIm9wdGlvbl92YWx1ZSIsImNvbmNhdCIsInNwbGl0IiwicGFyc2VJbnQiLCJpc05hTiIsInNlbGVjdGlvbl9saXN0IiwiRXJyb3IiLCJfaXNfdmFsaWRfc2VsZWN0aW9uIiwic29tZSIsImFsbE9wdGlvbnMiLCJjaGlsZEZpZWxkTmFtZSIsImZpbmFsT3B0cyIsIl9ub3JtYWxpemVPcHRzIiwiY29udmVydGVkT3B0cyIsImtleSIsIm5ld0tleSIsIm5vcm1hbGl6ZU9wdHMiLCJtZXJnZU9wdHMiLCJJbnB1dFNjYW5uZXIiLCJCYXNlVG9rZW5pemVyIiwiQkFTRVRPS0VOIiwiRGlyZWN0aXZlcyIsIlBhdHRlcm4iLCJUZW1wbGF0YWJsZVBhdHRlcm4iLCJTVEFSVCIsIlJBVyIsImRpcmVjdGl2ZXNfY29yZSIsIm51bWJlcl9wYXR0ZXJuIiwiZGlnaXQiLCJkb3RfcGF0dGVybiIsInB1bmN0IiwicHVuY3RfcGF0dGVybiIsInJlc2VydmVkX3dvcmRzIiwicmVzZXJ2ZWRfd29yZF9wYXR0ZXJuIiwiaW5faHRtbF9jb21tZW50IiwiaW5wdXRfc3RyaW5nIiwiX3BhdHRlcm5zIiwid2hpdGVzcGFjZSIsIm1hdGNoaW5nIiwicGF0dGVybl9yZWFkZXIiLCJfaW5wdXQiLCJ0ZW1wbGF0YWJsZSIsInJlYWRfb3B0aW9ucyIsIl9fcGF0dGVybnMiLCJ0ZW1wbGF0ZSIsInN0YXJ0aW5nX3dpdGgiLCJudW1iZXIiLCJjb21tZW50IiwidW50aWwiLCJibG9ja19jb21tZW50IiwidW50aWxfYWZ0ZXIiLCJodG1sX2NvbW1lbnRfc3RhcnQiLCJodG1sX2NvbW1lbnRfZW5kIiwiaW5jbHVkZSIsInNoZWJhbmciLCJ4bWwiLCJzaW5nbGVfcXVvdGUiLCJkb3VibGVfcXVvdGUiLCJ0ZW1wbGF0ZV90ZXh0IiwidGVtcGxhdGVfZXhwcmVzc2lvbiIsIl9pc19jb21tZW50IiwiX2lzX29wZW5pbmciLCJfaXNfY2xvc2luZyIsIm9wZW5fdG9rZW4iLCJfZ2V0X25leHRfdG9rZW4iLCJwcmV2aW91c190b2tlbiIsIl9yZWFkV2hpdGVzcGFjZSIsIl9jcmVhdGVfdG9rZW4iLCJfcmVhZF9ub25famF2YXNjcmlwdCIsIl9yZWFkX3N0cmluZyIsIl9yZWFkX3BhaXIiLCJfcmVhZF93b3JkIiwiX3JlYWRfc2luZ2xlcyIsIl9yZWFkX2NvbW1lbnQiLCJfcmVhZF9yZWdleHAiLCJfcmVhZF94bWwiLCJfcmVhZF9wdW5jdHVhdGlvbiIsInJlc3VsdGluZ19zdHJpbmciLCJyZWFkIiwiZCIsIl9pc19maXJzdF90b2tlbiIsInNoYXJwIiwiaGFzTmV4dCIsInRlc3RDaGFyIiwiYmFjayIsImdldF9kaXJlY3RpdmVzIiwiaWdub3JlIiwicmVhZElnbm9yZWQiLCJoYXNfY2hhcl9lc2NhcGVzIiwiX3JlYWRfc3RyaW5nX3JlY3Vyc2l2ZSIsInVuZXNjYXBlX3N0cmluZyIsIl9hbGxvd19yZWdleHBfb3JfeG1sIiwiZXNjIiwiaW5fY2hhcl9jbGFzcyIsInhtbFN0ciIsInJlYWRfbWF0Y2giLCJyb290VGFnIiwiaXNDdXJseVJvb3QiLCJkZXB0aCIsImlzRW5kVGFnIiwidGFnTmFtZSIsImlzU2luZ2xldG9uVGFnIiwiZXNjYXBlZCIsImlucHV0X3NjYW4iLCJtYXRjaGVkIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiZGVsaW1pdGVyIiwiYWxsb3dfdW5lc2NhcGVkX25ld2xpbmVzIiwic3RhcnRfc3ViIiwiY3VycmVudF9jaGFyIiwicmVnZXhwX2hhc19zdGlja3kiLCJoYXNPd25Qcm9wZXJ0eSIsIl9faW5wdXQiLCJfX2lucHV0X2xlbmd0aCIsIl9fcG9zaXRpb24iLCJyZXN0YXJ0IiwidmFsIiwiX19tYXRjaCIsImxhc3RJbmRleCIsInBhdHRlcm5fbWF0Y2giLCJleGVjIiwic3RpY2t5Iiwic3RhcnRpbmdfcGF0dGVybiIsInVudGlsX3BhdHRlcm4iLCJyZWFkVW50aWwiLCJtYXRjaF9pbmRleCIsInJlYWRVbnRpbEFmdGVyIiwiZ2V0X3JlZ2V4cCIsIm1hdGNoX2Zyb20iLCJmbGFncyIsImdldF9saXRlcmFsX3JlZ2V4cCIsImxpdGVyYWxfc3RyaW5nIiwicGVla1VudGlsQWZ0ZXIiLCJsb29rQmFjayIsInRlc3RWYWwiLCJ0b0xvd2VyQ2FzZSIsIlRva2VuU3RyZWFtIiwiV2hpdGVzcGFjZVBhdHRlcm4iLCJfX3Rva2VucyIsImN1cnJlbnQiLCJvcGVuX3N0YWNrIiwiY29tbWVudHMiLCJhZGQiLCJpc0VtcHR5IiwibmV3bGluZV9jb3VudCIsIndoaXRlc3BhY2VfYmVmb3JlX3Rva2VuIiwicGFyZW50X3Rva2VuIiwiX190b2tlbnNfbGVuZ3RoIiwiX19wYXJlbnRfdG9rZW4iLCJpbnB1dF9zY2FubmVyIiwiX2xpbmVfcmVnZXhwIiwiX19zZXRfd2hpdGVzcGFjZV9wYXR0ZXJucyIsIndoaXRlc3BhY2VfY2hhcnMiLCJuZXdsaW5lX2NoYXJzIiwiX21hdGNoX3BhdHRlcm4iLCJfbmV3bGluZV9yZWdleHAiLCJtYXRjaGVzIiwiX19zcGxpdCIsIl9jcmVhdGUiLCJfdXBkYXRlIiwicmVnZXhwIiwic3RhcnRfaW5kZXgiLCJuZXh0X21hdGNoIiwiX3N0YXJ0aW5nX3BhdHRlcm4iLCJfdW50aWxfcGF0dGVybiIsIl91bnRpbF9hZnRlciIsInN0YXJ0X2Jsb2NrX3BhdHRlcm4iLCJlbmRfYmxvY2tfcGF0dGVybiIsIl9fZGlyZWN0aXZlc19ibG9ja19wYXR0ZXJuIiwiX19kaXJlY3RpdmVfcGF0dGVybiIsIl9fZGlyZWN0aXZlc19lbmRfaWdub3JlX3BhdHRlcm4iLCJkaXJlY3RpdmVfbWF0Y2giLCJpbnB1dCIsInRlbXBsYXRlX25hbWVzIiwiZGphbmdvIiwiZXJiIiwiaGFuZGxlYmFycyIsInBocCIsInNtYXJ0eSIsIl9fdGVtcGxhdGVfcGF0dGVybiIsIl9kaXNhYmxlZCIsIk9iamVjdCIsImFzc2lnbiIsIl9leGNsdWRlZCIsImhhbmRsZWJhcnNfY29tbWVudCIsImhhbmRsZWJhcnNfdW5lc2NhcGVkIiwiZGphbmdvX3ZhbHVlIiwiZGphbmdvX2NvbW1lbnQiLCJzbWFydHlfY29tbWVudCIsInNtYXJ0eV9saXRlcmFsIiwiX19zZXRfdGVtcGxhdGVkX3BhdHRlcm4iLCJkaXNhYmxlIiwibGFuZ3VhZ2UiLCJleGNsdWRlIiwiX3JlYWRfdGVtcGxhdGUiLCJpdGVtcyIsInBlZWsxIiwiX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fIiwibW9kdWxlSWQiLCJjYWNoZWRNb2R1bGUiLCJfX3dlYnBhY2tfZXhwb3J0c19fIiwiZGVmaW5lIiwiYW1kIiwid2luZG93IiwiZ2xvYmFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/js-beautify/js/lib/beautify.js\n");

/***/ })

};
;